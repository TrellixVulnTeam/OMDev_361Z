<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Moca-RPC</title><meta content="DocBook XSL Stylesheets V1.72.0" name="generator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="Moca"></a><p>Moca-RP<sup>C</sup></p></h1></div><div><h3 class="subtitle"><i>Manuel utilisateur 13.12</i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Philippe</span> <span class="surname">Thomas</span></h3></div></div><div><p class="copyright">Copyright &copy; 2011 Total</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="2" valign="top" align="left"><b>Historique des versions</b></th></tr><tr><td align="left">Version 13.07</td><td align="left">7 Avril 2011</td></tr><tr><td align="left">Version 13.06</td><td align="left">7 F&eacute;vrier 2011</td></tr><tr><td align="left">Version 13.05</td><td align="left">28 Janvier 2011</td></tr><tr><td align="left">Version 13.04</td><td align="left">12 Novembre 2009</td></tr><tr><td align="left">Version 13.01</td><td align="left">10 Juin 2009</td></tr><tr><td align="left">Version 13.00</td><td align="left">20 Fevrier 2009</td></tr><tr><td align="left">Version 12.19</td><td align="left">10 D&eacute;cembre 2007</td></tr><tr><td align="left">Version 12.16</td><td align="left">30 Janvier 2007</td></tr><tr><td align="left">Version 12.14</td><td align="left">24 Ao&ucirc;t 2006</td></tr><tr><td align="left">Version 12.10</td><td align="left">22 Novembre 2005</td></tr><tr><td align="left">Version 12.01</td><td align="left">15 Novembre 2002</td></tr></table></div></div></div><hr></div><div class="toc"><p><b>Table des mati&egrave;res</b></p><dl><dt><span class="section"><a href="#Moca.Intro">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.News.1312">Nouveaut&eacute;s : Version 13.12</a></span></dt><dt><span class="section"><a href="#Moca.News.1307">Nouveaut&eacute;s : Version 13.07</a></span></dt><dt><span class="section"><a href="#Moca.News.1304">Nouveaut&eacute;s : Version 13.04</a></span></dt><dt><span class="section"><a href="#Moca.News.1301">Nouveaut&eacute;s : Version 13.01</a></span></dt><dt><span class="section"><a href="#Moca.News.1300">Nouveaut&eacute;s : Version 13.00</a></span></dt><dt><span class="section"><a href="#Moca.News.1219">Nouveaut&eacute;s : Version 12.19</a></span></dt><dt><span class="section"><a href="#Moca.News.1216">Nouveaut&eacute;s : Version 12.16</a></span></dt><dt><span class="section"><a href="#Moca.News.1214">Nouveaut&eacute;s : Version 12.14</a></span></dt><dt><span class="section"><a href="#Moca.News.1210">Nouveaut&eacute;s : Version 12.10</a></span></dt><dt><span class="section"><a href="#Moca.News.1200">Nouveaut&eacute;s : Version 12.0x</a></span></dt></dl></dd><dt><span class="section"><a href="#Moca.Moca12">Format des R&eacute;seaux de Petri de Moca-RP<sup>C</sup></a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.Moca12.Intro">Introduction</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Options">Rubrique : Options</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Constantes">Rubrique : Constantes (param&egrave;tres nomm&eacute;s)</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Variables">Rubrique : Variables (et expressions)</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Transs">Rubrique : Transitions</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Arrays">Rubrique : Tableaux g&eacute;n&eacute;raux</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Places">Rubrique : Places</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Inits">Rubrique : Initialisations</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.States">Rubrique : Etats statistiques (Observateurs)</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Types">Rubrique : Type de statistiques</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Samples">Exemple d'un r&eacute;seau de Petri</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Results">R&eacute;sultats attendus</a></span></dt></dl></dd><dt><span class="section"><a href="#Moca.IMoca">Interpr&eacute;teur de commandes</a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.IMoca.Intro">Introduction</a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Launch">Lancement de Moca-RP<sup>C</sup></a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Cmd.Base">Commandes de base</a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Cmd.Net">Commandes de gestion des r&eacute;seaux</a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Cmd.Result">Commandes de gestion des r&eacute;sultats</a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Cmd.Format">Commandes de gestion des formats d'affichage</a></span></dt><dt><span class="section"><a href="#Moca.IMoca.Cmd.Util">Commandes Utilitaires</a></span></dt></dl></dd><dt><span class="section"><a href="#Moca.Moca12.Law">Les lois dans Moca-RP<sup>C</sup></a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.Moca12.Law.Intro">G&eacute;n&eacute;ralit&eacute;s</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Law.Delay">Lois de d&eacute;lai de Moca-RP<sup>C</sup></a></span></dt><dt><span class="section"><a href="#Moca.Moca12.Law.Fire">Lois de tir de Moca-RP<sup>C</sup></a></span></dt></dl></dd><dt><span class="section"><a href="#Moca.Moca12.API">Interface de programmation C</a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.Moca12.API.Intro">Lancement de Moca-RP<sup>C</sup></a></span></dt><dt><span class="section"><a href="#Moca.Moca12.API.Use">Utilisation des fonctions/lois externes</a></span></dt><dt><span class="section"><a href="#Moca.Moca12.API.Create">Cr&eacute;ation de la librairie optionnelle <code class="filename">MocaAdd.dll</code></a></span></dt><dt><span class="section"><a href="#Moca.Moca12.API.Define">Description des types/fonctions de l'API</a></span></dt></dl></dd><dt><span class="appendix"><a href="#Moca.Moca10">A. Lecture de fichiers au format Moca10</a></span></dt><dt><span class="appendix"><a href="#Moca.Aralia">B. Lecture de fichiers au format Aralia</a></span></dt><dt><span class="appendix"><a href="#Moca.Compute">C. Calcul de la moyenne et de la variance</a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.Compute.Simul">Lors de la simulation</a></span></dt><dt><span class="section"><a href="#Moca.Compute.Merge">Lors de la fusion de 2 lots</a></span></dt><dd><dl><dt><span class="section"><a href="#Moca.Compute.Merge.Intro">Pr&eacute;sentation</a></span></dt><dt><span class="section"><a href="#Moca.Compute.Merge.Math">D&eacute;veloppements math&eacute;matiques</a></span></dt><dt><span class="section"><a href="#Moca.Compute.Merge.Result">R&eacute;sultats</a></span></dt></dl></dd></dl></dd></dl></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Moca.Intro"></a>Introduction</h2></div></div></div><p> 
		Le logiciel Moca-RP<sup>C</sup> (Monte-Carlo bas&eacute; sur les R&eacute;seaux de Petri) est destin&eacute; &agrave; la simulation
		du comportement des syst&egrave;mes dynamiques complexes dans le but d'obtenir, par un traitement 
		statistique, des r&eacute;sultats concernant leur fiabilit&eacute;, disponibilit&eacute;, productivit&eacute;, ainsi 
		que tout autre param&egrave;tre probabiliste. Le mod&egrave;le du syst&egrave;me &agrave; &eacute;tudier est r&eacute;alis&eacute; sous la 
		forme d'un r&eacute;seau de Petri stochastique interpr&eacute;t&eacute; qui sert de support &agrave; une simulation de 
		Monte-Carlo classique.
	</p><p> 
		En 1996, une collaboration entre ELF Exploration-Production, le Laboratoire Bordelais de 
		Recherche en Informatique (LaBRI) et la soci&eacute;t&eacute; IXI, a conduit au d&eacute;veloppement de la version 
		10 du logiciel Moca-RP<sup>C</sup>. 
		Cette version se distingue de la pr&eacute;c&eacute;dente par son langage d'impl&eacute;mentation (le langage C 
		ANSI au lieu du Fortran) qui a facilit&eacute; l'int&eacute;gration de nouvelles fonctionnalit&eacute;s.
	</p><p> 
		En 2002, une collaboration entre Total-Fina-Elf et la soci&eacute;t&eacute; GFI Consulting a conduit au 
		d&eacute;veloppement de la version 12 du logiciel Moca-RP<sup>C</sup>. 
		Cette version int&egrave;gre principalement, les messages et &eacute;tats statistiques complexes, 
		un interpr&eacute;teur de commande et un d&eacute;but de simulation double-d&eacute;tente.
	</p><p> 
		De 2005 &agrave; 2009, une collaboration entre Total et Dassault-Data-Services a permis de faire &eacute;voluer
		Moca-RP<sup>C</sup> jusqu'&agrave; l'aboutissement d'une version 13 : 
		<div class="itemizedlist"><ul type="disc"><li>
				La version 12.10 int&egrave;gre la possibilit&eacute; d'afficher les r&eacute;sultats des 
				&eacute;tats statistiques &agrave; diff&eacute;rents temps.
			</li><li>
				La version 12.14 permet de charger des arbres de d&eacute;faillance au format 
				Aralia afin de calculer efficacement la fiabilit&eacute; associ&eacute;e aux 
				&eacute;v&eacute;nements redout&eacute;s d&eacute;crits &agrave; l'aide de ces arbres de d&eacute;faillances.
			</li><li>
				La version 13.00 int&egrave;gre un simulateur pas &agrave; pas exploitable par des 
				interfaces utilisateur comme GRIF.
			</li><li>
				La version 13.04 int&egrave;gre un ensemble de m&eacute;canisme simplifiant la mod&eacute;lisation
				utilisateur comme les priorit&eacute;s dynamiques, l'&eacute;valuation s&eacute;quentielle des 
				affectations, les transitions &agrave; m&eacute;moire dynamique, la gestion &eacute;quiprobable 
				des conflits, ...
			</li></ul></div>
  </p><p> 
    Depuis 2010, le d&eacute;veloppement de la version 13 de Moca-RP<sup>C</sup> se poursuit &agrave; travers une 
    collaboration entre Total et SaToDev.
    <div class="itemizedlist"><ul type="disc"><li>
        <span class="news">
        La version 13.07 int&egrave;gre une notion de tableau et la possibilit&eacute; d'ex&eacute;cuter 
        du code lors du tir d'une transition.
        TBC ...
        </span>
      </li></ul></div>
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1312"></a>Nouveaut&eacute;s : Version 13.12</h3></div></div></div><p> 
  <span class="news">
    Ajout des fonctions random() et crc(...)
  </span>
  </p><p> 
  <span class="news">
    Am&eacute;lioration de la commande format (nouvelle directive d'affichage Cst et Var, 
    Utilisation de joker dans les s&eacute;lecteurs, drapeau XML dans la directive Net)
  </span>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1307"></a>Nouveaut&eacute;s : Version 13.07</h3></div></div></div><p> 
	<span class="news">
		TBC
	</span>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1304"></a>Nouveaut&eacute;s : Version 13.04</h3></div></div></div><p> 
		Jusqu'&agrave; pr&eacute;sent les affectations lors du tir d'une transition se faisaient de 
		mani&egrave;re parall&egrave;le de la m&ecirc;me mani&egrave;re que les d&eacute;placements de jetons 
		(on retire tous les jetons des places amonts, puis on ajoute tous les jetons 
		aux places avales).
		Sous la pression de nombreux utilisateurs, il est maintenant possible d'&eacute;valuer
		les affectations de mani&egrave;re s&eacute;quentielle (comme dans un langage de programmation).
		Pour plus d'informations, Cf. <a href="#Moca.Moca12.Transs.Affect" title="Affectations">la section intitul&eacute;e &laquo;&nbsp;Affectations&nbsp;&raquo;</a>.
	</p><p>
		Dans certain cas, par exemple afin de prendre en compte une politique de 
		maintenance diff&eacute;rente suite &agrave; une reconfiguration, il est n&eacute;cessaire de pouvoir
		modifier en cours de simulation la priorit&eacute; de certaines transitions.
		Les priorit&eacute;s dynamiques ont &eacute;t&eacute; introduites pour r&eacute;pondre &agrave; ce besoin
		(Cf. <a href="#Moca.Moca12.Transs.Conflict" title="Priorit&eacute; &amp; Equiprobabilit&eacute;">la section intitul&eacute;e &laquo;&nbsp;Priorit&eacute; &amp; Equiprobabilit&eacute;&nbsp;&raquo;</a>). 
	</p><p> 
		Il est maintenant possible de choisir de mani&egrave;re &eacute;quiprobable une transition
		parmi les transitions en conflit. Cette nouvelle politique de gestion des 
		transitions en conflit exploite &eacute;galement la notion de priorit&eacute; et peut
		&ecirc;tre utilis&eacute; conjointement &agrave; politique actuelle.
		Cf. <a href="#Moca.Moca12.Transs.Conflict" title="Priorit&eacute; &amp; Equiprobabilit&eacute;">la section intitul&eacute;e &laquo;&nbsp;Priorit&eacute; &amp; Equiprobabilit&eacute;&nbsp;&raquo;</a>.
	</p><p> 
		Certaine mod&eacute;lisation pose des probl&egrave;mes de boucles instantan&eacute;es qui obligent les
		utilisateurs &agrave; mettre en place des subterfuges afin de les emp&ecirc;cher (via 
		des messages dans le meilleur des cas, via des lois dirac epsilon ou via ...).
		Il est maintenant possible de pr&eacute;ciser le nombre de tir autoris&eacute; sans incr&eacute;ment 
		du temps avant qu'une transition ne devienne invalide.    
		Cf. <a href="#Moca.Moca12.Transs.Limit" title="Limiter le nombre de tir instantan&eacute;">la section intitul&eacute;e &laquo;&nbsp;Limiter le nombre de tir instantan&eacute;&nbsp;&raquo;</a>.
	</p><p> 
		Cette version apporte &eacute;galement un m&eacute;canisme pour prendre en compte ou non, 
		de mani&egrave;re dynamique, la m&eacute;moire d'une transition. Il est alors possible 
		de mod&eacute;liser un composant sollicit&eacute; avec maintenance corrective et pr&eacute;ventive
		de mani&egrave;re plus juste.
		Cf. <a href="#Moca.Moca12.Transs.Memory" title="Transitions &agrave; m&eacute;moire">la section intitul&eacute;e &laquo;&nbsp;Transitions &agrave; m&eacute;moire&nbsp;&raquo;</a>.
	</p><p> 
		Pour finir, un nouveau type de statistique a &eacute;t&eacute; ajout&eacute; afin de calculer la valeur
		moyenne entre 2 temps de calcul (typiquement cela permet de calculer facilement
		une production moyenne pour chaque ann&eacute;e de production sans &ecirc;tre oblig&eacute; de cr&eacute;er 
		un RdP utilitaire).
		Cf. <a href="#Moca.Moca12.Types" title="Rubrique : Type de statistiques">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Type de statistiques&nbsp;&raquo;</a>.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1301"></a>Nouveaut&eacute;s : Version 13.01</h3></div></div></div><p> 
		Les formats d'affichage ont &eacute;t&eacute; &eacute;tendus afin de permettre d'afficher les
		r&eacute;sultats au format XML. Pour plus d'informations, Cf. <a href="#Moca.IMoca.Cmd.Format" title="Commandes de gestion des formats d'affichage">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des formats d'affichage&nbsp;&raquo;</a>.
	</p><p>
		Afin de permettre de contr&ocirc;ler le d&eacute;roulement d'une simulation et en particulier
		arr&ecirc;ter la simulation sans envoyer de signal SIGINT (ce qui n'est pas possible
		en Java par exemple), il est maintenant possible d'arr&ecirc;ter la simulation
		lorsque la pr&eacute;sence d'un fichier lock est av&eacute;r&eacute;e (Cf. <a href="#Moca.IMoca.Cmd.Net.Simul.Locker" title="Arr&ecirc;t de la simulation de mani&egrave;re externe {set simul locker ...}">la section intitul&eacute;e &laquo;&nbsp;Arr&ecirc;t de la simulation de mani&egrave;re externe {<span><strong class="command">set simul locker ...</strong></span>}&nbsp;&raquo;</a> 
	</p><p> 
		Il est maintenant possible d'afficher la progression d'une simulation en cours
		en pourcentage du nombre total d'histoire &agrave; r&eacute;aliser. Cela permet de se rendre
		compte de l'avancement de la simulation. Pour plus d'informations, Cf. <a href="#Moca.IMoca.Cmd.Net.Simul" title="Lancement d'une simulation {simul ...}">la section intitul&eacute;e &laquo;&nbsp;Lancement d'une simulation {<span><strong class="command">simul ...</strong></span>}&nbsp;&raquo;</a>.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1300"></a>Nouveaut&eacute;s : Version 13.00</h3></div></div></div><p> 
		La version 13.00 int&egrave;gre un simulateur pas &agrave; pas avec possibilit&eacute;
		de revenir en arri&egrave;re, de tirer une transition &agrave; un temps sp&eacute;cifique, 
		de visualiser l'&eacute;ch&eacute;ancier, la valeur d'une variable ou le
		marquage d'une place.
		Ce simulateur pas &agrave; pas est directement utilis&eacute; par les interfaces 
		graphiques (comme GRIF) afin de permettre de d&eacute;bugger un r&eacute;seau de Petri.
	</p><p> 
		Lorsqu'une exception intervient lors de la simulation (comme une division
		par z&eacute;ro, un nombre de tir instantan&eacute; sup&eacute;rieur &agrave; la limite, ...) le message
		d'erreur int&egrave;gre maintenant la valeur de la graine du g&eacute;n&eacute;rateur al&eacute;atoire au 
		d&eacute;but de l'histoire ayant engendr&eacute; l'erreur.
		Cette information a son importance depuis qu'il est possible de d&eacute;bugger un
		r&eacute;seau de Petri. En effet, lors du lancement de la simulation graphique, il 
		suffira de pr&eacute;ciser la graine du g&eacute;n&eacute;rateur al&eacute;atoire pour se positionner
		dans le m&ecirc;me cadre que lors de l'apparition de l'exception et ainsi en comprendre
		l'origine.  
	</p><p>
		 Le calcul &agrave; diff&eacute;rents temps pour les &eacute;tats statistiques fonctionnait jusqu'&agrave;
		 pr&eacute;sent &agrave; partir des valeurs des &eacute;tats statistiques avant le tir de la transition.
		 Cela pouvait poser des probl&egrave;mes de compr&eacute;hension des r&eacute;sultats lorsqu'une 
		 transition devait &ecirc;tre tir&eacute;e de mani&egrave;re d&eacute;terministe &agrave; un instant t et 
		 qu'un &eacute;tat statistique devait &ecirc;tre calcul&eacute; &eacute;galement &agrave; t. La valeur retenue
		 pour l'&eacute;tat statistique correspondait &agrave; la valeur avant le tir de la transition.
		 Ce n'est maintenant plus le cas. La valeur retenue correspond maintenant &agrave; la 
		 valeur apr&egrave;s le tir de toutes transitions devant &ecirc;tre tir&eacute;es &agrave; l'instant consid&eacute;r&eacute;.
		 Les &eacute;tats statistiques n'&eacute;tant que des observateurs, ils sont donc consid&eacute;r&eacute;s
		 comme moins prioritaires qu'une quelconque transition.   
	</p><p>
		En revanche, il est toujours int&eacute;ressant de conna&icirc;tre la valeur d'un &eacute;tat 
		statistique juste avant un tir d'une transition d&eacute;terministe. Cela permet de capter
		les ph&eacute;nom&egrave;nes de discontinuit&eacute;s d&eacute;terministes. Il est donc possible de calculer
		un &eacute;tat statistique &agrave; <code class="code">t - <span class="emphasis"><em>epsilon</em></span></code> 
		(c'est &agrave; dire juste avant <code class="code">t</code>).
		Pour plus d'informations, voir <a href="#Moca.Moca12.Options.Times">
		la syntaxe associ&eacute;e aux temps de calcul</a>.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1219"></a>Nouveaut&eacute;s : Version 12.19</h3></div></div></div><p> 
		Des fonctions de gestion des banques de r&eacute;sultat ont &eacute;t&eacute; ajout&eacute;es afin
		de permettre la parall&eacute;lisation de la simulation &agrave; l'ext&eacute;rieur de Moca-RP<sup>C</sup>.
		Pour plus d'informations, voir <a href="#Moca.IMoca.Cmd.Result" title="Commandes de gestion des r&eacute;sultats">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des r&eacute;sultats&nbsp;&raquo;</a>.
	</p><p> 
		Un nouveau format d'affichage des histogrammes a &eacute;t&eacute; mis en place afin 
		d'afficher les SIL (Safety Integrity Level) d'une grandeur et plus g&eacute;n&eacute;ralement
		d'afficher un histogramme avec des intervalles choisis.
		Pour plus d'informations, voir <a href="#Moca.IMoca.Cmd.Format.HstSt" title="Directive pour les histogrammes des &eacute;tats statistiques">la section intitul&eacute;e &laquo;&nbsp;Directive pour les histogrammes des &eacute;tats statistiques&nbsp;&raquo;</a>.
	</p><p> 
		Une seconde loi de tir &agrave; la sollicitation a &eacute;galement vu le jour afin de
		permettre d'associer explicitement les probabilit&eacute;s d'occurrence aux places.
		Pour plus d'informations, voir <a href="#Moca.Moca12.Law.Fire.sol" title="Loi de tir &agrave; la sollicitation {sol|sol2 ...}">la section intitul&eacute;e &laquo;&nbsp;Loi de tir &agrave; la sollicitation {<span><strong class="command">sol|sol2 ...</strong></span>}&nbsp;&raquo;</a>.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1216"></a>Nouveaut&eacute;s : Version 12.16</h3></div></div></div><p> 
		Il est maintenant possible d'associer un nom aux tableaux au sein de la 
		description d'un r&eacute;seau de Petri (Cf. <a href="#Moca.Moca12.Arrays" title="Rubrique : Tableaux g&eacute;n&eacute;raux">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Tableaux g&eacute;n&eacute;raux&nbsp;&raquo;</a>).
	</p><p> 
		L'API de programmation a &eacute;t&eacute; mise &agrave; jour afin de pouvoir d&eacute;finir des fonctions
		externes &agrave; Moca. Ces fonctions doivent &ecirc;tre &eacute;crites en C/C++ et compil&eacute;es
		au sein d'une librairie dynamique (MocaAdd.dll sous Windows). Pour plus 
		d'informations, voir <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1214"></a>Nouveaut&eacute;s : Version 12.14</h3></div></div></div><p> 
		De plus en plus d'&eacute;tudes sont r&eacute;alis&eacute;s afin de d&eacute;terminer les SIL (Safety Integrity Level) 
		d'une installation ou d'un syst&egrave;me de protection. 
		Ces &eacute;tudes sont r&eacute;alis&eacute;es &agrave; l'aide de Aralia WorkShop. Le calcul de SIL est bas&eacute; sur une 
		estimation de la disponibilit&eacute; &agrave; chaque instant de la vie du syst&egrave;me. 
	</p><p> 
		Les arbres de d&eacute;faillance ne permettent de calculer que la disponibilit&eacute; du syst&egrave;me et 
		&eacute;ventuellement une approximation de sa fiabilit&eacute; lorsque tous les &eacute;v&eacute;nements ont un 
		comportement de panne et de r&eacute;paration d&eacute;finit &agrave; l'aide de loi exponentielle. 
		Dans les autres cas, Aralia n'est pas capable de fournir de mani&egrave;re relativement 
		s&ucirc;re la fiabilit&eacute; du syst&egrave;me. 
	</p><p> 
		Le module de conversion de formule Aralia a &eacute;t&eacute; industrialis&eacute; afin de calculer facilement 
		la fiabilit&eacute; des variables sommets (&agrave; priori les &eacute;v&eacute;nements redout&eacute;s) des formules Aralia.
	</p><p> 
		En particulier, les diff&eacute;rentes lois de test p&eacute;riodique, ainsi que la loi Weibull ont &eacute;t&eacute; 
		traduites en r&eacute;seau de Petri &eacute;quivalent.
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1210"></a>Nouveaut&eacute;s : Version 12.10</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1210.Times"></a>R&eacute;sultats pour diff&eacute;rents temps de calcul</h4></div></div></div><p> 
			Il est parfois utile de suivre l'&eacute;volution d'un &eacute;tat statistique afin de tracer des 
			courbes de disponibilit&eacute;, productivit&eacute;, fiabilit&eacute;, ... en fonction du temps. 
			Pr&eacute;alablement, les calculs statistiques ne se faisaient qu'au temps de mission du syst&egrave;me. 
			Pour r&eacute;aliser de telles courbes, il fallait relancer autant de fois Moca-RP<sup>C</sup> que l'on 
			souhaitait de points interm&eacute;diaires ce qui conduisait &agrave; des temps de calcul parfois tr&egrave;s longs. 
			Ce temps est proportionnel au nombre de points souhait&eacute; soit parfois 2h pour un 
			calcul unitaire de l'ordre de 2 &agrave; 3 minutes. 
		</p><p> 
			Il est maintenant possible de sp&eacute;cifier les diff&eacute;rents temps de calcul, soit &agrave; l'aide 
			d'une liste de temps, soit en pr&eacute;cisant un temps initial, un temps final et un pas de temps 
			pour l'ensemble des &eacute;tats statistiques ou pour uniquement un &eacute;tat statistique consid&eacute;r&eacute;.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1210.Prio"></a>Ajout des priorit&eacute;s sur les transitions</h4></div></div></div><p> 
			La priorit&eacute; est utilis&eacute;e pendant la simulation lors de conflit possible sur plusieurs 
			transitions tirables au m&ecirc;me instant. 
			Auparavant, seul le rang de description de la transition permettait de d&eacute;terminer la 
			priorit&eacute; de la transition. 
			Il est maintenant possible de sp&eacute;cifier un entier positif pr&eacute;cisant le degr&eacute; de priorit&eacute; 
			de la transition.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1210.Operator"></a>Ajout d'op&eacute;rateurs</h4></div></div></div><p> 
			Les op&eacute;rateurs suivant ont &eacute;t&eacute; ajout&eacute;s comme op&eacute;rateur valide dans les descriptions Moca-RP<sup>C</sup> :
			<div class="itemizedlist"><ul type="disc"><li>
					<code class="code">delay()</code> correspondant &agrave; la dur&eacute;e de la simulation (&eacute;quivalent 
					&agrave; une constante &eacute;gale &agrave; l'option <code class="code">duration</code> du r&eacute;seau de Petri)
				</li><li>
					<code class="code">@()(e1, ... ,en)</code> (o&ugrave; <code class="code">e1, ... , en</code> sont des expressions 
					bool&eacute;ennes) est &eacute;quivalent &agrave; l'op&eacute;rateur <code class="code">#(e1, ... ,en)</code> du langage 
					AltaRica DataFlow (Il a &eacute;t&eacute; ajout&eacute; afin de pouvoir traduire des descriptions AltaRica 
					en Moca-RP<sup>C</sup>)
				</li></ul></div>
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.News.1200"></a>Nouveaut&eacute;s : Version 12.0x</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1200.Expr"></a>Modification du pouvoir d'expression</h4></div></div></div><p> 
			Les messages manipul&eacute;s dans la version de 10 de Moca-RP<sup>C</sup> ne sont que bool&eacute;ens. 
			La version 12 enrichit le pouvoir d'expression du mod&egrave;le, en permettant 
			l'utilisation des variables r&eacute;elles, enti&egrave;res ou bool&eacute;ennes. 
			&Agrave; partir de ces variables et constantes, il est possible de construire, 
			&agrave; l'aide d'op&eacute;rateurs, des expressions complexes qui sont utilis&eacute;es dans 
			diff&eacute;rentes parties de descriptions 
			(en particulier les &eacute;missions/r&eacute;ceptions de messages).
		</p><p> 
			De plus, la version 12 de Moca-RP<sup>C</sup> scinde clairement les lois qui d&eacute;terminent 
			le d&eacute;lai de la transition de celles qui sp&eacute;cifient la mani&egrave;re de tirer la 
			transition. 
			Cette id&eacute;e permet de d&eacute;finir beaucoup plus simplement (et proprement) 
			les d&eacute;faillances &agrave; la sollicitation. 
			En effet, les d&eacute;faillances &agrave; la sollicitation modifient les r&egrave;gles de tir 
			habituelles d'une transition puisque seul le marquage d'une place avale est modifi&eacute;.
		</p><p> 
			Le format de description des r&eacute;seaux de Petri a donc &eacute;t&eacute; modifi&eacute; afin de pouvoir :
			<div class="itemizedlist"><ul type="disc"><li>
					D&eacute;clarer des constantes et des variables bool&eacute;ennes, enti&egrave;res ou r&eacute;elles
				</li><li>
					D&eacute;finir ces variables &agrave; l'aide d'expressions complexes prenant en compte 
					les op&eacute;rateurs math&eacute;matiques et logiques usuels (+, -, *, / &amp;, |, !, ite, &hellip;) 
					ainsi que des op&eacute;rateurs sp&eacute;cifiques aux r&eacute;seaux de Petri manipul&eacute;s 
					dans Moca-RP<sup>C</sup> (#i pour le marquage de la place i, min(&hellip;) et max(&hellip;) 
					pour les fonctions retournant le minimum et le maximum de leurs op&eacute;rateurs, 
					nlog(m, e) et unif(min, max) pour des g&eacute;n&eacute;rateurs de nombres al&eacute;atoires 
					utilis&eacute;s dans la simulation double-d&eacute;tente, &hellip;).
				</li><li>
					D&eacute;finir la liste de transition (dans un format proche de celui 
					actuellement utilis&eacute; dans la version 10.04) pr&eacute;cisant pour chaque transition : 
					son nom, ses arcs amonts et avals, ses gardes (une liste d'expressions devant 
					&ecirc;tre diff&eacute;rentes de z&eacute;ro pour rendre la transition valide), ses affectations 
					(une liste de variables prenant une expression comme valeur au moment o&ugrave; la 
					transition est tir&eacute;e), ses lois de d&eacute;lai et de tir d&eacute;finis &agrave; l'aide de 
					param&egrave;tres (eux m&ecirc;mes d&eacute;crits &agrave; l'aide d'expressions), des &eacute;ventuels drapeaux 
					permettant de sp&eacute;cifier si la transition est &agrave; m&eacute;moire ou pas et si 
					l'utilisateur souhaite obtenir un histogramme ou non.
				</li><li>
					Sp&eacute;cifier le nom de chacune des places du r&eacute;seau
				</li><li>
					D&eacute;finir le marquage initial des places, ainsi que l'affectation initiale 
					des variables
				</li><li>
					D&eacute;finir les &eacute;tats statistiques &agrave; partir d'expressions complexes.
				</li></ul></div>
		</p><p> 
			Les param&egrave;tres des lois (de d&eacute;lai et de tir) sont des expressions dont la valeur d&eacute;pend 
			du moment o&ugrave; la transition est valide (loi de d&eacute;lai) ou tir&eacute;e (loi de tir). 
			Ceci g&eacute;n&eacute;ralise les lois optionnelles de la version 10 de Moca-RP<sup>C</sup>. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1200.Interprete"></a>Interpr&eacute;teur de commandes</h4></div></div></div><p> 
			La version 10 de Moca-RP<sup>C</sup> fonctionne de mani&egrave;re batch. On sp&eacute;cifie, sur la ligne de 
			commande appelant le logiciel, le fichier d'entr&eacute;e &agrave; traiter, le fichier de sortie 
			et un certain nombre de directives optionnelles. 
			Le logiciel traite alors le fichier d'entr&eacute;e, g&eacute;n&egrave;re le fichier de sortie et rend la main. 
			Pour refaire une simulation, il faut modifier le fichier d'entr&eacute;e et relancer le calcul.
		</p><p> 
			Les diff&eacute;rents projets de ces derni&egrave;res ann&eacute;es (Aralia, H&eacute;v&eacute;a, Alo&egrave;s, &hellip;) montrent 
			l'int&eacute;r&ecirc;t des interpr&eacute;teurs de commandes, tant en terme d'utilisation 
			(choix du d&eacute;roulement des op&eacute;rations, modifications des donn&eacute;es, &hellip;) 
			que de programmation (facilit&eacute; d'ajout de fonctionnalit&eacute;s, de format d'affichage, &hellip;). 
		</p><p> 
			La version 12 de Moca-RP<sup>C</sup> int&egrave;gre un interpr&eacute;teur de commandes permettant  :
			<div class="itemizedlist"><ul type="disc" compact><li>
					La cr&eacute;ation et la gestion de plusieurs r&eacute;seaux de Petri
				</li><li>
					Le chargement des r&eacute;seaux au format Moca-RP<sup>C</sup> version 10.04 et pr&eacute;c&eacute;dents 
				</li><li>
					Le chargement des r&eacute;seaux au format Moca-RP<sup>C</sup> version 12
				</li><li>
					La sauvegarde (et / ou l'affichage) des r&eacute;seaux au format Moca-RP<sup>C</sup> version 12
				</li><li>
					L'arr&ecirc;t et la reprise d'une simulation permettant la v&eacute;rification d'un RdP sur 
					un petit nombre d'histoires, puis le lancement de la simulation pour un grand 
					nombre d'histoires (sans perdre les r&eacute;sultats pr&eacute;c&eacute;dents).
				</li><li>
					L'affichage de tout ou d'une partie des r&eacute;sultats vers un ou plusieurs fichiers 
					(les histogrammes pouvant &ecirc;tre redirig&eacute;s vers un fichier sp&eacute;cifique afin de 
					les traiter sans filtrer les autres donn&eacute;es)
				</li><li>
					Une aide en ligne, une commande g&eacute;n&eacute;rique afin d'acc&eacute;der au syst&egrave;me, 
					une gestion de chronom&egrave;tres, ...
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1200.SimulDouble"></a>Simulation double-d&eacute;tente</h4></div></div></div><p> 
			Le but d'une simulation double-d&eacute;tente est d'&eacute;valuer l'influence des incertitudes 
			des param&egrave;tres d'entr&eacute;e sur la dispersion du (des) r&eacute;sultat(s) de sortie.
		</p><p> 
			Comme proposer en [8], la premi&egrave;re id&eacute;e pour tenir compte de la dispersion des 
			param&egrave;tres d'entr&eacute;e dans une simulation de Monte Carlo d'un RdP, est de faire deux 
			tirages au hasard en cascade : un  pour choisir le jeu de param&egrave;tres et 
			la seconde pour la simulation proprement dite.
		</p><p> 
			Cela va consister &agrave; tirer un jeu de param&egrave;tres au hasard et de r&eacute;aliser n histoires 
			avec ce jeu, puis de recommencer m fois avec m autres jeux de param&egrave;tres. 
			Ainsi on obtient m &eacute;chantillons de n valeurs chacun dont on va pouvoir estimer 
			les param&egrave;tres statistiques.
		</p><p> 
			Comme cette impl&eacute;mentation correspond &agrave; un premier essai de simulation double-d&eacute;tente, 
			on ne conserve actuellement que la moyenne de la seconde simulation. 
			On obtient alors un &eacute;chantillon de m moyennes sur lequel on estime les param&egrave;tres statistiques.
		</p><p> 
			Afin d'aller plus loin, il est possible d'afficher une trace des m r&eacute;sultats 
			interm&eacute;diaires (moyenne et variance de chaque &eacute;chantillon de n valeurs). 
			Il est alors possible de faire un post-traitement.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.News.1200.MemResult"></a>M&eacute;morisation des r&eacute;sultats</h4></div></div></div><p> 
			Un des sc&eacute;narios d'utilisation de Moca-RP<sup>C</sup> consiste &agrave; l'utiliser en &laquo; Batch &raquo;. 
			On lance une simulation pour un r&eacute;seau de Petri avec des param&egrave;tres de simulation 
			donn&eacute;s (nombre d'histoires, temps de simulation maximum, &hellip;), puis on sort de l'interpr&eacute;teur. 
		</p><p> 
			Il est possible que les r&eacute;sultats obtenus ne satisfassent pas l'utilisateur dans la 
			mesure o&ugrave; ils ne sont pas assez pr&eacute;cis. 
			Une des deux raisons suivantes explique ce fait : le nombre d'histoires &eacute;tait insuffisant 
			ou le temps de simulation maximum a &eacute;t&eacute; atteint avant la fin de la simulation.
		</p><p> 
			Comme la simulation a &eacute;t&eacute; lanc&eacute;e en &laquo; batch &raquo;, il n'est pas possible de reprendre 
			la simulation l&agrave; o&ugrave; elle s'&eacute;tait arr&ecirc;t&eacute;e (contrairement &agrave; une utilisation en mode interpr&eacute;t&eacute;). 
		</p><p> 
			L'id&eacute;e consiste &agrave; pouvoir m&eacute;moriser les r&eacute;sultats dans un fichier afin de pouvoir 
			les recharger par la suite et poursuivre la simulation.
		</p><p> 
			Cette id&eacute;e a &eacute;t&eacute; mise en &#339;uvre dans la gestion des banques de r&eacute;sultats.
		</p></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Moca.Moca12"></a>Format des R&eacute;seaux de Petri de Moca-RP<sup>C</sup></h2></div></div></div><p> 
		Cette premi&egrave;re section d&eacute;crit le format d'entr&eacute;e des r&eacute;seaux de Petri 
		pour la version actuelle de Moca-RP<sup>C</sup>. 
		Il est &agrave; noter qu'il est possible d'ouvrir &agrave; l'aide de cette version 
		des fichiers provenant des versions 8, 9 et 10 de Moca-RP<sup>C</sup>. 
		Veuillez-vous r&eacute;f&eacute;rer &agrave; l'annexe A pour plus d'informations sur ce sujet.
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Intro"></a>Introduction</h3></div></div></div><p> 
			Les r&eacute;seaux de Petri sont charg&eacute;s au sein de l'interface &agrave; 
			l'aide de la commande <span><strong class="command">load Moca "&lt;file&gt;";</strong></span> 
			o&ugrave; <code class="literal">&lt;file&gt;</code> est le nom (entour&eacute; de guillemets) du fichier 
			&agrave; charger contenant un ou plusieurs r&eacute;seaux de Petri. 
		</p>
			Ce format de donn&eacute;es est le seul qui permet de d&eacute;finir un r&eacute;seau en 
			prenant en compte toutes les possibilit&eacute;s de Moca-RP<sup>C</sup>. 
			Les r&eacute;seaux en m&eacute;moire sont affich&eacute;s dans ce format lorsque l'on utilise 
			la commande <span><strong class="command">display net &lt;net&gt;;</strong></span> 
			(Cf. <a href="#Moca.IMoca.Cmd.Net.Display" title="Affichage d'un r&eacute;seau {display net ...}">la section intitul&eacute;e &laquo;&nbsp;Affichage d'un r&eacute;seau {<span><strong class="command">display net ...</strong></span>}&nbsp;&raquo;</a>).
		<p> 
			Un fichier de description Moca-RP<sup>C</sup> peut contenir la 
			description de plusieurs r&eacute;seaux de Petri. Chaque r&eacute;seau de Petri est d&eacute;crit 
			&agrave; l'aide d'un bloc ayant la forme suivante :
		</p><pre class="programlisting"> net &lt;id-net&gt; {
  /* Diff&eacute;rentes rubriques pour constituer le RdP */
}; </pre><p> 
			o&ugrave; <code class="code">&lt;id-net&gt;</code> est le nom du r&eacute;seau de Petri d&eacute;fini 
			dans le bloc qui suit. Ce dernier est constitu&eacute; de diff&eacute;rentes 
			rubriques qui ne sont pas forcement ordonn&eacute;es. La seule 
			limite consiste &agrave; d&eacute;clarer une variable avant de l'utiliser. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Options"></a>Rubrique : Options</h3></div></div></div><p> 
		Cette rubrique permet d'ajouter des informations sp&eacute;cifiques  et inclassables, 
		tel qu'un titre (ou une description) associ&eacute; au r&eacute;seau de Petri ou la dur&eacute;e 
		d'une histoire.
	</p><p> 
		Chacune des options est pr&eacute;c&eacute;d&eacute;e du mot-clef g&eacute;n&eacute;ral <code class="code">OPT:</code> suivi 
		d'un mot-clef sp&eacute;cifique &agrave; l'option et de sa valeur. 
		Seules les options suivantes sont permises : 
		<div class="itemizedlist"><ul type="disc" compact><li>
				<code class="code">title</code> suivi d'une cha&icirc;ne de caract&egrave;res entre guillemets 
				permet d'associer un titre au r&eacute;seau de Petri 
			</li><li>
				<code class="code">duration</code> suivi d'un entier ou d'un r&eacute;el permet de sp&eacute;cifier 
				la dur&eacute;e d'une histoire. Cette valeur doit &eacute;videmment &ecirc;tre coh&eacute;rente 
				avec les lois de d&eacute;lai du r&eacute;seau. 
			</li><li><a name="Moca.Moca12.Options.Times"></a>
				<code class="code">times &lt;times&gt;</code> permet de pr&eacute;ciser les diff&eacute;rents 
				temps de calcul pour les &eacute;tats statistiques. 
				La directive <code class="code">&lt;times&gt;</code> peut s'&eacute;crire de deux mani&egrave;res : 
				<div class="itemizedlist"><ul type="circle" compact><li>
						<code class="code">at t<sub>1</sub>, ..., t<sub>i</sub>, ...t<sub>n</sub></code> : 
						pour pr&eacute;ciser une liste de temps explicite. Le ou les 
						<code class="code">t<sub>i</sub></code> sont des nombres
						r&eacute;els positifs ou nuls. Ils peuvent &ecirc;tre suivis du caract&egrave;re <code class="code">'-'</code>
						pour demander explicitement &agrave; faire le calcul avant le tir des
						transitions devant se faire &agrave; <code class="code">t<sub>i</sub></code>.   
					</li><li>
						<code class="code">from min to max step inc</code> : pour g&eacute;n&eacute;rer une liste 
						de temps de <code class="code">min</code> &agrave; <code class="code">max</code> par pas 
						de <code class="code">inc</code>. L'incr&eacute;ment <code class="code">inc</code> peut &ecirc;tre suivi
						du caract&egrave;re <code class="code">'-'</code> pour des observations &agrave; 
						<code class="code">t- <span class="emphasis"><em>epsilon</em></span></code>.
					</li></ul></div>
			</li><li>
				<code class="code">add_censured_hst</code> suivi d'un bool&eacute;en permet d'activer(/d&eacute;sactiver) 
				l'ajout des donn&eacute;es censur&eacute;es au sein des histogrammes des transitions.
			</li></ul></div>
	</p><p>
		Exemple 1 : 
		<pre class="programlisting">  OPT: title     "DEFAULT TITLE" ;
  OPT: duration  100.00 ;
  OPT: times from 0.0 to 100.0 step 10.0 ;</pre>
	</p><p>
		Exemple 2 : 
		<pre class="programlisting">  OPT: times at 0, 5, 10-, 10, 15, 20-, 20;</pre>
		Si des tirs de transitions ont lieu &agrave; t = 10 et/ou &agrave; t = 20, les &eacute;tats statistiques
		seront calcul&eacute;s juste avant et juste apr&egrave;s le tir de ces transitions. 
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Constantes"></a>Rubrique : Constantes (param&egrave;tres nomm&eacute;s)</h3></div></div></div><p> 
		Il est possible de d&eacute;clarer des constantes qui peuvent &ecirc;tre 
		bool&eacute;ennes (<code class="code">bool</code>), enti&egrave;res (<code class="code">int</code>) ou r&eacute;elles 
		(<code class="code">float</code>). 
		La d&eacute;claration d'une constante s'effectue en respectant la syntaxe suivante : 
			<pre class="programlisting"> 
const &lt;type&gt; &lt;ident&gt; = &lt;expr&gt; ;
			</pre>
		o&ugrave; <code class="code">&lt;type&gt;</code> est un des mots-cl&eacute;s <code class="code">bool</code>, 
		<code class="code">int</code> ou <code class="code">float</code>, <code class="code">&lt;ident&gt;</code> est le nom 
		(identificateur) de la constante et <code class="code">&lt;expr&gt;</code> est une 
		expression constante, c'est &agrave; dire ne contenant pas de variable. 
	</p><p>
		Exemple : 
		<pre class="programlisting">const float LAMBDA1 = 1e-5 ;  /* un param&egrave;tre de loi g&eacute;n&eacute;rique */
const int JETONS = 12 ;   /* pour l'initialisation d'une place */</pre>
	</p><p> 
		L'avantage de ces param&egrave;tres nomm&eacute;s est qu'ils peuvent &ecirc;tre utilis&eacute;s 
		pour param&eacute;trer le r&eacute;seau. On peut les employer en particulier pour 
		d&eacute;finir le poids des arcs afin de modifier le comportement du r&eacute;seau 
		de Petri d'une simulation &agrave; l'autre (contrairement aux variables).
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Variables"></a>Rubrique : Variables (et expressions)</h3></div></div></div><p> 
		Les paragraphes <a href="#Moca.Moca12.Variables.NumExpr" title="Expressions num&eacute;riques">la section intitul&eacute;e &laquo;&nbsp;Expressions num&eacute;riques&nbsp;&raquo;</a> et 
		<a href="#Moca.Moca12.Variables.BoolExpr" title="Expressions bool&eacute;ennes">la section intitul&eacute;e &laquo;&nbsp;Expressions bool&eacute;ennes&nbsp;&raquo;</a> 
		donnent la syntaxe des expressions pouvant &ecirc;tre 
		utilis&eacute;es pour les gardes, affectations et &eacute;tats statistiques du r&eacute;seau.
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Variables.Declare"></a>D&eacute;clarations</h4></div></div></div><p> 
			Avant d'&ecirc;tre utilis&eacute;es, les variables doivent &ecirc;tre d&eacute;clar&eacute;es en utilisant 
			une des syntaxes suivantes : 
				<pre class="programlisting">&lt;type&gt; &lt;ident&gt; ;
&lt;type&gt; &lt;ident&gt; = &lt;expr&gt; ;</pre>
			o&ugrave; <code class="code">&lt;type&gt;</code> est un des mots-cl&eacute;s <code class="code">bool</code>, 
			<code class="code">int</code> ou <code class="code">float</code>, <code class="code">&lt;ident&gt;</code> est le nom 
			(identificateur) de la variable. 
		</p><p>
			Dans la seconde syntaxe, on d&eacute;finit la  variable <code class="code">&lt;ident&gt;</code> 
			&agrave; partir de l'expression <code class="code">&lt;expr&gt;</code>. 
		</p><p>
			Cette affectation peut aussi se faire en deux temps : 
				<pre class="programlisting">&lt;type&gt; &lt;ident&gt; ;
&lt;ident&gt; = &lt;expr&gt; ;</pre>
		</p><p>
			Exemple : L'exemple qui suit d&eacute;clare quatre variables bool&eacute;ennes, 
			la derni&egrave;re &eacute;tant d&eacute;finie en fonction des trois premi&egrave;res. 
			<pre class="programlisting">bool a; bool b; bool c;
bool r = (a &amp; b) | (!a &amp; c);</pre>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Variables.NumExpr"></a>Expressions num&eacute;riques</h4></div></div></div><p> 
			Elles sont form&eacute;es &agrave; partir des variables et constantes num&eacute;riques 
			(c.-&agrave;-d. enti&egrave;res ou r&eacute;elles) et des op&eacute;rateurs <code class="code">+</code>, 
			<code class="code">-</code> (binaire), <code class="code">-</code> (unaire), <code class="code">*</code>, 
			<code class="code">/</code>, <code class="code">#</code>, des parenth&egrave;ses et de fonctions math&eacute;matiques. 
		</p><p>
			Une expression num&eacute;rique peut &ecirc;tre : 
			<div class="itemizedlist"><ul type="disc" compact><li>
					une constante enti&egrave;re ou r&eacute;elle 
					(Cf. <a href="#Moca.Moca12.Constantes" title="Rubrique : Constantes (param&egrave;tres nomm&eacute;s)">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Constantes (param&egrave;tres nomm&eacute;s)&nbsp;&raquo;</a>) ; 
				</li><li>
					une variable enti&egrave;re ou r&eacute;elle 
					(Cf. <a href="#Moca.Moca12.Variables.Declare" title="D&eacute;clarations">la section intitul&eacute;e &laquo;&nbsp;D&eacute;clarations&nbsp;&raquo;</a>) ; 
				</li><li>
					un nombre entier ou r&eacute;el ; 
				</li><li>
					<code class="code">int(expr)</code> (o&ugrave; <code class="code">expr</code> est une expression 
					num&eacute;rique) est une conversion d'une expression en une expression 
					enti&egrave;re. La valeur de <code class="code">int(expr)</code> est la valeur de 
					<code class="code">expr</code> arrondie &agrave; sa partie enti&egrave;re inf&eacute;rieure ; 
				</li><li>
					<code class="code">float(expr)</code> (o&ugrave; <code class="code">expr</code> est une expression 
					num&eacute;rique) est une conversion de l'expression <code class="code">expr</code> en 
					une expression r&eacute;elle ; 
				</li><li>
					<code class="code">-expr</code> (o&ugrave; <code class="code">expr</code> est une expression num&eacute;rique)
					a pour valeur l'oppos&eacute;e de celle de <code class="code">expr</code> ; 
				</li><li>
					<code class="code">(expr)</code> est une expression num&eacute;rique qui a la m&ecirc;me 
					valeur que <code class="code">expr</code> ; 
				</li><li>
					<code class="code">#i</code> (o&ugrave; <code class="code">i</code> est un entier &gt; 0) qui est 
					&eacute;gale au marquage de la place num&eacute;ro <code class="code">i</code> du r&eacute;seau ; 
				</li><li>
					Les op&eacute;rations arithm&eacute;tiques usuelles <code class="code">e1+e2</code>, 
					<code class="code">e1-e2</code>, <code class="code">e1*e2</code> et <code class="code">e1/e2</code> 
					(o&ugrave; <code class="code">e1</code> et <code class="code">e2</code> sont deux expressions du 
					m&ecirc;me type c'est &agrave; dire soit enti&egrave;res, soit r&eacute;elles) ; 
				</li><li>
					L'op&eacute;rateur <code class="code">e1%e2</code> (o&ugrave; <code class="code">e1</code> et <code class="code">e2</code>
					sont deux expressions enti&egrave;res) a pour valeur le reste de la division 
					enti&egrave;re de <code class="code">e1</code> par <code class="code">e2</code> ;
				</li><li>
					<code class="code">unif(e1,e2)</code> (o&ugrave; <code class="code">e1</code> et <code class="code">e2</code> 
					sont deux expressions r&eacute;elles constantes) est un g&eacute;n&eacute;rateur 
					de nombres al&eacute;atoires suivant une distribution uniforme
					dans l'intervalle [<code class="code">e1</code>,<code class="code">e2</code>] (voir ci-dessous) ; 
				</li><li>
					<code class="code">nlog(m,e)</code> (o&ugrave; <code class="code">m</code> et <code class="code">e</code> sont deux 
					expressions r&eacute;elles constantes) est un g&eacute;n&eacute;rateur de nombres 
					al&eacute;atoires suivant une distribution lognormale centr&eacute;e en la 
					valeur moyenne <code class="code">m</code> et se trouvant avec une probabilit&eacute; de 90% 
					dans l'intervalle [<code class="code">m/e</code>,<code class="code">m*e</code>] (voir ci-dessous) ; 
				</li><li>
					<code class="code">min(e1, ... ,en)</code> et <code class="code">max(e1, ... ,en)</code> (o&ugrave; 
					<code class="code">e1, ... , en</code> sont des expressions du m&ecirc;me type) sont des 
					fonctions calculant le minimum ou le maximum des expressions pass&eacute;es en 
					param&egrave;tre ;
				</li><li>
					<code class="code">ln(e1)</code>, <code class="code">exp(e1)</code>, <code class="code">logx(e1, e2)</code>, 
					<code class="code">pow(e1, e2)</code> (o&ugrave; <code class="code">e1</code> et <code class="code">e2</code> sont deux 
					expressions r&eacute;elles) sont des fonctions calculant le logarithme n&eacute;p&eacute;rien, 
					l'exponentiel, le logarithme base <code class="code">e2</code> ou la puissance de 
					<code class="code">e1</code> ; 
				</li><li>
					<code class="code">ite(e1, e2, e3)</code> (o&ugrave; <code class="code">e1</code> est une expression bool&eacute;enne 
					et <code class="code">e2</code> et <code class="code">e3</code> deux expressions du m&ecirc;me type) a pour 
					valeur <code class="code">e2</code> si <code class="code">e1</code> (<code class="code">e1 == vrai</code> ou 
					<code class="code">e1 != 0</code>) sinon elle a pour valeur <code class="code">e3</code>. 
					La syntaxe suivante <code class="code">e1 ? e2 : e3</code> d&eacute;finie en langage C existe 
					aussi pour cet op&eacute;rateur ;
				</li><li>
					<code class="code">time()</code> est le temps courant de la simulation.
				</li><li>
					<code class="code">story()</code> est le num&eacute;ro de l'histoire courante.
				</li><li>
					<code class="code">delay()</code> est la dur&eacute;e de la simulation (&eacute;quivalent &agrave; 
					une constante &eacute;gale &agrave; l'option <code class="code">duration</code> du r&eacute;seau de Petri)
				</li><li>
					<code class="code">@()(e1, ... ,en)</code> (o&ugrave; <code class="code">e1, ... , en</code> sont des 
					expressions bool&eacute;ennes) est &eacute;gale au nombre d'argument valant vrai. 
					Cet op&eacute;rateur a &eacute;t&eacute; ajout&eacute; afin d'&ecirc;tre compatible avec l'op&eacute;rateur 
					<code class="code">#(e1, ... ,en)</code> du langage AltaRica DataFlow.
				</li></ul></div>
		</p><p>
			Une expression peut faire intervenir des g&eacute;n&eacute;rateurs de nombres al&eacute;atoires ; 
			ceux-ci seront utilis&eacute;s lors d'une simulation double d&eacute;tente. 
			Sur l'exemple ci-dessous, la variable LAMBDA peut &ecirc;tre utilis&eacute;e 
			comme param&egrave;tre d'une loi. 
			<pre class="programlisting">const float MIN_L 1e-3 ;
const float MAX_L 1e-4 ;
float LAMBDA unif(MIN_L,MAX_L) ;</pre>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Variables.BoolExpr"></a>Expressions bool&eacute;ennes</h4></div></div></div><p> 
			Elles sont form&eacute;es &agrave; partir des variables et constantes bool&eacute;ennes 
			(<code class="code">vrai</code> et <code class="code">faux</code>), des parenth&egrave;ses et des op&eacute;rateurs 
			<code class="code">|</code>, <code class="code">ou</code>, <code class="code">&amp;</code>, <code class="code">et</code>, 
			<code class="code">!</code>, <code class="code">non</code>, <code class="code">==</code>, <code class="code">!=</code>, 
			<code class="code">&lt;</code>, <code class="code">&gt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;=</code>
			et <code class="code">@</code>. 
		</p><p>
			Une expression bool&eacute;enne peut &ecirc;tre : 
			<div class="itemizedlist"><ul type="disc" compact><li>
					une constante bool&eacute;enne 
					(Cf. <a href="#Moca.Moca12.Constantes" title="Rubrique : Constantes (param&egrave;tres nomm&eacute;s)">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Constantes (param&egrave;tres nomm&eacute;s)&nbsp;&raquo;</a>) ; 
				</li><li>
					une variable bool&eacute;enne 
					(Cf. <a href="#Moca.Moca12.Variables.Declare" title="D&eacute;clarations">la section intitul&eacute;e &laquo;&nbsp;D&eacute;clarations&nbsp;&raquo;</a>) ; 
				</li><li>
					une des constantes <code class="code">vrai</code> ou <code class="code">faux</code> ; 
				</li><li>
					<code class="code">e1 | e2</code>, <code class="code">e1 ou e2</code> (o&ugrave; <code class="code">e1</code> et 
					<code class="code">e2</code> sont des expressions bool&eacute;ennes) est le OU logique 
					de <code class="code">e1</code> et <code class="code">e2</code> ; 
				</li><li>
					<code class="code">e1 &amp; e2</code>, <code class="code">e1 et e2</code> (o&ugrave; <code class="code">e1</code> et 
					<code class="code">e2</code> sont des expressions bool&eacute;ennes) est le ET logique 
					de <code class="code">e1</code> et <code class="code">e2</code> ; 
				</li><li>
					<code class="code">!expr</code>, <code class="code">non expr</code> (o&ugrave; <code class="code">expr</code> est 
					une expression bool&eacute;enne) est le NON logique de <code class="code">expr</code> ; 
				</li><li>
					les op&eacute;rateurs d'&eacute;galit&eacute; et d'in&eacute;galit&eacute; usuels <code class="code">e1 == e2</code>, 
					<code class="code">e1 != e2</code>, <code class="code">e1 &lt; e2</code>, <code class="code">e1 &gt; e2</code>, 
					<code class="code">e1 &lt;= e2</code>, <code class="code">e1 &gt;= e2</code> (o&ugrave; <code class="code">e1</code> et 
					<code class="code">e2</code> sont deux expressions num&eacute;riques du m&ecirc;me type ; c'est &agrave; 
					dire soit enti&egrave;res, soit r&eacute;elles) ;
				</li><li>
					<code class="code">@(i)(e1, ... ,en)</code> (o&ugrave; <code class="code">i</code> est un entier positif et 
					<code class="code">e1, ... , en</code> sont des expressions bool&eacute;ennes) vaut vrai si 
					au moins <code class="code">i</code> des <code class="code">e1, ... , en</code> valent vrai ; 
				</li><li>
					<code class="code">@(i,j)(e1, ... ,en)</code> (o&ugrave; <code class="code">i</code> et <code class="code">j</code> sont 
					des entiers positifs et <code class="code">e1, ... , en</code> sont des expressions 
					bool&eacute;ennes) vaut vrai si au moins <code class="code">i</code> et au plus <code class="code">j</code> 
					des <code class="code">e1, ... , en</code> valent vrai. 
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Variables.PrioExpr"></a>Priorit&eacute;s des op&eacute;rateurs</h4></div></div></div><p> 
			Comme dans tous les langages avec des expressions math&eacute;matiques, il existe des 
			priorit&eacute;s lors de la quantification des op&eacute;rateurs (la multiplication est 
			prioritaire par rapport &agrave; l'addition).
		</p><p> 
			Lorsque deux op&eacute;rateurs ont la m&ecirc;me priorit&eacute;, ils sont quantifi&eacute;s de la gauche 
			vers la droite.
		</p><p> 
			Les priorit&eacute;s sont donn&eacute;es dans le tableau ci-contre de la moins prioritaire 
			&agrave; la plus prioritaire.
			<div class="orderedlist"><ol type="1" compact><li>
					Op&eacute;rateur tertiaire : <code class="code">... ? ... : ...</code>
				</li><li>
					Op&eacute;rateur bool&eacute;en : <code class="code">|</code>, <code class="code">ou</code>
				</li><li>
					Op&eacute;rateur bool&eacute;en : <code class="code">&amp;</code>, <code class="code">et</code>
				</li><li>
					Op&eacute;rateur d'&eacute;galit&eacute;/in&eacute;galit&eacute; : <code class="code">==</code>, <code class="code">!=</code>
				</li><li>
					Op&eacute;rateur de comparaison : <code class="code">&gt;</code>, <code class="code">&gt;=</code>, <code class="code">&lt;</code>, <code class="code">&lt;=</code>
				</li><li>
					Op&eacute;rateur arithm&eacute;tique : <code class="code">+</code>, <code class="code">-</code>
				</li><li>
					Op&eacute;rateur arithm&eacute;tique : <code class="code">*</code>, <code class="code">/</code>, <code class="code">%</code>
				</li><li>
					Op&eacute;rateur unitaire : <code class="code">-</code>, <code class="code">!</code>
				</li><li>
					Autres expressions
				</li></ol></div>
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Transs"></a>Rubrique : Transitions</h3></div></div></div><p> 
		La d&eacute;claration d'une transition utilise la syntaxe suivante : 
		<pre class="programlisting">TR: [&lt;nom&gt;] [AM &lt;arcs-en-amont&gt;] [AV &lt;arcs-en-aval&gt;] 
    [?? &lt;conditions&gt;] [(!! &lt;affectations&gt;) <span class="news">| (!{ &lt;instructions&gt; }!)</span>] 
    [LOI &lt;loi-de-d&eacute;lai&gt;] [TIR &lt;loi-de-tir&gt;] 
	  [PRIO &lt;expression&gt;] [EQP &lt;expression&gt;] 
    [MEM &lt;expression&gt;] [LIMIT &lt;entier&gt;] [HST] ;</pre>
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Name"></a>Nom de transition</h4></div></div></div><p> 
			Le nom de la transition est un identificateur optionnel ; si celui-ci 
			n'est pas sp&eacute;cifi&eacute; alors le nom par d&eacute;faut est <code class="code">Tri</code> o&ugrave; 
			<code class="code">i</code> est le num&eacute;ro d'apparition de la transition 
			dans la description. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Place"></a>Places en amont/aval</h4></div></div></div><p> 
			Les arcs en amont d'une transition sont d&eacute;crits apr&egrave;s le mot-clef <code class="code">AM</code>. 
			Ils consistent en une liste de couples (num&eacute;ro de place, poids) s&eacute;par&eacute;es 
			par des virgules. Le poids peut &ecirc;tre une expression constante enti&egrave;re 
			respectant la syntaxe donn&eacute;e &agrave; la section 0. A l'instar des anciennes 
			versions de Moca-RP, les arcs inhibiteurs sont indiqu&eacute;s avec un poids 
			n&eacute;gatif et un arc de poids 0 vide la place associ&eacute;e &agrave; l'arc. 
		</p><p> 
			Les arcs en aval se d&eacute;crivent de mani&egrave;re analogue mais en utilisant 
			le mot-clef <code class="code">AV</code>. Un arc aval ne peut pas avoir de poids n&eacute;gatif. 
			Un avertissement est affich&eacute; lorsqu'un arc aval a un poids nul.
		</p><p>
			Dans l'exemple suivant, une constante <code class="code">C</code> est utilis&eacute;e pour 
			le poids des arcs : le poids de l'arc amont avec la place <code class="code">2</code> 
			est de 2 et le poids de l'arc aval avec la place <code class="code">3</code> est de 4. 
			<pre class="programlisting">const entier C 2 ;
TR: AM 1 2, 2 C AV 3 2*C ;</pre>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Guard"></a>Gardes ou Conditions de validation</h4></div></div></div><p> 
			Dans la description d'une transition il est possible de sp&eacute;cifier 
			apr&egrave;s le mot-clef <code class="code">??</code> (double point d'interrogation pour 
			le diff&eacute;rencier de l'op&eacute;rateur <code class="code">[si]&amp;[alors]:[sinon]</code>) 
			une liste d'expressions bool&eacute;ennes qui doivent &ecirc;tre n&eacute;cessairement 
			v&eacute;rifi&eacute;es pour que la transition soit valide. 
			Ces expressions sont s&eacute;par&eacute;es par des virgules. 
		</p><p>
			La description ci-dessous d&eacute;finit un message bool&eacute;en <code class="code">m1</code> 
			qui doit &ecirc;tre vrai pour que la transition <code class="code">Tr1</code> soit valide 
			(condition n&eacute;cessaire) mais il faut de plus que le marquage de la 
			place <code class="code">3</code> soit sup&eacute;rieur &agrave; 2 ; 
			d'une certaine mani&egrave;re la condition <code class="code">#3 &gt;= 2</code> simule un 
			arc testeur de poids 2 sur la place <code class="code">3</code> 
			(i.e. qui ne consomme pas de jeton). 
			<pre class="programlisting">bool m1;
TR: Tr1 AM 1 1 AV 2 1 ?? (#3 &gt;= 2), m1;</pre>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Affect"></a>Affectations</h4></div></div></div><p> 
			Lors du tir d'une transition, il est possible de modifier la valeur
			d'une (ou plusieurs) variable(s) en lui (leurs) affectant la valeur 
			d'expression(s).
		</p><p> 
			Lorsqu'il y a plusieurs affectations, il est possible de r&eacute;aliser ces
			affectations de mani&egrave;re parall&egrave;le (en m&ecirc;me temps) <span class="news">ou de mani&egrave;re s&eacute;quentielle
			(l'une apr&egrave;s l'autre, dans l'ordre)</span>.
		</p><p> 
			Le mot-clef <code class="code">!!</code> (double point d'exclamation pour le 
			diff&eacute;rencier de l'op&eacute;rateur de n&eacute;gation) introduit une liste d'affectations 
			de variables. Ces affectations ont lieu, en parall&egrave;le, avant la production 
			de jetons et consistent en une liste de couples (variable, expression) s&eacute;par&eacute;s
			par des virgules o&ugrave; variable et expression sont du m&ecirc;me type. 
		</p><p>
		<span class="news"> 
			Le mot-clef <code class="code">!{</code> introduit une liste d'instructions. 
			Cette liste doit se conclure par le mot-clef <code class="code">}!</code>.
			Les instructions sont ex&eacute;cut&eacute;es les unes apr&egrave;s les autres dans l'ordre de 
			d&eacute;finition. 
			Actuellement, les instructions possibles sont : 
		</span>
			<div class="itemizedlist"><ul type="disc"><li>
					<span class="news"> 
			 		L'affection : <code class="code">&lt;variable&gt; = &lt;expression&gt; ;</code> 
			 		o&ugrave; variable et expression sont du m&ecirc;me type (attention 
			 		au point-virgule en fin de ligne) 
					</span>
				</li><li>
					<span class="news"> 
			 		La liste d'instruction : <code class="code">{ &lt;instructions&gt; }</code> 
			 		pour regrouper un ensemble d'instructions.
					</span>
				</li><li>
					<span class="news"> 
			 		Le branchement conditionnel : <code class="code">if (&lt;expression&gt;) &lt;instruction&gt; [else &lt;instruction&gt;]</code> 
			 		si l'expression est vraie alors la premi&egrave;re instruction est ex&eacute;cut&eacute;e
			 		sinon (si elle existe) la seconde instruction est ex&eacute;cut&eacute;e.
					</span>
				</li></ul></div>
		</p><p> 
			Remarque : Dans les 2 cas, il n'est pas possible d'affecter un 
			nombre de jetons &agrave; une place. 
		</p><p>
			&Agrave; chaque tir de la transition <code class="code">TrDEF</code> ci-dessous la variable 
			<code class="code">NB_DEF</code> est incr&eacute;ment&eacute;e ; <code class="code">NB_DEF</code> sert ainsi &agrave; 
			compter le nombre de tirs de cette transition. 
			<pre class="programlisting">int NB_DEF;
bool m1;
TR: TrDEF AM 1 1 AV 2 1 !! NB_DEF=NB_DEF+1, m1=faux;</pre>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Delay"></a>Loi de d&eacute;lai</h4></div></div></div><p> 
			La loi, qui permet de sp&eacute;cifier le d&eacute;lai au bout duquel la transition 
			valide sera tir&eacute;e, est sp&eacute;cifi&eacute;e apr&egrave;s le mot-clef <code class="code">LOI</code>. 
			Nous listons ici l'ensemble des lois possibles ainsi que leurs param&egrave;tres. 
			Cf. <a href="#Moca.Moca12.Law.Delay" title="Lois de d&eacute;lai de Moca-RPC">la section intitul&eacute;e &laquo;&nbsp;Lois de d&eacute;lai de Moca-RP<sup>C</sup>&nbsp;&raquo;</a> pour une description plus d&eacute;taill&eacute;e. 
		</p><div class="itemizedlist"><ul type="disc" compact><li>
		<code class="code">drc <span class="symbol">&#948;</span></code> est la loi de Dirac de d&eacute;lai <span class="symbol">&#948;</span> ; 
	</li><li>
		<code class="code">erlg m,<span class="symbol">&#946;</span></code> est la loi Erlang de moyenne m et d'ordre <span class="symbol">&#946;</span>; 
	</li><li>
		<code class="code">erlgg <span class="symbol">&#946;</span>, <span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub><span class="symbol">&#946;</span></sub></code> 
		est la loi d'Erlang g&eacute;n&eacute;ralis&eacute;e d'ordre <span class="symbol">&#946;</span> et 
		<span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub>b</sub> 
		sont les param&egrave;tres des exponentielles en s&eacute;rie ; 
	</li><li>
		<code class="code">empir c<sub>1</sub> , ... , c<sub>n</sub></code> 
		est la loi empirique &agrave; n classes c<sub>1</sub> , ... , c<sub>n</sub> ; 
	</li><li>
		<code class="code">exp <span class="symbol">&#955;</span></code> est la loi exponentielle de taux <span class="symbol">&#955;</span> ; 
	</li><li>
		<code class="code">expow <span class="symbol">&#955;</span>, <span class="symbol">&#948;</span></code> est une loi exponentielle de 
		taux <span class="symbol">&#955;</span> &agrave; laquelle on ajoute le d&eacute;lai <span class="symbol">&#948;</span>. ;
	</li><li>
		<code class="code">ipa <span class="symbol">&#964;</span></code> est la loi "instants pr&eacute;vus &agrave; l'avance" ayant 
		pour d&eacute;lai entre deux tirs <span class="symbol">&#964;</span> ; 
	</li><li>
		<code class="code">ifa <span class="symbol">&#948;</span>, t<sub>0</sub></code> est la loi 
		"instants fix&eacute;s &agrave; l'avance" ayant pour d&eacute;lai entre deux tirs le 
		param&egrave;tre <span class="symbol">&#948;</span> et comme premier instant de tir t<sub>0</sub> ; 
	</li><li>
		<code class="code">nlog m, e</code> est la loi log-normale de moyenne m et 
		de facteur d'erreur e ; 
	</li><li>
		<code class="code">spec n, p<sub>1</sub>,...,p<sub>m</sub></code> est 
		la n<sup>i&egrave;me</sup> loi sp&eacute;ciale qui prend 
		p<sub>1</sub>,...,p<sub>m</sub> en param&egrave;tres. 
		Les lois sp&eacute;ciales permettent d'ajouter de nouvelles lois directement en C 
		&agrave; l'aide d'une API de programmation (Cf. <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>)
	</li><li>
		<code class="code">tri a,b,c</code> est la loi triangulaire[3, 4] de minimum a, 
		de maximum b et de mode c. 
	</li><li>
		<code class="code">unif min,max</code> est la loi uniforme de minimum min et 
		de maximum max ; 
	</li><li>
		<code class="code">web m,<span class="symbol">&#946;</span></code> est la loi de Weibull de moyenne m et de 
		param&egrave;tre de forme <span class="symbol">&#946;</span> ; 
	</li><li>
		<code class="code">webtrc m,<span class="symbol">&#946;</span>,<span class="symbol">&#945;</span></code> est la loi de Weibull tronqu&eacute;e 
		de moyenne m, de param&egrave;tre de forme <span class="symbol">&#946;</span> et 
		d'&acirc;ge <span class="symbol">&#945;</span> &agrave; l'instant t = 0; 
	</li></ul></div><p>
			Tous les param&egrave;tres des lois sont des expressions r&eacute;elles. 
			Lorsqu'un param&egrave;tre est d&eacute;fini par une expression non constante, 
			sa valeur d&eacute;pend donc de l'instant o&ugrave; la transition est valide. 
			Ce principe permet de d&eacute;finir les lois optionnelles (drcop, expop et webop) 
			relativement facilement. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Fire"></a>Loi de tir</h4></div></div></div><p> 
			La loi, qui permet de sp&eacute;cifier la mani&egrave;re de tirer la transition est 
			sp&eacute;cifi&eacute;e apr&egrave;s le mot-clef <code class="code">TIR</code>. Actuellement, il existe 
			trois lois diff&eacute;rentes de tir:
		</p><div class="itemizedlist"><ul type="disc" compact><li>
		<code class="code">def</code> est la loi de tir par d&eacute;faut 
		(g&eacute;n&eacute;ralement employ&eacute; dans les r&eacute;seaux de Petri)
	</li><li>
		<code class="code">sol <span class="symbol">&#947;</span><sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub></code> 
		est une loi de tir &agrave; la sollicitation pour n+1 arcs avals. 
	</li><li>
		<code class="code">sol2 <span class="symbol">&#947;</span><sub>1</sub>, #P<sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, #P<sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub>, #P<sub>n</sub></code> 
		est une seconde loi de tir &agrave; la sollicitation pour n+1 places avales. 
		Cette seconde loi permet de sp&eacute;cifier explicitement la place qui est associ&eacute;e &agrave; chaque gamma.
	</li><li>
		<code class="code">spec n, p<sub>1</sub>,...,p<sub>m</sub></code> 
		est la n<sup>i&egrave;me</sup> loi sp&eacute;ciale qui prend 
		p<sub>1</sub>,...,p<sub>m</sub> en param&egrave;tres. 
		Les lois sp&eacute;ciales permettent d'ajouter de nouvelles lois directement en C &agrave; 
		l'aide d'une API de programmation (Cf. <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>)
	</li></ul></div><p>
			Cf. <a href="#Moca.Moca12.Law.Fire" title="Lois de tir de Moca-RPC">la section intitul&eacute;e &laquo;&nbsp;Lois de tir de Moca-RP<sup>C</sup>&nbsp;&raquo;</a> pour une description plus d&eacute;taill&eacute;e. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Conflict"></a>Priorit&eacute; &amp; Equiprobabilit&eacute;</h4></div></div></div><p>
			La priorit&eacute; est utilis&eacute;e pendant la simulation afin d'ordonner les transitions
			en conflit. Deux transitions sont en conflit si elles doivent &ecirc;tre tir&eacute;es
			au m&ecirc;me instant. Si deux transitions restent en conflit malgr&eacute; les priorit&eacute;s,
			elles restent ordonn&eacute;es suivant leurs rangs de description.
		</p><p>
			Plus la priorit&eacute; est grande, plus la transition est prioritaire.
			Par d&eacute;faut, la priorit&eacute; d'une transition est &eacute;gale &agrave; 0.
			Il est possible de sp&eacute;cifier une priorit&eacute; n&eacute;gative afin de d&eacute;finir des
			transitions moins prioritaire que les transitions par d&eacute;faut.
		</p><p>
			La priorit&eacute; est sp&eacute;cifi&eacute;e apr&egrave;s le mot-clef <code class="code">PRIO</code> &agrave; l'aide d'une
			expression enti&egrave;re. 
			La priorit&eacute; peut donc &ecirc;tre dynamique (d&eacute;pendre de l'instant o&ugrave; elle est utilis&eacute;e).
		</p><p>
		</p><p>
			Les transitions &eacute;quiprobables offrent une alternative dans la gestion des conflits.
			Jusqu'&agrave; pr&eacute;sent, la gestion des conflits de transitions &eacute;tait d&eacute;terministe.
			Lorsque la premi&egrave;re transition de l'&eacute;ch&eacute;ancier est de type &eacute;quiprobable, 
			l'&eacute;ch&eacute;ancier est parcouru pour r&eacute;cup&eacute;rer toutes les transitions &eacute;quiprobables
			en conflit et une de ces transitions est choisie de mani&egrave;re al&eacute;atoire.   
		</p><p>
			Un poids de pond&eacute;ration peut &ecirc;tre associ&eacute; &agrave; chaque transition &eacute;quiprobable.
			Plus ce poids est grand, plus la probabilit&eacute; de choisir cette transition
			parmi les transitions en conflit est importante. 
			Par d&eacute;faut, le poids de pond&eacute;ration d'une transition &eacute;quiprobable est &eacute;gale &agrave; 1.
		</p><p>
			Une transition est d&eacute;clar&eacute;e comme &eacute;quiprobable &agrave; l'aide du mot-clef 
			<code class="code">EQP</code> &eacute;ventuellement suivi d'une expression r&eacute;elle 
			(sup&eacute;rieure &agrave; z&eacute;ro) correspondant &agrave; son poids de pond&eacute;ration. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Memory"></a>Transitions &agrave; m&eacute;moire</h4></div></div></div><p> 
		Au cours de la simulation d'un syst&egrave;me, il arrive fr&eacute;quemment qu'une transition 
		valide &agrave; un instant donn&eacute; soit inhib&eacute;e (suite au tir d'autres transitions) avant 
		d'avoir &eacute;t&eacute; tir&eacute;e. Il est important alors de savoir s'il s'agit de la disparition 
		pure et simple de l'&eacute;v&eacute;nement correspondant ou seulement de la suspension de 
		celui-ci car il faudra en tenir compte si cette transition redevient valide au 
		cours de la m&ecirc;me histoire :
		<div class="itemizedlist"><ul type="disc"><li>
				Si la transition a &eacute;t&eacute; inhib&eacute;e suite &agrave; la disparition de l'&eacute;v&eacute;nement 
				correspondant alors une nouvelle validation correspond &agrave; un nouvel 
				&eacute;v&eacute;nement ind&eacute;pendant du pr&eacute;c&eacute;dent et le d&eacute;lai doit &ecirc;tre &eacute;valu&eacute; par 
				un nouveau tirage de nombre au hasard ;
			</li><li>
				Par contre, si l'inhibition correspond seulement &agrave; la suspension de 
				l'&eacute;v&eacute;nement correspondant, la nouvelle validation correspond seulement 
				&agrave; la r&eacute;activation de cet &eacute;v&eacute;nement et il faut utiliser comme d&eacute;lai celui 
				qui restait &agrave; courir au moment de la suspension.
			</li></ul></div>
	</p><p> 
		Pour montrer plus explicitement ce que nous venons de d&eacute;crire, nous allons prendre 
		l'exemple d'une transition (IT) relative &agrave; la d&eacute;faillance d'un composant.
	</p><p> 
		Soit T1 l'instant o&ugrave; on commence &agrave; utiliser le composant ; le composant est alors 
		neuf et IT devient valide pour la premi&egrave;re fois (cf. figure ci-dessous) ; 
		par tirage d'un nombre au hasard, on &eacute;value alors TH le d&eacute;lai d'utilisation au bout 
		duquel le composant tombera en panne et la transition sera effectivement tir&eacute;e 
		(par exemple, TH=1000h). La transition IT devrait donc &ecirc;tre tir&eacute;e &agrave; 
		l'instant T=T1+1000h.
	</p><p> 
		Consid&eacute;rons maintenant un instant T2 (p.ex. T2=T1+200h) o&ugrave;, momentan&eacute;ment, 
		on n'a plus besoin du composant consid&eacute;r&eacute;, on arr&ecirc;te alors de le faire fonctionner 
		et cela se traduit dans le r&eacute;seau de Petri par l'inhibition de la transition IT. 
		&Agrave; cet instant le composant a &eacute;t&eacute; utilis&eacute; pendant 200h et il lui reste normalement 
		1000-200=800h &agrave; <span class="emphasis"><em>vivre</em></span> (soit T-T2).
	</p><p> 
		Quelques temps plus tard (T3), on a de nouveau besoin du composant et la transition 
		(IT) redevient valide. Comme elle correspond toujours &agrave; la d&eacute;faillance du m&ecirc;me 
		composant c'est le d&eacute;lai de TH=800h ci-dessus qu'il faut utiliser et non 
		r&eacute;&eacute;valuer une nouvelle dur&eacute;e de vie TH (qui correspondrait au remplacement du 
		composant par un composant neuf) par le tir d'un nouveau nombre au hasard.
	</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="Moca12/FTransMemory.gif" align="middle"></div></div><p> 
		Le processus d'inhibition-validation peut se poursuivre plusieurs fois avant que 
		IT soit effectivement tir&eacute;e. Lorsqu'elle a &eacute;t&eacute; tir&eacute;e effectivement, le processus 
		reprend &agrave; z&eacute;ro (la validation suivante est consid&eacute;r&eacute;e comme une premi&egrave;re validation).
	</p><p> 
		Cela &eacute;tant dit, il est des fois n&eacute;cessaire d'inhiber le m&eacute;canisme de la m&eacute;moire
		en cours de simulation. Cela revient &agrave; se poser la question de l'utilisation 
		du temps restant &agrave; chaque validation de la transition. Il est alors possible
		de choisir au moment de la validation de la transition si un nouveau d&eacute;lai doit
		&ecirc;tre calcul&eacute; ou si le d&eacute;lai restant est utilis&eacute;. La transition devient alors
		une transition &agrave; m&eacute;moire dynamique.   
	</p><p>
		Une transition est d&eacute;clar&eacute;e "&agrave; m&eacute;moire" &agrave; l'aide du mot-clef <code class="code">MEM</code>.
		Pour les transitions &agrave; m&eacute;moire dynamique, le mot-clef <code class="code">MEM</code> est suivi 
		d'une expression bool&eacute;enne. 
		Cette expression doit &ecirc;tre, au moment de la validation de la transition, :
		<div class="itemizedlist"><ul type="disc"><li>
		 		&agrave; <code class="code">true</code> si le d&eacute;lai restant doit &ecirc;tre utilis&eacute; (m&eacute;canisme de m&eacute;moire);
			</li><li>
		 		&agrave; <code class="code">false</code> si un nouveau d&eacute;lai doit &ecirc;tre calcul&eacute;.
			</li></ul></div>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Limit"></a>Limiter le nombre de tir instantan&eacute;</h4></div></div></div><p>
			Il est possible de limiter le nombre de tir instantan&eacute; sans incr&eacute;ment du temps.
			Cela permet de traiter facilement les transitions ne devant &ecirc;tre tir&eacute;s qu'une
			seule fois &agrave; un temps donn&eacute;e (comme les transitions avec une loi "Instant
			Pr&eacute;vu &agrave; l'Avance").   
		</p><p>
			Ce m&eacute;canisme est sp&eacute;cifi&eacute; &agrave; l'aide du mot-clef <code class="code">LIMIT</code> suivi 
			d'un entier (g&eacute;n&eacute;ralement &eacute;gal &agrave; 1) qui pr&eacute;cise le nombre de tir autoris&eacute;
			sans incr&eacute;ment du temps. Lorsque le temps de la simulation change, le compteur
			du nombre de tir autoris&eacute; est remis &agrave; z&eacute;ro. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Transs.Hst"></a>Histogramme</h4></div></div></div><p> 
			Il est possible de demander la m&eacute;morisation de l'histogramme 
			des tirs d'une transition &agrave; l'aide du mot-clef <code class="code">HST</code>.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Arrays"></a>Rubrique : Tableaux g&eacute;n&eacute;raux</h3></div></div></div><p> 
		Le nombre de param&egrave;tres maximum des lois mises en &#339;uvre dans les versions 
		pr&eacute;c&eacute;dentes de Moca-RP<sup>C</sup> &eacute;tait fix&eacute; &agrave; 3. Ce nombre est largement suffisant 
		dans la plupart des cas mais pour la mise en &#339;uvre de certaines lois 
		complexes il &eacute;tait n&eacute;cessaire de pouvoir indiquer un plus grand nombre 
		de param&egrave;tres. Pour r&eacute;gler ce probl&egrave;me on utilisait alors un des trois 
		param&egrave;tres pr&eacute;c&eacute;dents pour indiquer un num&eacute;ro de tableau et le tableau 
		en question &eacute;tait ensuite d&eacute;crit sous une autre rubrique.
	</p><p> 
		Dans la version actuelle de Moca-RP<sup>C</sup>, le nombre de param&egrave;tres maximum des lois n'a 
		pas &eacute;t&eacute; limit&eacute; et le nombre de lois utilisant plus de trois param&egrave;tres 
		a &eacute;t&eacute; r&eacute;duit &agrave; 4. Nous avons pourtant souhait&eacute; conserver un m&eacute;canisme 
		similaire afin de simplifier la saisie des diff&eacute;rentes lois.
	</p><p> 
		Il est possible de d&eacute;clarer des tableaux (qui sont d'ailleurs plut&ocirc;t des 
		listes d'expressions) et de les utiliser lors de la description des lois 
		des transitions. Ces tableaux sont identifi&eacute;s &agrave; l'aide d'un num&eacute;ro et 
		&eacute;ventuellement d'un nom.
	</p><p> 
		Un tableau est d&eacute;clar&eacute; de la mani&egrave;re suivante :
		<pre class="programlisting">TB: [name] n expr1, expr2,..., exprk;</pre>
		o&ugrave; <code class="code">name</code> est un nom optionnel, <code class="code">n</code> est le num&eacute;ro du tableau 
		en question et <code class="code">expr1, expr2,..., exprk</code> sont les k expressions 
		du tableau <code class="code">n</code>.
	</p><p> 
		Ne s'agissant que d'un raccourci d'&eacute;criture, ils peuvent s'utiliser &agrave; la place 
		de toute liste d'expressions (expressions s&eacute;par&eacute;es par des virgules), 
		c'est-&agrave;-dire comme param&egrave;tres des lois de d&eacute;lai et de tir, comme arguments 
		des expressions <code class="code">@(k[,l])(...)</code>, <code class="code">min(...)</code> et 
		<code class="code">max(...)</code> et comme gardes des transitions. 
	</p><p> 
		Pour les utiliser, il suffit d'utiliser l'op&eacute;rateur <code class="code">$</code> suivi 
		du nom ou du num&eacute;ro de tableau concern&eacute;.
	</p><p>
		Exemple : 
		<pre class="programlisting">TB: 1  1e-3, 1e-2, 1e-3; /* Definition d'un tableau */
TB: solP 2 0.1, 0.2; /* Definition d'un autre tableau */

TR: Tr1 AM 1 1 AV 2 1, 3 1, 4 1 LOI erlgg 3,$1 TIR sol $solP; /* Utilisation des tableaux */ </pre>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Places"></a>Rubrique : Places</h3></div></div></div><p> 
		Les places sont automatiquement d&eacute;clar&eacute;es lors des descriptions des transitions 
		et/ou des expressions utilisant le marquage d'une place. 
		Cette rubrique ne sert qu'&agrave; associer des noms aux places du r&eacute;seau de Petri.  
		Elle est rep&eacute;r&eacute;e par le mot-clef <code class="code">PL:</code>. La suite consiste en une 
		liste de la forme suivante :
		<pre class="programlisting">PL: Nom1, P2 Nom2... </pre>
		o&ugrave; <code class="code">Pi</code> est un num&eacute;ro de place et <code class="code">Nomi</code> le nom 
		qui lui est associ&eacute;.
	</p><p>
		Exemple : 
		<pre class="programlisting">PL: 1 Out_OK,  2 Out_NOK, 
    10 A_OK,   11 A_NOK,
    20 B_OK,   21 B_NOK,
    30 C_OK,   31 C_NOK;</pre>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Inits"></a>Rubrique : Initialisations</h3></div></div></div><p> 
		L'initialisation d'un r&eacute;seau de Petri se r&eacute;sume en l'initialisation de ses 
		places et de ses variables. L'initialisation commence par le mot-cl&eacute; 
		<code class="code">AI:</code> suivi d'une liste d'affectations: 
		<div class="itemizedlist"><ul type="disc"><li>
				<code class="code">#&lt;place&gt; = &lt;expr&gt;</code> o&ugrave; <code class="code">&lt;place&gt;</code>
				est le num&eacute;ro de la place et <code class="code">&lt;expr&gt;</code> est une expression 
				constante enti&egrave;re. Par d&eacute;faut une place contient 0 jeton. 
			</li><li>
				<code class="code">&lt;var&gt; = &lt;expr&gt;</code> o&ugrave; <code class="code">&lt;var&gt;</code> est 
				le nom d'une variable et <code class="code">&lt;expr&gt;</code> une expression 
				constante. <code class="code">&lt;var&gt;</code> et <code class="code">&lt;expr&gt;</code> 
				doivent &ecirc;tre du m&ecirc;me type. 
				Par d&eacute;faut une variable bool&eacute;enne vaut faux et une variable enti&egrave;re 
				ou r&eacute;elle 0.
			</li></ul></div>
	</p><p>
		Exemple : 
		<pre class="programlisting">bool b ;  /* une variable bool&eacute;enne */
int c ;   /* une variable enti&egrave;re */
TR: AM 1 1 AV 2 1; 
AI: #1=1, c=3 ; 
/* par d&eacute;faut b vaut faux et la place 2 contient 0 jeton */</pre>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.States"></a>Rubrique : Etats statistiques (Observateurs)</h3></div></div></div><p> 
		La d&eacute;claration d'un &eacute;tat statistique utilise la syntaxe suivante : 
		<pre class="programlisting"> ES: &lt;name&gt; = &lt;expr&gt; [&lt;flags&gt;]; </pre>
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.States.Name"></a>Nom de l'&eacute;tat statistique</h4></div></div></div><p> 
			Le nom <code class="code">&lt;name&gt;</code> de l'&eacute;tat statistique est un 
			identificateur utilis&eacute; lors de l'affichage des r&eacute;sultats. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.States.Expr"></a>Expression</h4></div></div></div><p> 
			L'expression <code class="code">&lt;expr&gt;</code>, permettant de savoir &agrave; 
			tout instant si nous sommes ou non dans un &eacute;tat statistique donn&eacute;, 
			est d&eacute;crit &agrave; l'aide d'une expression num&eacute;rique d&eacute;finie 
			dans le <a href="#Moca.Moca12.Variables.NumExpr" title="Expressions num&eacute;riques">la section intitul&eacute;e &laquo;&nbsp;Expressions num&eacute;riques&nbsp;&raquo;</a>.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.States.Flags"></a>Drapeaux</h4></div></div></div><p> 
			Les drapeaux <code class="code">&lt;flags&gt;</code> sont tous facultatifs, 
			mais ils doivent &ecirc;tre indiqu&eacute;s dans l'ordre ci-dessous.
		</p><div class="itemizedlist"><ul type="disc"><li>
				Le drapeau <code class="code">HST</code> permet d'obtenir l'&eacute;chantillon complet 
				des valeurs tir&eacute;es pour l'&eacute;tat concern&eacute;. Ceci est utile lorsque 
				l'on ne se contente pas des r&eacute;sultats obtenus par d&eacute;faut.
			</li><li>
				Le drapeau <code class="code">CHRO</code> permet d'obtenir un chronogramme moyen 
				de la valeur de l'&eacute;tat concern&eacute;. Cela permet de visualiser 
				le profil de vie de l'&eacute;tat statistique.
			</li><li>
				Le drapeau <code class="code">at &lt;float&gt;[-]? [, &lt;float&gt;[-]?]*</code> ou 
				<code class="code">from &lt;float&gt; to &lt;float&gt; step &lt;float&gt;[-]?</code> 
				permet de sp&eacute;cifier des temps de calcul sp&eacute;cifique &agrave; l'&eacute;tat statistique 
				consid&eacute;r&eacute;. Si ce drapeau n'est pas pr&eacute;sent les temps de calcul consid&eacute;r&eacute;s 
				sont ceux d&eacute;finies &agrave; l'aide de <a href="#Moca.Moca12.Options.Times">
				l'option times</a>.
			</li><li>
				Le drapeau <code class="code">[TS: &lt;num&gt; [,&lt;num&gt;]*]</code> permet de 
				sp&eacute;cifier de type de statistique sp&eacute;cifique &agrave; l'&eacute;tat statistique 
				consid&eacute;r&eacute;. Si ce drapeau n'est pas pr&eacute;sent les types de statistiques 
				consid&eacute;r&eacute;s sont ceux d&eacute;finies dans la rubrique TS:
			</li></ul></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Types"></a>Rubrique : Type de statistiques</h3></div></div></div><p> 
		Moca-RP<sup>C</sup> &eacute;value syst&eacute;matiquement un certain nombre de r&eacute;sultats mais il est 
		de plus possible, pour les &eacute;tats statistiques d&eacute;crits &agrave; la rubrique 
		pr&eacute;c&eacute;dente (2.2.8), d'obtenir des r&eacute;sultats sp&eacute;cifiques. 
	</p><p> 
		La pr&eacute;sente rubrique, rep&eacute;r&eacute;e par le mot-clef <code class="code">TS:</code>, permet 
		d'indiquer quels types de r&eacute;sultats doivent &ecirc;tre &eacute;valu&eacute;s sur ces &eacute;tats.
	</p><p> 
		Moca-RP<sup>C</sup> autorise 7 types de statistiques :
		<div class="orderedlist"><ol type="1"><li>
				Temps moyen de s&eacute;jour cumul&eacute; pass&eacute; dans les &eacute;tats :
				De loin le plus utilis&eacute; car il permet, en particulier, les 
				&eacute;valuations de disponibilit&eacute; de production (productivit&eacute;) 
				des installations.
			</li><li>
				Moyenne de pr&eacute;sence d'&eacute;tats &agrave; la fin d'une histoire : 
				Destin&eacute; &agrave; la r&eacute;alisation des calculs de fiabilit&eacute; ;
				Dans ce cas, on regarde si l'&eacute;tat de panne (absorbant) est 
				pr&eacute;sent en fin d'histoire.
			</li><li>
				Valeur moyenne de l'expression de l'&eacute;tat &agrave; la fin d'une histoire :
				Le pendant pour un &eacute;tat statistique du nombre moyen de jetons 
				en fin d'histoire pour une place.
			</li><li>
				Nombre de passages moyens par les &eacute;tats au cours d'une histoire :
				Destin&eacute; au d&eacute;nombrement des occurrences d'&eacute;v&eacute;nements 
				particuliers au cours d'une histoire.
			</li><li>
				Valeur moyenne de l'expression de l'&eacute;tat au cours d'une histoire :
				Le pendant pour un &eacute;tat statistique du marquage moyen pour 
				une place.
			</li><li>
				Date moyenne de premi&egrave;re arriv&eacute;e dans les &eacute;tats et nombre total de 
				donn&eacute;es non censur&eacute;es, c'est-&agrave;-dire de dates inf&eacute;rieures &agrave; la 
				dur&eacute;e d'une histoire : 
				Permet d'obtenir des renseignements sur l'instant o&ugrave; un syst&egrave;me 
				tombe en panne pour la premi&egrave;re fois. Ceci permet de r&eacute;aliser des calculs 
				de fiabilit&eacute; et d'&eacute;valuer le temps moyen de bon fonctionnement du syst&egrave;me.
			</li><li>
				Valeur moyenne de l'expression de l'&eacute;tat pour chaque intervalle de temps :
				A &eacute;t&eacute; int&eacute;gr&eacute; afin d'afficher la production moyenne pour chaque 
				ann&eacute;e de production. 
				Doit &ecirc;tre utilis&eacute; avec une liste de temps (dans le cas contraire, le 
				r&eacute;sultat est identique &agrave; un type de statistique 5).
				La diff&eacute;rence entre 2 temps doit &ecirc;tre strictement sup&eacute;rieure &agrave; epsilon (une 
				liste de temps incluant t et t-epsilon rendra impossible le lancement de 
				la simulation).  
			</li></ol></div>
	</p><p> 
		Il est possible de pr&eacute;ciser plusieurs types de statistiques sur tous les &eacute;tats 
		statistiques en s&eacute;parant les types de statistiques par une virgule. 
	</p><p>
		L'exemple suivant d&eacute;finit les trois types de statistique 1, 2 et 4.
		<pre class="programlisting">TS: 1, 2, 4 ;</pre>
	</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Samples"></a>Exemple d'un r&eacute;seau de Petri</h3></div></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="Moca12/Sample.png" align="middle"></div></div><pre class="programlisting"> 
net RdpTyp1 {
 
/* Description des options */
       OPT: title "1er exemple de r&eacute;seaux de Petri typiques (JPS)" ;
       OPT: duration          8760.00 ; /* Une ann&eacute;e */

/* Donn&eacute;es g&eacute;n&eacute;rales */
       const float DELTA = 1.; /* Vitesse de production */
 
/* Premier train de production */
       const float LBD1 = 1e-3;
       const float MU1 = 1e-2;
       TR: Rep1 AM 2 1 AV 1 1 LOI exp MU1 ;
       TR: Def1 AM 1 1 AV 2 1 LOI exp LBD1 ;
       TR: Prod1 
             AM 1 1, 5 -1000, 6 -1 
             AV 1 1, 5 5
             LOI drc DELTA MEM;
       PL: 1 March1, 2 Panne1;
       AI: #1 = 1;
 
/* second train de production */
       const float LBD2 = 1e-3;
       const float MU2 = 1e-2;
       TR: Rep2 AM 4 1 AV 3 1 LOI exp MU2 ;
       TR: Def2 AM 3 1 AV 4 1 LOI exp LBD2 ;
       TR: Prod2 
             AM 3 1, 5 -1000, 7 -1
             AV 3 1, 5 5
             LOI drc DELTA MEM;
       PL: 3 March2, 4 Panne2;
       AI: #3 = 1;
 
/* Maintenance pr&eacute;ventive */
       const float D-MP = 800.;
       const float D-MP1 = 100.;
       const float D-MP2 = 100.;
       TR: AttMP1 AM 6 1 AV 7 1
             LOI drc D-MP1 ;
       TR: AttMP2 AM 7 1 AV 8 1
             LOI drc D-MP2 ;
       TR: AttMP AM 8 1 AV 6 1
             LOI drc D-MP ;
       PL: 6 MP1, 7 MP2, 8 PasMP;
       AI: #8 = 1;
 
/* Description des autres places */
       PL: 5 Stock;
};
	</pre></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Results"></a>R&eacute;sultats attendus</h3></div></div></div><p> 
		Les r&eacute;sultats fournis par le logiciel sont les moyennes, &eacute;cart-types et 
		intervalles de confiance &agrave; 90% des mesures suivantes :
		<div class="orderedlist"><ol type="1" compact><li>
				Le nombre de tirs pour chaque transition 
				(r&eacute;sultat fourni par d&eacute;faut) ;
			</li><li>
				Le temps de s&eacute;jour cumul&eacute; dans chaque place 
				(r&eacute;sultat fourni par d&eacute;faut) ;
			</li><li>
				Le marquage de chaque place 
				(r&eacute;sultat fourni par d&eacute;faut) ;
			</li><li>
				Le marquage en fin d'histoire de chaque place ;
			</li><li>
				Le temps cumul&eacute; dans un &eacute;tat statistique ;
			</li><li>
				La date de premi&egrave;re occurrence d'un &eacute;tat statistique ;
			</li><li>
				Le nombre d'occurrences d'un &eacute;tat statistique ;
			</li><li>
				La pr&eacute;sence d'un &eacute;tat statistique en fin d'histoire ;
			</li><li>
				L'histoire des mesures sur les &eacute;tats et transitions ;
			</li></ol></div>
	</p><p> 
		Pour les &eacute;tats statistiques, des &eacute;chantillons sont constitu&eacute;s au fur et &agrave; 
		mesure du d&eacute;roulement des histoires. Pour chaque &eacute;tat sp&eacute;cifi&eacute;, on obtient 
		ainsi un &eacute;chantillon qui peut &ecirc;tre caract&eacute;ris&eacute; par sa moyenne 
		(<span class="emphasis"><em>m</em></span>) et sa variance 
		(<span class="emphasis"><em><span class="symbol">&#963;</span><sup>2</sup></em></span>). 
		La racine carr&eacute;e de la variance constitue l'&eacute;cart-type 
		(<span class="emphasis"><em><span class="symbol">&#963;</span></em></span>) de l'&eacute;chantillon. 
		Au fur et &agrave; mesure que le nombre d'histoires grandit, 
		l'&eacute;chantillon grandit aussi et les param&egrave;tres <span class="emphasis"><em>m</em></span> et 
		<span class="emphasis"><em><span class="symbol">&#963;</span></em></span> convergent vers des valeurs limites qui 
		correspondent aux r&eacute;sultats recherch&eacute;s. Plus les valeurs de l'&eacute;chantillon 
		sont dispers&eacute;es et plus <span class="emphasis"><em><span class="symbol">&#963;</span></em></span> est grand. 
		Si on repr&eacute;sente l'&eacute;chantillon sous la forme d'un histogramme, celui-ci 
		sera d'autant aplati que <span class="emphasis"><em><span class="symbol">&#963;</span></em></span> sera grand.
	</p><p> 
		Un autre param&egrave;tre indispensable &agrave; conna&icirc;tre pour appr&eacute;hender la qualit&eacute; 
		de la simulation r&eacute;alis&eacute;e est l'&eacute;valuation de la confiance que l'on peut 
		attribuer au r&eacute;sultat. Si on consid&egrave;re la moyenne <span class="emphasis"><em>m</em></span> 
		de l'&eacute;chantillon, il s'agit d'une estimation de la moyenne 
		<span class="emphasis"><em>vraie</em></span> <span class="emphasis"><em>M</em></span>. 
		Au fur et &agrave; mesure que l'&eacute;chantillon s'&eacute;toffe, l'estimation 
		<span class="emphasis"><em>m</em></span> doit se rapprocher de plus en plus de la valeur 
		<span class="emphasis"><em>vraie</em></span> <span class="emphasis"><em>M</em></span>. 
		Comme <span class="emphasis"><em>M</em></span> est une valeur d&eacute;terministe, la qualit&eacute; de 
		l'estimation peut &ecirc;tre mesur&eacute;e par l'intervalle dans lequel se trouve 
		l'estimation <span class="emphasis"><em>m</em></span> par rapport &agrave; la valeur 
		<span class="emphasis"><em>vraie</em></span> <span class="emphasis"><em>M</em></span>. 
		Ceci s'exprime &agrave; l'aide de la notion de confiance <span class="emphasis"><em>C(e)</em></span> 
		&agrave; <span class="symbol">&#945;</span>% :
		<div class="informalequation"><div class="mediaobject" align="center"><img src="Moca12/Result.gif" align="middle"></div></div>  
		La formule ci-dessus exprime que la probabilit&eacute; que la moyenne estim&eacute;e 
		<span class="emphasis"><em>m</em></span> se trouve dans l'intervalle 
		[-<span class="emphasis"><em>e</em></span>,<span class="emphasis"><em>+e</em></span>] autour de la valeur 
		<span class="emphasis"><em>vraie</em></span> <span class="emphasis"><em>M</em></span> est de 0.9.
	</p><p> 
		Plus l'intervalle [-<span class="emphasis"><em>e</em></span>,<span class="emphasis"><em>+e</em></span>] sera 
		petit, plus l'estimation <span class="emphasis"><em>m</em></span> de 
		<span class="emphasis"><em>M</em></span> sera pr&eacute;cise. 
		En th&eacute;orie, pour un nombre infini d'histoires cet intervalle devient nul 
		puisque <span class="emphasis"><em>M</em></span> est une valeur d&eacute;terministe.
	</p><p> 
		La fonction <span class="emphasis"><em>C(e)</em></span> s'exprime en fonction de la 
		fonction <span class="emphasis"><em>erf(.)</em></span> tabul&eacute;e dans les tables relatives &agrave; la 
		loi de Gauss. 
		Cela permet de d&eacute;montrer que <span class="emphasis"><em>C(e)</em></span> est &eacute;gale &agrave; 90% 
		si l'on pose <span class="emphasis"><em>e=1.64<span class="symbol">&#963;</span>/<span class="symbol">&radic;</span>N</em></span>. 
		Dans cette formule <span class="emphasis"><em><span class="symbol">&#963;</span></em></span> est l'&eacute;cart-type de 
		l'&eacute;chantillon, <span class="emphasis"><em>N</em></span> est le nombre d'histoires r&eacute;alis&eacute;es, 
		et 1.64 un coefficient donn&eacute; par des tables.
	</p><p> 
		Moca-RP<sup>C</sup> &eacute;value syst&eacute;matiquement la valeur de <span class="emphasis"><em>e</em></span> 
		correspondant &agrave; un intervalle de confiance &agrave; 90% afin que l'utilisateur 
		puisse avoir une id&eacute;e de l'erreur li&eacute;e &agrave; la simulation. Il est &agrave; noter 
		que <span class="emphasis"><em>e</em></span> varie selon la racine carr&eacute;e du nombre 
		d'histoires, donc tr&egrave;s lentement. 
		Il en r&eacute;sulte que pour obtenir des r&eacute;sultats pr&eacute;cis pour des &eacute;v&eacute;nements 
		peu probables, un tr&egrave;s grand nombre d'histoires sera n&eacute;cessaire.
	</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Moca.IMoca"></a>Interpr&eacute;teur de commandes</h2></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Intro"></a>Introduction</h3></div></div></div><p> 
			La version 10 de Moca-RP<sup>C</sup> fonctionne de mani&egrave;re batch. On sp&eacute;cifie, sur la ligne 
			de commande appelant le logiciel, le fichier d'entr&eacute;e &agrave; traiter, le fichier de 
			sortie et un certain nombre de directives optionnelles. Le logiciel traite alors 
			le fichier d'entr&eacute;e, g&eacute;n&egrave;re le fichier de sortie et rend la main. 
			Pour refaire une simulation, il faut modifier le fichier d'entr&eacute;e et relancer 
			le calcul.
		</p><p> 
			Les versions 12 (et sup&eacute;rieures) de Moca-RP<sup>C</sup> dialogue avec les utilisateurs &agrave; 
			l'aide d'un interpr&eacute;teur de commandes. 
		</p><p> 
			Celui-ci permet  :
			<div class="itemizedlist"><ul type="disc" compact><li>
					La cr&eacute;ation et la gestion de plusieurs r&eacute;seaux de Petri
				</li><li>
					Le chargement des r&eacute;seaux au format Moca-RP<sup>C</sup> version 10.04 et pr&eacute;c&eacute;dents 
				</li><li>
					Le chargement des r&eacute;seaux au format Moca-RP<sup>C</sup> 
				</li><li>
					La sauvegarde (et / ou l'affichage) des r&eacute;seaux au format Moca-RP<sup>C</sup> 
				</li><li>
					L'arr&ecirc;t et la reprise d'une simulation permettant ainsi la v&eacute;rification 
					d'un RdP sur un petit nombre d'histoires, puis le lancement de la simulation 
					pour un grand nombre d'histoires (sans perdre les r&eacute;sultats pr&eacute;c&eacute;dents).
				</li><li>
					L'affichage de tout ou d'une partie des r&eacute;sultats vers un ou plusieurs 
					fichiers
				</li><li>
					Une aide en ligne, une commande g&eacute;n&eacute;rique afin d'acc&eacute;der au syst&egrave;me, 
					une gestion de chronom&egrave;tres, ...
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Launch"></a>Lancement de Moca-RP<sup>C</sup></h3></div></div></div><p> 
		Pour lancer le logiciel, il faut &agrave; partir d'un shell (fen&ecirc;tre de commandes Dos dans 
		le cas d'un syst&egrave;me Windows) lancer l'ex&eacute;cutable <code class="filename">Moca13</code> 
		(<code class="filename">Moca13.exe</code> sous Windows). 
		L'invite de l'interpr&eacute;teur de commandes Moca-RP<sup>C</sup> s'affiche alors &agrave; l'&eacute;cran.
	</p><pre class="screen">Moca-RPc : propriete du groupe Total
Version 13.12 (Sep 14 2009 - 16:35:17)
 
 Pour obtenir de l'aide, saisissez la commande "help;"
 
 
Moca &gt;</pre><p>
		Vous pouvez &agrave; partir de l&agrave; ex&eacute;cuter des commandes Moca.
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Launch.Sample"></a>Exemple d'une session Moca-RP<sup>C</sup></h4></div></div></div><p> 
			Un interpr&eacute;teur de commandes permet &agrave; l'utilisateur d'effectuer des requ&ecirc;tes 
			au logiciel qui r&eacute;pond en fonction de la nature de la question pos&eacute;e et des 
			commandes qu'il a d&eacute;j&agrave; trait&eacute;es.
		</p><p> 
			L'exemple ci-dessous correspond &agrave; une copie de la console DOS. Les commandes saisies
			par l'utilisateur sont affich&eacute;es en gras. 
		</p><pre class="screen">01  D:\BASIC\TEST&gt;<strong class="userinput"><code>Moca13</code></strong>
02  
03  Moca-RPc : propriete du groupe Total
04  Version 13.12 (Sep 14 2009 - 16:35:17)
05  
06   Pour obtenir de l'aide, saisissez la commande "help;"
07  
08  
09  Moca &gt; <strong class="userinput"><code>help;</code></strong>
10  |--------------------------------------------------------------------|
11  | Moca [Version 13.12} : aide en ligne                               |
12  |--------------------------------------------------------------------|
13  | L'interface utilisateur de Moca est un interpreteur de commandes.  |
14  | Les reseaux sont charges a l'aide de  "parser" externe non         |
15  | documente dans cette aide en ligne.                                |
16  | Des commandes permettent de manipuler ces donnees (afficher,       |
17  | supprimer, ...).                                                   |
18  |                                                                    |
19  | Les commandes principales sont les suivantes :                     |
20  |  exit, load, save, set, clear, timer, system                       |
21  |  simul, display, redirection,                                      |
22  |                                                                    |
23  | D'autres mots clefs sont aussi utilises                            |
24  |  trace, seed, of, stop, start, variable, prompt, information       |
25  |  precision, language, format, options, result                      |
26  |                                                                    |
27  | Voir 'help &lt;commande&gt;;' pour une aide sur la commande donnee.      |
28  |                                                                    |
29  | Moca peut etre appele avec des noms de fichiers comme arguments.   |
30  | Ces fichiers sont lus avant que l'interpreteur de commande ne      |
31  | demarre.                                                           |
32  |--------------------------------------------------------------------|
33  
34  Moca &gt; <strong class="userinput"><code>load "drc.mok";</code></strong>
35  Chargement du fichier drc.mok
36  ## parser Moca at line 2
37  ## endparser at line 51
38  
39  Moca &gt; <strong class="userinput"><code>display net all;</code></strong>
40  display net ;
41  /*
42    1 drc
43   */
44  
45  Moca &gt; <strong class="userinput"><code>simul drc {story 100};</code></strong>
46  Temps de simulation : 3.98 (3.99)
47  
48  Moca &gt; <strong class="userinput"><code>display result drc &gt; "File.res";</code></strong>
49  
50  Moca &gt; <strong class="userinput"><code>exit;</code></strong>
51  
52  D:\BASIC\TEST&gt;</pre><p>
			Dans un premier temps, on ex&eacute;cute le logiciel &agrave; partir du chemin en cours (ligne 1). 
			L'interpr&eacute;teur de commandes est alors op&eacute;rationnel. 
			Comme cela est sp&eacute;cifi&eacute; dans la banni&egrave;re de lancement de Moca, la commande 
			<span><strong class="command">help</strong></span> (ligne 9) permet d'afficher le d&eacute;but de l'aide en ligne. 
			Le chargement du fichier <code class="literal">drc.mok</code> est effectu&eacute; sur la ligne 34. 
			La commande <span><strong class="command">display net all;</strong></span> (ligne 39) nous informe qu'un 
			r&eacute;seau de Petri nomm&eacute; drc a &eacute;t&eacute; charg&eacute; en m&eacute;moire. 
			Cent histoires sont alors simul&eacute;es sur le r&eacute;seau drc &agrave; l'aide de la commande 
			<span><strong class="command">simul</strong></span> (ligne 45). 
			Les r&eacute;sultats statistiques de ces simulations sont imprim&eacute;s vers le fichier 
			<code class="literal">File.res</code> &agrave; l'aide de la commande <span><strong class="command">display result</strong></span>
			(ligne 48). 
			Pour finir, la commande <span><strong class="command">exit</strong></span> permet de quitter l'interpr&eacute;teur 
			de commandes.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Launch.Batch"></a>Lancement de Moca-RP<sup>C</sup> en batch</h4></div></div></div><p> 
			Lorsque l'on souhaite lancer Moca-RP<sup>C</sup> en batch, il suffit d'&eacute;crire dans un fichier 
			(par exemple cmd.mok) toutes les commandes que l'on souhaite ex&eacute;cuter, puis on 
			lance Moca-RP<sup>C</sup> &agrave; l'aide de la commande <strong class="userinput"><code>Moca1301 &lt; cmd.mok</code></strong>
		</p><p>
			Il convient de ne pas oublier de mettre la commande <span><strong class="command">exit;</strong></span> &agrave; la 
			fin du fichier de commande.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Cmd.Base"></a>Commandes de base</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Remark"></a>Commentaires</h4></div></div></div><p> 
			Les commentaires dans Moca-RP<sup>C</sup> ont la m&ecirc;me syntaxe que dans le langage C. 
			Ils commencent par les caract&egrave;res <code class="literal">/*</code> et finissent sur les 
			caract&egrave;res <code class="literal">*/</code>. Ils peuvent &ecirc;tre &eacute;tendus sur plusieurs lignes.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Help"></a>Aide en ligne {<span><strong class="command">help ...</strong></span>}</h4></div></div></div><p> 
			Une aide en ligne est disponible directement dans Moca-RP<sup>C</sup> en saisissant la 
			commande <span><strong class="command">help;</strong></span>. 
			Elle est segment&eacute;e en diff&eacute;rentes rubriques correspondant aux mots clefs du langage.
		</p><div class="informalexample"> 
			La commande <span><strong class="command">help display;</strong></span> affiche l'aide en ligne associ&eacute; aux 
			commandes <span><strong class="command">display</strong></span>.
		</div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Load"></a>Chargement de fichiers {<span><strong class="command">load ...</strong></span>}</h4></div></div></div><p> 
			On peut charger un fichier de commande &agrave; l'aide de la commande 
			<span><strong class="command">load "&lt;file&gt;";</strong></span>. Les commandes de ce fichier doivent 
			avoir la m&ecirc;me syntaxe que les commandes Moca-RP<sup>C</sup>. 
			Le nom du fichier doit &ecirc;tre mis entre guillemets.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Save"></a>Sauvegarde de fichier {<span><strong class="command">save ...</strong></span>}</h4></div></div></div><p> 
			On a la possibilit&eacute; de sauvegarder l'ensemble des r&eacute;seaux et des options de Moca-RP<sup>C</sup> 
			en m&eacute;moire &agrave; l'aide de la commande <span><strong class="command">save "&lt;file&gt;";</strong></span>.
		</p><p> 
			Les donn&eacute;es sauvegard&eacute;es sont les suivantes :
			<div class="itemizedlist"><ul type="disc" compact><li>
					Les r&eacute;seaux au format Moca-RP<sup>C</sup>
				</li><li>
					Les diff&eacute;rentes options
				</li></ul></div>
		</p><p> 
			Le nom du fichier doit &ecirc;tre mis entre guillemets.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Parser"></a>Gestion des diff&eacute;rents formats de donn&eacute;es {<span><strong class="command">##parser ...</strong></span>}</h4></div></div></div><p> 
			L'interpr&eacute;teur de commandes ne g&egrave;re pas directement le chargement des r&eacute;seaux de 
			Petri. Il se d&eacute;charge pour cette op&eacute;ration sur des "Parseurs" sp&eacute;cifique &agrave; un 
			format de donn&eacute;e. 
		</p><p> 
			Actuellement, il existe trois parseurs support&eacute; par Moca-RP<sup>C</sup> : 
			<div class="itemizedlist"><ul type="disc"><li>
					Le parseur Moca12/Moca permettant de charger des fichiers de versions
					12 et suivante de Moca-RP<sup>C</sup> (Cf. <a href="#Moca.Moca12" title="Format des R&eacute;seaux de Petri de Moca-RPC">la section intitul&eacute;e &laquo;&nbsp;Format des R&eacute;seaux de Petri de Moca-RP<sup>C</sup>&nbsp;&raquo;</a> 
					pour plus d'informations sur ce format), 
				</li><li>
					Le parseur Moca10 permettant de charger des fichiers des pr&eacute;c&eacute;dentes 
					versions de Moca-RP<sup>C</sup> (Ce format est d&eacute;crit dans [5]. 
					Cf. <a href="#Moca.Moca10" title="A.&nbsp;Lecture de fichiers au format Moca10">Annexe&nbsp;A, <i xmlns:xlink="http://www.w3.org/1999/xlink">Lecture de fichiers au format Moca10</i></a> pour la description des diff&eacute;rentes 
					options d'ouverture du fichier). 
				</li><li>
					Le parseur Aralia permettant de charger des fichiers au format Aralia. 
					(Cf. <a href="#Moca.Aralia" title="B.&nbsp;Lecture de fichiers au format Aralia">Annexe&nbsp;B, <i>Lecture de fichiers au format Aralia</i></a> pour la description de diff&eacute;rentes 
					options d'ouverture du fichier). 
				</li></ul></div>
		</p><p> 
			La commande display parser; permet d'afficher tous les parseurs de donn&eacute;es 
			disponibles dans Moca-RP<sup>C</sup> avec dans la mesure du possible un rappel sur la 
			syntaxe de la ligne de commande. 
		</p><p> 
			Pour ouvrir un fichier dans un format, il faut utiliser la commande 
			<span><strong class="command">load &lt;parser&gt; "&lt;file&gt;" ["&lt;options&gt;"];</strong></span> o&ugrave; 
			<code class="literal">&lt;parser&gt;</code>est un parseur support&eacute; par Moca-RP<sup>C</sup>, 
			<code class="literal">&lt;file&gt;</code> le nom du fichier &agrave; charger 
			et <code class="literal">"&lt;options&gt;"</code> des options sp&eacute;cifiques au parseur.
		</p><p> 
			Il est &eacute;galement possible d'ouvrir directement au sein de l'interpr&eacute;teur 
			une session afin de saisir un r&eacute;seau de Petri &agrave; l'aide d'un parseur dans un 
			format sp&eacute;cifique. 
			L'ouverture de la session se fait &agrave; l'aide de la commande 
			<span><strong class="command">##parser &lt;parser&gt; [&lt;options&gt;]</strong></span> o&ugrave; 
			<code class="literal">&lt;parser&gt;</code> est un parseur support&eacute; par Moca-RP<sup>C</sup> 
			(la fin de ligne permet de sp&eacute;cifier des options de cr&eacute;ation sp&eacute;cifique au parseur). 
			Il est alors possible de saisir directement le r&eacute;seau de Petri au format sp&eacute;cifi&eacute;. 
			La commande <span><strong class="command">##endparser</strong></span> permet de fermer cette session. 
			Le texte saisi pendant la session est alors interpr&eacute;t&eacute; et des &eacute;ventuels messages 
			d'avertissement ou d'erreur sont affich&eacute;s.
		</p><p> 
			La session suivante permet de d&eacute;finir un r&eacute;seau de Petri nomm&eacute; <code class="literal">First</code>
			compos&eacute; de 2 transitions et de 2 places.
		</p><pre class="screen">Moca &gt; <strong class="userinput"><code>## parser Moca

net First {
  TR: def AM 1 1 AV 2 1 LOI exp 1e-3;
  TR: rep AM 2 1 AV 1 1 LOI exp 1e-2;
};

## endparser</code></strong>
## parser Moca at line 1
## endparser at line 8

Moca &gt; </pre></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.ClearAll"></a>R&eacute;initialisation {<span><strong class="command">clear all;</strong></span>}</h4></div></div></div><p> 
			Il est possible de r&eacute;initialiser l'interpr&eacute;teur &agrave; l'aide de cette commande. 
			Tous les r&eacute;seaux charg&eacute;s en m&eacute;moire, toutes les banques de r&eacute;sultats 
			(Cf. <a href="#Moca.IMoca.Cmd.Result" title="Commandes de gestion des r&eacute;sultats">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des r&eacute;sultats&nbsp;&raquo;</a>), tous les formats d'affichage 
			(Cf. <a href="#Moca.IMoca.Cmd.Format" title="Commandes de gestion des formats d'affichage">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des formats d'affichage&nbsp;&raquo;</a>) sont supprim&eacute;s. 
			Par contre, les options de l'interpr&eacute;teur (Cf. <a href="#Moca.IMoca.Cmd.Options" title="Options de l'interpr&eacute;teur de commandes {display options |set ...}">la section intitul&eacute;e &laquo;&nbsp;Options de l'interpr&eacute;teur de commandes {<span><strong class="command">display options |set ...</strong></span>}&nbsp;&raquo;</a>) 
			sont conserv&eacute;es.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Exit"></a>Sortie de l'interpr&eacute;teur {<span><strong class="command">exit ...</strong></span>}</h4></div></div></div><p> 
			Pour finir correctement une session Moca-RP<sup>C</sup>, il faut utiliser la commande 
			<span><strong class="command">exit;</strong></span>.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Redirection"></a>Redirection de l'affichage</h4></div></div></div><p> 
			Toutes les commandes d'affichage (display) peuvent &ecirc;tre redirig&eacute;es vers un fichier ASCII.
		</p><p> 
			Si le point-virgule terminant la commande est pr&eacute;c&eacute;d&eacute; par &gt; "&lt;file&gt;" (respectivement par &gt;&gt; "&lt;file&gt;"), les r&eacute;sultats sont affich&eacute;s (respectivement ajout&eacute;s) dans le fichier indiqu&eacute;. Sinon ils sont affich&eacute;s sur la sortie standard.
		</p><p> 
			<strong class="userinput"><code>display result drc &gt; "result.res";</code></strong> cr&eacute;e un fichier 
			<code class="literal">result.res</code> (l'&eacute;crase s'il existait d&eacute;j&agrave;) et affiche dans celui-ci les r&eacute;sultats 
			courants du r&eacute;seau drc.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Cmd.Net"></a>Commandes de gestion des r&eacute;seaux</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Net.Display"></a>Affichage d'un r&eacute;seau {<span><strong class="command">display net ...</strong></span>}</h4></div></div></div><p> 
			Il est possible d'afficher le nom de l'ensemble des r&eacute;seaux en m&eacute;moire &agrave; l'aide 
			de la commande <span><strong class="command">display net all;</strong></span>.
		</p><p> 
			Il est de plus possible d'afficher un r&eacute;seau de Petri en m&eacute;moire &agrave; l'aide de la commande
			<span><strong class="command">display net &lt;id-net&gt;;</strong></span> o&ugrave; <code class="literal">&lt;id-net&gt;</code> est 
			le nom d'un r&eacute;seau de Petri en m&eacute;moire.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Net.Set"></a>Modification d'un r&eacute;seau {<span><strong class="command">set net ...</strong></span>}</h4></div></div></div><p> 
			Il est int&eacute;ressant et souvent n&eacute;cessaire de devoir modifier &agrave; la vol&eacute;e un r&eacute;seau en m&eacute;moire 
			&agrave; l'aide de l'interpr&eacute;teur de commandes. 
		</p><p> 
			Notons que la structure du r&eacute;seau de Petri ne peut pas &ecirc;tre modifi&eacute;e. 
		</p><p> 
			En revanche, les donn&eacute;es suivantes sont modifiables :
			<div class="itemizedlist"><ul type="disc" compact><li>
					Le nom et le titre d'un r&eacute;seau, 
				</li><li>
					La dur&eacute;e de simulation, 
				</li><li>
					La valeur des param&egrave;tres nomm&eacute;s, 
				</li><li>
					L'&eacute;tat initial (marquage initial des places et valeur initiale des variables) 
				</li><li>
					Les &eacute;tats statistiques qui ne sont que des observateurs du r&eacute;seau 
				</li></ul></div>
		</p><p> 
			Pour modifier un r&eacute;seau de Petri, il faut entrer dans un mode particulier 
			(un sous-shell) &agrave; l'aide de la commande <span><strong class="command">set net &lt;id-net&gt;;</strong></span> o&ugrave; 
			<code class="literal">&lt;id-net&gt;</code> est le nom d'un r&eacute;seau de Petri &agrave; modifier.
		</p><p> 
			Le sous-shell affiche un prompt de type <code class="literal">Modif[&lt;id-net&gt;]</code> et 
			accepte les commandes suivantes :
			<div class="itemizedlist"><ul type="disc" compact><li>
					<span><strong class="command">exit;</strong></span> permet de sortir du sous-shell 
				</li><li>
					<span><strong class="command">display;</strong></span> affiche le r&eacute;seau actuel 
				</li><li>
					<span><strong class="command">duration &lt;float&gt;;</strong></span> modifie la dur&eacute;e de simulation 
				</li><li>
					<span><strong class="command">name &lt;id-net&gt;;</strong></span> modifie le nom du r&eacute;seau 
				</li><li>
					<span><strong class="command">title "&lt;string&gt;";</strong></span> modifie le titre du r&eacute;seau 
					(attention <code class="literal">&lt;string&gt;</code> est une cha&icirc;ne de caract&egrave;re entour&eacute; 
					de guillemets) 
				</li><li>
					<span><strong class="command">state add [&lt;id-name&gt;] "&lt;expr&gt;" [hst];</strong></span> ajoute 
					un &eacute;tat statistique (nomm&eacute; <code class="literal">&lt;id-name&gt;</code>) d&eacute;finit &agrave; l'aide 
					de l'expression <code class="literal">&lt;expr&gt;</code>. Pour plus d'information
					concernant la syntaxe de l'expression, cf. <a href="#Moca.Moca12.Variables.NumExpr" title="Expressions num&eacute;riques">la section intitul&eacute;e &laquo;&nbsp;Expressions num&eacute;riques&nbsp;&raquo;</a>. 
				</li><li>
					<span><strong class="command">state add-expr [hst];</strong></span> ajoute un &eacute;tat statistique pour chaque 
					variable du mod&egrave;le. 
				</li><li>
					<span><strong class="command">state del {all | &lt;int&gt;};</strong></span> supprime tous les &eacute;tats 
					statistiques (<code class="literal">all</code>) ou le 
					<code class="literal">&lt;int&gt;</code><sup>&egrave;me</sup> &eacute;tat statistique. 
				</li><li>
					<span><strong class="command">state hst {all | &lt;int&gt;} &lt;value&gt;;</strong></span> modifie 
					l'histogramme de tous les &eacute;tats statistiques (<code class="literal">all</code>) ou le 
					<code class="literal">&lt;int&gt;</code><sup>&egrave;me</sup> &eacute;tat statistique 
					suivant <code class="literal">&lt;value&gt;</code> 
					(si <code class="literal">&lt;value&gt;</code> = 0 on supprime l'histogramme, sinon on l'ajoute). 
				</li><li>
					<span><strong class="command">state times {all | &lt;int&gt;} &lt;times&gt;;</strong></span> modifie les 
					temps de calcul de tous les &eacute;tats statistiques (<code class="literal">all</code>) ou le 
					<code class="literal">&lt;int&gt;</code><sup>&egrave;me</sup> &eacute;tat statistique. 
					Cf. <a href="#Moca.Moca12.Options.Times">option times</a> pour la syntaxe 
					de <code class="literal">&lt;times&gt;</code> 
				</li><li>
					<span><strong class="command">state type {all | &lt;int&gt;} &lt;num&gt; [, &lt;num&gt;]*;</strong></span> 
					modifie les types de statistiques de tous les &eacute;tats statistiques 
					(<code class="literal">all</code>) ou le 
					<code class="literal">&lt;int&gt;</code><sup>&egrave;me</sup> &eacute;tat statistique. 
					(Cf. <a href="#Moca.Moca12.Types" title="Rubrique : Type de statistiques">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Type de statistiques&nbsp;&raquo;</a>) 
				</li><li>
					<span><strong class="command">init &lt;id-var&gt; = &lt;value&gt;;</strong></span> modifie la valeur initiale 
					d'une variable ou la valeur d'un param&egrave;tre nomm&eacute; (constante). 
				</li><li>
					<span><strong class="command">init #&lt;num&gt; = &lt;value&gt;;</strong></span> modifie le marquage initial 
					de la place <code class="literal">&lt;num&gt;</code>. 
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Net.Clear"></a>Suppression d'un r&eacute;seau de Petri {<span><strong class="command">clear net ...</strong></span>}</h4></div></div></div><p> 
			Pour supprimer un r&eacute;seau de Petri, il suffit d'utiliser la commande 
			<span><strong class="command">clear net &lt;id-net&gt;;</strong></span> o&ugrave; <code class="literal">&lt;id-net&gt;</code> est 
			le nom d'un r&eacute;seau de Petri &agrave; supprimer.
		</p><p> 
			Pour supprimer tous les r&eacute;seaux de Petri en m&eacute;moire, il faut lancer la commande 
			<span><strong class="command">clear net all;</strong></span>.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Net.Simul"></a>Lancement d'une simulation {<span><strong class="command">simul ...</strong></span>}</h4></div></div></div><p> 
			Cette commande permet de lancer une simulation de Monte Carlo de N histoires sur un r&eacute;seau 
			de Petri donn&eacute;. Les param&egrave;tres de cette commande sont nombreux mais, en g&eacute;n&eacute;ral, optionnels. 
		</p><p> 
			A tout instant l'utilisateur peut suspendre la simulation en cours afin de consulter 
			les r&eacute;sultats. Pour se faire, l'utilisateur doit taper la s&eacute;quence de touches 
			<strong class="userinput"><code>CTRL-C</code></strong> ; le programme termine alors l'histoire courante.
		</p><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Net.Simul.Syntax"></a>Syntaxe de la commande</h5></div></div></div><pre class="programlisting"> 
	simul &lt;id-net&gt; [=&gt; &lt;result&gt;] {
	      story [until] &lt;nbr-stories&gt;
	      [delay &lt;delay&gt;]
	      [max-loop &lt;max-loop&gt;]
	      [seed &lt;seed&gt;]
	      [tries [until] &lt;nbr-tries&gt; {
	           [seed &lt;seed-tries&gt;]
	           [inc-seed &lt;inc-seed-tries&gt;]
	           [trace &lt;trace-tries&gt;]
	           [merge-histo]
	        }  ]
	      [batch &lt;size-batch&gt; [{
	           [trace &lt;trace-batch&gt;]
	           [inc-seed &lt;inc-seed&gt;]
	        }  ]  ]
	      [progress [&lt;nbr-class&gt;] ["&lt;format&gt;"]]
	} ;
			</pre><p> 
				Les param&egrave;tres obligatoires sont :
				<div class="itemizedlist"><ul type="disc"><li>
						<code class="literal">&lt;id-net&gt;</code>(identificateur) est le nom d'un r&eacute;seau 
						de Petri &agrave; simuler
					</li><li>
						<code class="literal">&lt;nbr-stories&gt;</code>(entier) est le nombre d'histoires 
						que l'on souhaite simuler. S'il est pr&eacute;c&eacute;d&eacute; du mot-clef <code class="literal">until</code>, 
						cela signifie que l'on souhaite simuler jusqu'&agrave; la 
						<code class="literal">&lt;nbr-stories&gt;</code> histoire. 
					</li></ul></div>
			</p><p> 
				Les param&egrave;tres g&eacute;n&eacute;raux optionnels sont :
				<div class="itemizedlist"><ul type="disc"><li>
						<code class="literal">&lt;result&gt;</code>(identificateur) est la banque o&ugrave; seront 
						stock&eacute;s les r&eacute;sultats. (Cf. <a href="#Moca.IMoca.Cmd.Result" title="Commandes de gestion des r&eacute;sultats">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des r&eacute;sultats&nbsp;&raquo;</a>). 
						Lorsque cette option n'est pas sp&eacute;cifi&eacute;e, la banque de r&eacute;sultats par d&eacute;faut 
						<code class="literal">def</code> est utilis&eacute;e. Si elle n'existe pas, elle est cr&eacute;&eacute;e.
					</li><li><p>
						<code class="literal">&lt;delay&gt;</code>(entier) permet de sp&eacute;cifier le temps 
						d'ex&eacute;cution maximal de Moca-RP<sup>C</sup> pour effectuer cette simulation. 
						Au-del&agrave; de ce temps, la commande termine l'histoire courante et arr&ecirc;te la 
						simulation. 
						</p><p>
						La valeur par d&eacute;faut de ce param&egrave;tre est fix&eacute;e dans les options 
						de l'interpr&eacute;teur (Cf. <a href="#Moca.IMoca.Cmd.Options" title="Options de l'interpr&eacute;teur de commandes {display options |set ...}">la section intitul&eacute;e &laquo;&nbsp;Options de l'interpr&eacute;teur de commandes {<span><strong class="command">display options |set ...</strong></span>}&nbsp;&raquo;</a>)
					</p></li><li><p>
						<code class="literal">&lt;max-loop&gt;</code>(entier) permet de sp&eacute;cifier le nombre 
						de transitions qui peuvent &ecirc;tre tir&eacute;es successivement sans que le temps 
						de l'histoire soit incr&eacute;ment&eacute;. 
						Au-del&agrave; de ce nombre la simulation est brutalement interrompue, la boucle 
						et l'&eacute;ch&eacute;ancier sont affich&eacute;s. 
						</p><p>
						La valeur par d&eacute;faut de ce param&egrave;tre est fix&eacute;e dans les options de 
						l'interpr&eacute;teur (Cf. <a href="#Moca.IMoca.Cmd.Options" title="Options de l'interpr&eacute;teur de commandes {display options |set ...}">la section intitul&eacute;e &laquo;&nbsp;Options de l'interpr&eacute;teur de commandes {<span><strong class="command">display options |set ...</strong></span>}&nbsp;&raquo;</a>)
					</p></li><li><p>
						<code class="literal">&lt;seed&gt;</code>(r&eacute;el) permet de sp&eacute;cifier la graine du 
						g&eacute;n&eacute;rateur de nombres au hasard. Cette donn&eacute;e permet en particulier de 
						rendre reproductible la simulation. Il est conseill&eacute; d'utiliser un 
						nombre r&eacute;el assez grand et impair. 
						</p><p>
						Lorsque la simulation courante n'est que la suite d'une pr&eacute;c&eacute;dente simulation 
						(banque de r&eacute;sultats ayant un nombre d'histoires sup&eacute;rieur &agrave; 0) 
						ce param&egrave;tre est ignor&eacute;. 
						</p><p>
						La valeur par d&eacute;faut de ce param&egrave;tre est fix&eacute;e dans les options 
						de l'interpr&eacute;teur (Cf. <a href="#Moca.IMoca.Cmd.Options" title="Options de l'interpr&eacute;teur de commandes {display options |set ...}">la section intitul&eacute;e &laquo;&nbsp;Options de l'interpr&eacute;teur de commandes {<span><strong class="command">display options |set ...</strong></span>}&nbsp;&raquo;</a>)
					</p></li><li>
						Il est possible d'afficher la progression de la simulation &agrave; l'aide 
						du mot-cl&eacute; <code class="literal">progress</code>. Les options de ce param&egrave;tre
						sont le nombre de classe d'affichage (<code class="literal">&lt;nbr-class&gt;</code> 
						par d&eacute;faut cette valeur est fix&eacute;e &agrave; 100) et le format d'affichage
						du message de progression (<code class="literal">&lt;format&gt;</code> 
						par d&eacute;faut &eacute;gal &agrave; <code class="literal">"[%P%%]"</code> ; <code class="literal">%P</code> 
						sera remplac&eacute; par l'&eacute;tat d'avancement en pourcentage et 
						<code class="literal">%%</code> sera remplac&eacute; par le caract&egrave;re '<code class="literal">%</code>'). 
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Net.Simul.Tries"></a>Cas d'une simulation double-d&eacute;tente</h5></div></div></div><p> 
				Dans Moca-RP<sup>C</sup>, une simulation double-d&eacute;tente consiste &agrave; tirer un jeu de param&egrave;tres 
				au hasard et de r&eacute;aliser <code class="literal">&lt;nbr-stories&gt;</code> histoires avec ce 
				jeu, puis de recommencer <code class="literal">&lt;nbr-tries&gt;</code> fois avec 
				<code class="literal">&lt;nbr-tries&gt;</code> autres jeux de param&egrave;tres. 
				Ainsi on obtient un &eacute;chantillon de <code class="literal">&lt;nbr-tries&gt;</code> moyennes 
				que l'on traite de mani&egrave;re classique. 
			</p><p> 
				Nous avons d&eacute;cid&eacute; de scinder le g&eacute;n&eacute;rateur de nombres al&eacute;atoires utilis&eacute; pour 
				g&eacute;n&eacute;rer le jeu de param&egrave;tres (<code class="literal">&lt;seed-tries&gt;</code>) du g&eacute;n&eacute;rateur 
				de nombre al&eacute;atoire utilis&eacute; pour r&eacute;aliser le nombre d'histoires 
				(<code class="literal">&lt;seed&gt;</code>). De plus, afin de rendre facilement parall&eacute;lisable 
				ce type de simulation, un incr&eacute;ment de la graine initiale 
				(<code class="literal">&lt;inc-seed-tries&gt;</code>) a &eacute;t&eacute; ajout&eacute; aux param&egrave;tres de ce type 
				de simulation.
			</p><p> 
				L'algorithme lors d'une simulation double-d&eacute;tente est alors le suivant : 
				<pre class="programlisting"> 
	Seed_tries = &lt;seed-tries&gt; ;
	Seed_story = &lt;seed&gt; ;
	Pour i de 0 &agrave; &lt;nbr-tries&gt; :
	    GenRandom_SetSeed(Seed_tries) ;
	Pour chaque expression faisant intervenir des g&eacute;n&eacute;rateurs de nombres al&eacute;atoires (nlog, unif ou norm) :
	Initialiser la valeur de l'expression en fonction de sa distribution et de ses param&egrave;tres
	    GenRandom_SetSeed(Seed_story) ;
	    Pour j de 0 &agrave; &lt;nbr-story&gt;
	        Faire une histoire
	    Seed_story += &lt;inc-seed-tries&gt; ;
	    Seed_tries += &lt;inc-seed-tries&gt; ;
				</pre>
			</p><p> 
				Les fonctions <code class="literal">GenRandom_GetSeed()</code> et 
				<code class="literal">GenRandom_SetSeed(seed)</code> permettent respectivement de r&eacute;cup&eacute;rer et de 
				fixer la graine du g&eacute;n&eacute;rateur de nombres al&eacute;atoires.
			</p><p> 
				Notons que la graine du g&eacute;n&eacute;rateur de nombres al&eacute;atoires utilis&eacute; pour g&eacute;n&eacute;rer le 
				i<sup>&egrave;me</sup> jeu de param&egrave;tres est &eacute;gal &agrave; 
				<code class="literal">&lt;seed-tries&gt; + (i-1)*&lt;inc-seed-tries&gt;</code>.
			</p><p> 
				Param&egrave;tres utilis&eacute;s lors d'une simulation double-d&eacute;tente tries { ... } :
				<div class="itemizedlist"><ul type="disc"><li>
						<code class="literal">&lt;nbr-tries&gt;</code>(entier) est le nombre de jeux de 
						param&egrave;tres que l'on souhaite simuler. S'il est pr&eacute;c&eacute;d&eacute; du mot-clef 
						<code class="literal">until</code>, cela signifie que l'on souhaite simuler 
						jusqu'au <code class="literal">&lt;nbr-tries&gt;</code> jeux de param&egrave;tres.
					</li><li>
						<code class="literal">&lt;seed-tries&gt;</code>(r&eacute;el) permet de sp&eacute;cifier la graine 
						du g&eacute;n&eacute;rateur de nombres au hasard permettant de g&eacute;n&eacute;rer les jeux de 
						param&egrave;tres. 
						Cette donn&eacute;e permet en particulier de rendre reproductible la simulation. 
						Il est conseill&eacute; d'utiliser un nombre r&eacute;el assez grand et impair.
					</li><li>
						<code class="literal">&lt;inc-seed-tries&gt;</code>(r&eacute;el) permet de sp&eacute;cifier 
						l'incr&eacute;ment de la graine du g&eacute;n&eacute;rateur de nombres al&eacute;atoires utilis&eacute; 
						pour g&eacute;n&eacute;rer chaque nouveau jeu de param&egrave;tres.
					</li><li>
						<code class="literal">&lt;trace-tries&gt;</code>(format d'affichage) permet d'afficher 
						les r&eacute;sultats interm&eacute;diaires issus de chaque jeu de param&egrave;tres ; 
						c'est &agrave; dire une fois les <code class="literal">&lt;nbr-stories&gt;</code> histoires 
						simul&eacute;es ; dans le format sp&eacute;cifi&eacute; (Cf. <a href="#Moca.IMoca.Cmd.Format" title="Commandes de gestion des formats d'affichage">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des formats d'affichage&nbsp;&raquo;</a>). 
					</li><li>
						<code class="literal">&lt;merge-histo&gt;</code> permet d'ajouter l'histogramme
						des &eacute;tats statistiques des <code class="literal">&lt;nbr-stories&gt;</code> histoires 
						au sein de l'histogramme du jeu de param&egrave;tres courant. 
						Dans le cas contraire, seule la valeur moyenne de l'&eacute;tat statistique est
						ajout&eacute;e &agrave; l'histogramme du jeu de param&egrave;tres courant. 
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Net.Simul.Batch"></a>Cas d'une simulation par lots</h5></div></div></div><p> 
				Il est possible dans Moca-RP<sup>C</sup> de faire des simulations par lots. 
				Dans l'absolu, cette fonctionnalit&eacute; n'apporte strictement rien. En effet, au lieu de 
				faire une simulation <span class="emphasis"><em>lin&eacute;aire</em></span>, on d&eacute;coupe le nombre d'histoires 
				&agrave; simuler <code class="literal">&lt;nbr-stories&gt;</code> en lots de taille identique 
				<code class="literal">&lt;size-batch&gt;</code>. Pour chaque lot, on fait une simulation classique 
				et on regroupe les r&eacute;sultats provenant des diff&eacute;rents lots afin d'obtenir le r&eacute;sultat 
				final de la simulation. 
			</p><p> 
				En fait l'int&eacute;r&ecirc;t de cette approche est de pouvoir facilement parall&eacute;liser la simulation. 
				Il est effectivement possible de distribuer la simulation &agrave; diff&eacute;rentes ressources de 
				calcul (processeur et/ou poste de calcul) en leur demandant de traiter diff&eacute;rents lots 
				d'histoires. 
				C'est la raison qui nous a pouss&eacute;s &agrave; impl&eacute;menter ce type de simulation, en local dans un 
				premier temps, en distribu&eacute; dans un second temps. 
			</p><p> 
				L'algorithme lors d'une simulation par lot est le suivant : 
				<pre class="programlisting"> 
	Nbr_batch = &lt;nbr-story&gt; / &lt;size-batch&gt; ;
	Seed_story = &lt;seed&gt; ;
	Pour i de 0 &agrave; Nbr_batch :
	    GenRandom_SetSeed(Seed_story) ;
	    Pour j de 0 &agrave; &lt;nbr-story&gt;
	        Faire une histoire
	    Ajouter au r&eacute;sultat courant le r&eacute;sultat de ce lot d'histoire
	    Seed_story += &lt;inc-seed&gt; ;
				</pre>
			</p><p> 
				La mani&egrave;re de calculer la moyenne et la variance pour des &eacute;chantillons par lots utilis&eacute;e 
				dans Moca-RP<sup>C</sup> est d&eacute;crite en annexe (Cf. <a href="#Moca.Compute.Merge.Result" title="R&eacute;sultats">la section intitul&eacute;e &laquo;&nbsp;R&eacute;sultats&nbsp;&raquo;</a>)
			</p><p> 
				Param&egrave;tres utilis&eacute;s lors d'une simulation par lot { ... } :
				<div class="itemizedlist"><ul type="disc"><li>
						<code class="literal">&lt;size-batch&gt;</code>(entier) est le nombre d'histoire par lot.
					</li><li>
						<code class="literal">&lt;inc-seed &gt;</code>(r&eacute;el) permet de sp&eacute;cifier l'incr&eacute;ment 
						de la graine du g&eacute;n&eacute;rateur de nombre al&eacute;atoire utilis&eacute; lors de la simulation 
						de chaque lot.
					</li><li>
						<code class="literal">&lt;trace-batch&gt;</code>(format d'affichage) permet d'afficher 
						les r&eacute;sultats interm&eacute;diaires issus de chaque lot d'histoires dans le 
						format sp&eacute;cifi&eacute; (Cf. <a href="#Moca.IMoca.Cmd.Format" title="Commandes de gestion des formats d'affichage">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des formats d'affichage&nbsp;&raquo;</a>). 
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Net.Simul.BatchTries"></a>Cas d'une simulation double-d&eacute;tente par lot</h5></div></div></div><p> 
				L'id&eacute;e est de coupler les deux types de simulation pr&eacute;c&eacute;dents. 
			</p><p> 
				L'algorithme mis en &#339;uvre est alors le suivant : 
				<pre class="programlisting"> 
	Seed_tries = &lt;seed-tries&gt; ;
	Nbr_batch = &lt;nbr-story&gt; / &lt;size-batch&gt; ;
	Pour i de 0 &agrave; &lt;nbr-tries&gt; :
	    GenRandom_SetSeed(Seed_tries) ;
	Pour chaque expression faisant intervenir les g&eacute;n&eacute;rateurs de nombres al&eacute;atoires (nlog, unif ou norm) :
	Initialiser la valeur de l'expression en fonction de sa distribution et de ses param&egrave;tres
	    Seed_story = &lt;seed&gt; + i * &lt;inc-seed-tries&gt;;
	    Pour j de 0 &agrave; Nbr_batch :
	        GenRandom_SetSeed(Seed_story) ;
	        Pour k de 0 &agrave; &lt;nbr-story&gt;
	           Faire une histoire
	       Ajouter au r&eacute;sultat courant le r&eacute;sultat de ce lot 
	        Seed_story += &lt;inc-seed&gt; ;
	    Seed_tries += &lt;inc-seed-tries&gt; ;
				</pre>
			</p><p> 
				Tous les param&egrave;tres ont d&eacute;j&agrave; &eacute;t&eacute; pr&eacute;sent&eacute;s.
			</p><p> 
				Notons que le param&egrave;tre <code class="code">&lt;inc-seed-tries&gt;</code> sert :
				<div class="itemizedlist"><ul type="disc" compact><li>
						d'incr&eacute;ment pour le g&eacute;n&eacute;rateur d&eacute;terminant le jeu de param&egrave;tres 
					</li><li>
						d'incr&eacute;ment pour le g&eacute;n&eacute;rateur d&eacute;terminant la simulation classique. 
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Net.Simul.Locker"></a>Arr&ecirc;t de la simulation de mani&egrave;re externe {<span><strong class="command">set simul locker ...</strong></span>}</h5></div></div></div><p> 
				Afin de permettre d'arr&ecirc;ter la simulation sans envoyer de signal SIGINT 
				(&eacute;quivalent d'un Ctrl+C - ce qui est impossible &agrave; faire en Java par exemple), 
				il est maintenant possible d'arreter la simulation lorsque la pr&eacute;sence 
				d'un fichier lock est av&eacute;r&eacute;e.
			</p><p> 
				Pour activer cette fonctionnalit&eacute;, il faut utiliser la commande 
				<span><strong class="command">set simul locker "&lt;file&gt;";</strong></span> o&ugrave; <code class="literal">&lt;file&gt;</code> est 
				le nom d'un fichier entour&eacute; par des guillemets. 
				Si ce fichier existe la simulation s'arr&ecirc;te.
			</p><p> 
				Pour d&eacute;sactiver cette fonctionnalit&eacute;, il suffit de lancer la commande 
				<span><strong class="command">set simul locker;</strong></span> (sans nom de fichier).
			</p></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Cmd.Result"></a>Commandes de gestion des r&eacute;sultats</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Intro"></a>Introduction</h4></div></div></div><p> 
			Les diff&eacute;rentes &eacute;volutions de Moca-RP<sup>C</sup> ont conduit &agrave; introduire des banques de r&eacute;sultats. 
			Une banque de r&eacute;sultats est une structure de donn&eacute;es contenant suffisamment 
			d'informations pour poursuivre une simulation. 
		</p><p> 
			Les informations stock&eacute;es au sein de ces banques de r&eacute;sultats sont : 
			<div class="itemizedlist"><ul type="disc" compact><li>
					Les informations sur l'&eacute;tat de la simulation &agrave; terminaison ; A savoir
					le nombre d'histoire jou&eacute;e, la graine du g&eacute;n&eacute;rateur de nombre al&eacute;atoire
					lors de l'arr&ecirc;t de la simulation, ...
				</li><li>
					L'ensemble des estimateurs statistiques (moyenne, &eacute;cart type, donn&eacute;e censur&eacute;)
					pour les transitions, places et observateurs aux diff&eacute;rents temps observ&eacute;s.
				</li><li>
					L'ensemble des histogrammes (transitions et observateurs).
				</li><li>
					L'ensemble des chronogrammes (observateurs).
				</li></ul></div>
		</p><p> 
			Dans les versions pr&eacute;c&eacute;dentes la version 12.17, Moca-RP<sup>C</sup> utilisait 
			ces structures de donn&eacute;es 
			<div class="itemizedlist"><ul type="disc" compact><li>
					pour m&eacute;moriser les r&eacute;sultats de chaque lot d'histoires (traitement batch) 
				</li><li>
					pour m&eacute;moriser les r&eacute;sultats issus de la simulation d'un jeu de param&egrave;tres 
					lors d'une simulation double-d&eacute;tente. 
				</li><li>
					pour sauvegarder/charger ces r&eacute;sultats sous la forme de fichier binaire 
					utilis&eacute; lors des &eacute;changes de donn&eacute;es entre les serveurs de calcul et 
					le client lors d'un calcul distribu&eacute;. 
				</li></ul></div>
		</p><p> 
			Le m&eacute;canisme de calcul distribu&eacute; interne &agrave; Moca-RP<sup>C</sup> (&agrave; l'&eacute;poque bas&eacute; sur 
			le protocole Corba) n'a pas &eacute;t&eacute; maintenu.
		</p><p> 
			En revanche, les commandes permettant d'enregistrer/charger des banques de 
			r&eacute;sultat, ainsi que de synth&eacute;tiser les diff&eacute;rentes banques de r&eacute;sultats 
			ont &eacute;t&eacute; conserv&eacute;es. 
		</p><p> 
			Un r&eacute;seau de Petri peut donc utiliser une ou plusieurs banques de r&eacute;sultats. 
			Il n'y a pas d'interd&eacute;pendance entre ces banques. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Access"></a>Acc&egrave;s aux diff&eacute;rentes banques de r&eacute;sultats</h4></div></div></div><p> 
			L'acc&egrave;s &agrave; une banque de r&eacute;sultats ne se fait qu'&agrave; travers le r&eacute;seau dont elle d&eacute;pend. 
			Pour acc&eacute;der &agrave; la banque de r&eacute;sultat <code class="literal">bank1</code> du r&eacute;seau 
			<code class="literal">PNet1</code>, il suffit d'&eacute;crire 
			<strong class="userinput"><code>PNet1 =&gt; bank1</code></strong>. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Display"></a>Affichage des r&eacute;sultats {<span><strong class="command">result display ...</strong></span>}</h4></div></div></div><p> 
			Pour afficher les r&eacute;sultats associ&eacute;s &agrave; une banque de r&eacute;sultats, il faut utiliser 
			la commande <span><strong class="command">result display &lt;access-result&gt; [&lt;format-result&gt;];
			</strong></span> o&ugrave; <code class="literal">&lt;access-result&gt;</code> est un acc&egrave;s &agrave; une banque 
			de r&eacute;sultats et <code class="literal">&lt;format-result&gt;</code> est un format d'affichage 
			(Cf. <a href="#Moca.IMoca.Cmd.Format" title="Commandes de gestion des formats d'affichage">la section intitul&eacute;e &laquo;&nbsp;Commandes de gestion des formats d'affichage&nbsp;&raquo;</a>). 
			Si ce dernier param&egrave;tre n'est pas pr&eacute;sent, le format d'affichage par d&eacute;faut est utilis&eacute;.
		</p><p>
			Il est &eacute;galement possible de conna&icirc;tre toutes les banques de r&eacute;sultats d'un r&eacute;seau 
			&agrave; l'aide de la commande <span><strong class="command">result display &lt;id-net&gt; all;</strong></span>
			o&ugrave; <code class="literal">&lt;id-net&gt;</code> est le nom d'un r&eacute;seau de Petri en m&eacute;moire.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.LoadSave"></a>Chargement et sauvegarde de r&eacute;sultats {<span><strong class="command">result load|save ...</strong></span>}</h4></div></div></div><p> 
			Il est possible de sauvegarder/charger une banque de r&eacute;sultats dans un fichier 
			binaire. L'int&eacute;r&ecirc;t de cette approche r&eacute;side dans la possibilit&eacute; d'arr&ecirc;ter une 
			simulation en cours et de pouvoir la reprendre plus tard sans perdre les 
			simulations d&eacute;j&agrave; effectu&eacute;es. 
		</p><p>
			Pour sauvegarder une banque de r&eacute;sultats, il suffit d'utiliser la commande 
			<span><strong class="command">result save &lt;access-result&gt; "&lt;file&gt;";</strong></span> 
			o&ugrave; <code class="literal">&lt;access-result&gt;</code> est un acc&egrave;s &agrave; une banque de r&eacute;sultats 
			et <code class="literal">&lt;file&gt;</code> un nom de fichier entour&eacute; de guillemets. 
		</p><p>
			Pour recharger une banque de r&eacute;sultats, il faut avoir au pr&eacute;alable le r&eacute;seau 
			en m&eacute;moire et utiliser la 
			commande <span><strong class="command">result load &lt;id-net&gt; "&lt;file&gt;";</strong></span> 
			o&ugrave; <code class="literal">&lt;id-net&gt;</code> est le nom du r&eacute;seau de Petri 
			et <code class="literal">&lt;file&gt;</code> un nom (entour&eacute; de guillemets) du fichier 
			binaire contenant une banque de r&eacute;sultats du r&eacute;seau consid&eacute;r&eacute;.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Clear"></a>Suppression d'une banque de r&eacute;sultats {<span><strong class="command">result clear ...</strong></span>}</h4></div></div></div><p> 
			Pour supprimer une banque de r&eacute;sultat, il suffit d'utiliser la commande 
			<span><strong class="command">result clear &lt;access-result&gt;;</strong></span> o&ugrave; 
			<code class="literal">&lt;access-result&gt;</code> est un acc&egrave;s &agrave; la banque de r&eacute;sultats 
			&agrave; supprimer.
		</p><p>
			Pour supprimer toutes les banques de r&eacute;sultats d'un r&eacute;seau, il faut lancer la commande 
			<span><strong class="command">result clear &lt;id-net&gt; all;</strong></span> o&ugrave; 
			<code class="literal">&lt;id-net&gt;</code> est le nom du r&eacute;seau de Petri consid&eacute;r&eacute;.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Merge"></a>Fusion de 2 banques de r&eacute;sultats {<span><strong class="command">result merge ...</strong></span>}</h4></div><div><h5 class="subtitle">Cas d'une simulation par lot</h5></div></div></div><p> 
			La commande <span><strong class="command">result merge &lt;id-net&gt;=&gt;&lt;id-result1&gt; &lt;id-result2&gt;;</strong></span>
			(o&ugrave; <code class="literal">&lt;id-net&gt;</code> est le nom du r&eacute;seau de Petri consid&eacute;r&eacute; 
			et <code class="literal">&lt;id-result1&gt;</code> et <code class="literal">&lt;id-result2&gt;</code>
			2 banques de r&eacute;sultats) permet de fusionner les 2 banques de r&eacute;sultats. Le r&eacute;sultat
			de cette fusion est stock&eacute; dans la premi&egrave;re banque.
		</p><p>
			La fusion est r&eacute;alis&eacute;e en fonction de la nature des donn&eacute;es &agrave; fusionner.
			<div class="itemizedlist"><ul type="disc" compact><li>
					Pour les estimateurs statistiques (moyenne, &eacute;cart type, donn&eacute;e censur&eacute;),
					il est possible de fusionner ces informations sans conna&icirc;tre la valeur
					de chaque histoire de chaque lot. Pour plus d'information, voir
					<a href="#Moca.Compute.Merge" title="Lors de la fusion de 2 lots">la section intitul&eacute;e &laquo;&nbsp;Lors de la fusion de 2 lots&nbsp;&raquo;</a>
				</li><li>
					Pour les histogrammes, il suffit de mettre bout &agrave; bout les 
					histogrammes des 2 lots.
				</li><li>
					Pour les chronogrammes, une fonction a &eacute;t&eacute; d&eacute;velopp&eacute; pour fusionner
					2 chronogrammes de poids diff&eacute;rents (en effet le nombre d'histoire
					associ&eacute; &agrave; chaque lot n'est pas forcement le m&ecirc;me).
					La diminution du nombre de points du chronogramme se fait apr&egrave;s la 
					fusion &agrave; proprement parl&eacute;.
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Add"></a>Ajout d'une banque dans une autre {<span><strong class="command">result add ...</strong></span>}</h4></div><div><h5 class="subtitle">Cas d'une simulation double-d&eacute;tente</h5></div></div></div><p> 
			La commande <span><strong class="command">result add &lt;id-net&gt;=&gt;&lt;id-result1&gt; &lt;id-result2&gt;;</strong></span>
			(o&ugrave; <code class="literal">&lt;id-net&gt;</code> est le nom du r&eacute;seau de Petri consid&eacute;r&eacute; 
			et <code class="literal">&lt;id-result1&gt;</code> et <code class="literal">&lt;id-result2&gt;</code>
			2 banques de r&eacute;sultats) permet d'ajouter les r&eacute;sultats de la seconde banque 
			dans la premi&egrave;re.
		</p>
			L'objectif &eacute;tant de traiter le cas d'une simulation double-d&eacute;tente, les 2 
			banques de r&eacute;sultat n'ont pas la m&ecirc;me signification. La premi&egrave;re banque
			permet de stocker les r&eacute;sultats des diff&eacute;rents jeux de param&egrave;tres.
			La seconde correspond aux r&eacute;sultats associ&eacute;s &agrave; un jeu de param&egrave;tres.
		<p>
		</p><p>
			L'ajout est r&eacute;alis&eacute; en fonction de la nature des donn&eacute;es &agrave; prendre en compte.
			<div class="itemizedlist"><ul type="disc" compact><li>
					Pour les estimateurs statistiques (moyenne, &eacute;cart type, donn&eacute;e censur&eacute;),
					la moyenne est utilis&eacute;e comme valeur unitaire du jeu de param&egrave;tre.
				</li><li>
					Les histogrammes des transitions provenant du jeu de param&egrave;tres 
					ne sont pas pris en compte.
    				Les histogrammes des &eacute;tats statistiques du jeu de param&egrave;tre sont en revanche 
    				pris en compte.
				</li><li>
					Le chronogramme moyen issu d'un jeu de param&egrave;tres est vu comme 
					le chronogramme d'une seule histoire. Il est donc fusionn&eacute; avec un 
					poids de 1.
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Result.Example"></a>Exemple d'un traitement par lot &agrave; l'aide de banques de r&eacute;sultat</h4></div></div></div><p> 
			L'exemple qui suit montre l'utilisation des banques de r&eacute;sultats 
			pour simuler une simulation par lot, c'est-&agrave;-dire faire la m&ecirc;me
			chose qu'une simulation par lot 
			(Cf. <a href="#Moca.IMoca.Cmd.Net.Simul.Batch" title="Cas d'une simulation par lots">la section intitul&eacute;e &laquo;&nbsp;Cas d'une simulation par lots&nbsp;&raquo;</a>), 
			mais avec uniquement des simulations standards et des manipulations 
			sur les banques de r&eacute;sultats. 
<pre class="screen">01  simul PetriNet3=&gt;Lot1 {
02  	story 500 
03  	seed 12345679};
04  result merge PetriNet3=&gt;Result1 Lot1;
05  simul PetriNet3=&gt;Lot2 {
06  	story 500 
07  	seed 12345802};
08  result merge PetriNet3=&gt;Result1 Lot2;
09  simul PetriNet3=&gt;Lot3 {
10  	story 500 
11  	seed 12345925};
12  result merge PetriNet3=&gt;Result1 Lot3;
13  
14  simul PetriNet3=&gt;Result2 {
15  	story 1500 
16  	seed 12345679 
17  	batch 500 {inc-seed 123} };</pre>
		</p><p>
			Les commandes ligne 01, 05 et 09 permettent de faire des simulations
			de 500 histoires avec des graines de nombre al&eacute;atoire diff&eacute;rentes.
			Les r&eacute;sultats de ces simulations sont stock&eacute;s dans les banques de 
			r&eacute;sultats Lot1, Lot2 et Lot3.
		</p><p>
			Les commandes ligne 04, 08 et 12 permettent de synth&eacute;tiser les
			diff&eacute;rentes banques de r&eacute;sultat au sein de la banque Result1.
		</p><p>
			La commande ligne 14 est la commande &eacute;quivalente.
		</p><p>
			L'int&eacute;r&ecirc;t est de pouvoir faire la simulation de chaque lot sur diff&eacute;rentes
			ressources de calcul et de pouvoir regrouper ces r&eacute;sultats.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Cmd.Format"></a>Commandes de gestion des formats d'affichage</h3></div></div></div><p> 
		Au vu des nombreuses demandes de modification des affichages des r&eacute;sultats dans 
		les versions pr&eacute;c&eacute;dentes de Moca-RP<sup>C</sup>, nous proposons maintenant un format 
		d'affichage personnalisable en terme de types de tabulations, de pr&eacute;cisions, ...
	</p><p> 
		L'interpr&eacute;teur de commandes g&egrave;re une liste de format et il est possible d'afficher 
		une banque de r&eacute;sultats en utilisant un des formats d'affichage de la liste. 
		Il existe toujours un format d'affichage par d&eacute;faut (nomm&eacute; <code class="literal">default</code>).
	</p><p> 
		Les formats d'affichage provenant de la version 10.07 de Moca-RP<sup>C</sup> ont &eacute;t&eacute; traduits 
		au format d'affichage de la version courante. Ces formats d'affichage sont d&eacute;finis 
		au sein du fichier <code class="filename">Moca13 .ini</code> (fichier faisant parti 
		du package de Moca-RP<sup>C</sup>).
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Format.Create"></a>Cr&eacute;ation d'un format d'affichage {<span><strong class="command">set format ...</strong></span>}</h4></div></div></div><p> 
			La commande suivante permet de cr&eacute;er un format d'affichage : 
			<pre class="programlisting">	set format &lt;id-format&gt; {
	... /* Diff&eacute;rentes directives d'affichage */
	} ;</pre>
			o&ugrave; <code class="literal">&lt;id-format&gt;</code> est le nom du format d'affichage.
		</p><p> 
			Un format d'affichage est donc compos&eacute; d'une ou plusieurs directives d'affichage. 
			Chaque directive commence par un mot-clef l'identifiant et par un certain nombre d'options. 
		</p><p> 
			Parmi ces options, on retrouve pratiquement toujours une cha&icirc;ne de caract&egrave;res 
			(entour&eacute;e de guillemets) pr&eacute;cisant le texte &agrave; afficher. Ce texte, de la responsabilit&eacute; 
			de l'utilisateur, contient des champs dans un format sp&eacute;cifique. Lors de l'affichage 
			des r&eacute;sultats ces champs sont remplac&eacute;s par l'information qu'ils codent.
		</p><p> 
			Un champ est compos&eacute; d'une suite de balise obligatoire ou optionnel dans l'ordre suivant :
			<pre class="programlisting"> % [flags] [width] [.precision] $ type </pre>
		</p><p> 
			Chaque balise est un caract&egrave;re simple ou un nombre ayant une signification particuli&egrave;re. 
			Le champ le plus simple contient seulement le signe de pourcentage, 
			le signe '$' (dollars) et un caract&egrave;re sp&eacute;cifiant le type d'information &agrave; afficher. 
			Le type d&eacute;pend forcement de la directive d'affichage en cours. 
			Il est remplac&eacute; &agrave; l'affichage par un caract&egrave;re, une cha&icirc;ne de caract&egrave;res ou un nombre. 
			Si le signe '$' est suivi par un caract&egrave;re ne correspondant par &agrave; la directive 
			d'affichage, une erreur s'affiche &agrave; l'&eacute;cran. 
		</p><p> 
			Pour afficher le signe de pourcentage, utilisez %%.
		</p><p> 
			Les balises optionnelles, qui apparaissent avant le signe $ contr&ocirc;le le format 
			d'affichage du champ. 
			<div class="itemizedlist"><ul type="disc"><li><p>
					<code class="literal">flags</code> : caract&egrave;re(s) optionnel(s) contr&ocirc;lant 
					<div class="itemizedlist"><ul type="circle" compact><li>
							la justification de la sortie : Si '-' est pr&eacute;sent la justification 
							se fera &agrave; droite, par d&eacute;faut elle se fait &agrave; gauche.
						</li><li>
							l'affichage de signe : Si '+' est pr&eacute;sent, les nombres sont pr&eacute;c&eacute;d&eacute;s 
							du signe &lsquo;+' s'ils sont positifs.
						</li><li>
							le caract&egrave;re de remplissage. Si <code class="literal">width</code> est sup&eacute;rieur 
							&agrave; l'affichage normal, des caract&egrave;res sont affich&eacute;s en plus. 
							'0' et ' ' (espace) sont des flags qui forcent ce remplissage &agrave; l'aide 
							de z&eacute;ros ou d'espaces.
						</li><li>
							l'affichage de virgules d&eacute;cimales : Si '#' est pr&eacute;sent, le point 
							d&eacute;cimal sera toujours affich&eacute;.
						</li><li>
							l'affichage au format XML : Si 'x' est pr&eacute;sent, les caract&egrave;res 
							{&amp;, &lt;, &gt;, ', "} sont remplac&eacute;s par les cha&icirc;nes
							de caract&egrave;res {&amp;amp;, &amp;lt;, &amp;gt;, &amp;apos;, &amp;quot;}.
						</li></ul></div>
				</p></li><li><p>
					<code class="literal">width</code> : nombre optionnel sp&eacute;cifiant le nombre minimum de 
					caract&egrave;res de l'affichage.
				</p></li><li><p>
					<code class="literal">precision</code> : nombre optionnel sp&eacute;cifiant soit le nombre 
					maximum de caract&egrave;res &agrave; afficher dans le cas d'une cha&icirc;ne de caract&egrave;res 
					ou d'un entier, soit le nombre de chiffre significatif pour un nombre r&eacute;el. 
					Ce nombre peut &ecirc;tre remplac&eacute; par le caract&egrave;re '_', auquel cas la pr&eacute;cision 
					par d&eacute;faut (option de l'interpr&eacute;teur de commandes) sera utilis&eacute;e.
				</p></li></ul></div>
		</p><p> 
			Apr&egrave;s cette introduction, les paragraphes qui suivent pr&eacute;sentent les diff&eacute;rentes 
			directives d'affichage.
		</p><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Info"></a>Directive pour les informations g&eacute;n&eacute;rales</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Afficher des informations g&eacute;n&eacute;rales sur 
				la simulation
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : <span><strong class="command">Info "&lt;format&gt;"</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de caract&egrave;res acceptant 
				les types de champs suivants :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">T</code> : Titre du r&eacute;seau (cha&icirc;ne de caract&egrave;res) 
					</li><li>
						<code class="code">t</code> : Nom du r&eacute;seau (cha&icirc;ne de caract&egrave;res) 
					</li><li>
						<code class="code">B</code> : Nom de la banque de r&eacute;sultat (cha&icirc;ne de caract&egrave;res) 
					</li><li>
						<code class="code">S</code> : Nombre d'histoires simul&eacute;es (entier) 
					</li><li>
						<code class="code">C</code> : Graine initiale du g&eacute;n&eacute;rateur de nombres al&eacute;atoires (r&eacute;el) 
					</li><li>
						<code class="code">L</code> : Graine courante du g&eacute;n&eacute;rateur de nombres al&eacute;atoires (r&eacute;el) 
					</li><li>
						<code class="code">D</code> : Dur&eacute;e d'une histoire (r&eacute;el) 
					</li><li>
						<code class="code">@</code> : Diff&eacute;rents temps de calcul pour les &eacute;tats statistiques 
					</li><li>
						<code class="code">1|2|3|4|5|6</code> : Type de statistique pris en compte dans la 
						simulation ("ON" | "OFF") 
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Tr"></a>Directive pour les transitions</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque transition (s&eacute;lectionn&eacute;e), afficher 
				son nom, num&eacute;ro, moyenne, &eacute;cart-type et/ou intervalle de confiance.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">Tr &lt;select&gt; "&lt;format&gt;" ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> de transitions, 
				<code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher et 
				<code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de caract&egrave;res acceptant 
				les types de champs suivants :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">n</code> : Num&eacute;ro de la transition (entier) 
					</li><li>
						<code class="code">N</code> : Nom de la transition (cha&icirc;ne de caract&egrave;res) 
					</li><li>
						<code class="code">M</code> : Nombre moyen de tir de la transition (r&eacute;el) 
					</li><li>
						<code class="code">S</code> : Ecart-type sur le tir de la transition (r&eacute;el) 
					</li><li>
						<code class="code">I</code> : Intervalle de confiance &agrave; 90 % sur le tir de la transition (r&eacute;el)
					</li></ul></div>
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur de transitions est vide. 
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Pl"></a>Directive pour les places</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque place (s&eacute;lectionn&eacute;e), afficher 
				son nom, num&eacute;ro, et/ou (moyenne, &eacute;cart-type, intervalle de confiance) 
				des diff&eacute;rentes grandeurs statistiques calcul&eacute;es.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">Pl &lt;select&gt; "&lt;format&gt;" ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> de places, 
				<code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher et 
				<code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de caract&egrave;res acceptant 
				les types de champs suivants :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">n</code> : Num&eacute;ro de la place (entier) 
					</li><li>
						<code class="code">N</code> : Nom de la place (cha&icirc;ne de caract&egrave;res) 
					</li><li>
						<code class="code">K</code> : Marquage moyen en fin d'histoire de la place (r&eacute;el) 
					</li><li>
						<code class="code">L</code> : Marquage moyen de la place (r&eacute;el) 
					</li><li>
						<code class="code">M</code> : Temps moyen de s&eacute;jour dans la place (r&eacute;el) 
					</li><li>
						<code class="code">Q</code> : Ecart-type sur le marquage moyen en fin d'histoire 
						de la place (r&eacute;el) 
					</li><li>
						<code class="code">R</code> : Ecart-type sur le marquage moyen de la place (r&eacute;el) 
					</li><li>
						<code class="code">S</code> : Ecart-type sur le temps moyen de s&eacute;jour dans la place (r&eacute;el) 
					</li><li>
						<code class="code">G</code> : Intervalle de confiance &agrave; 90 % sur le marquage moyen 
						en fin d'histoire de la place (r&eacute;el) 
					</li><li>
						<code class="code">H</code> : Intervalle de confiance &agrave; 90 % sur le marquage moyen 
						de la place (r&eacute;el) 
					</li><li>
						<code class="code">I</code> : Intervalle de confiance &agrave; 90 % sur le temps moyen 
						de s&eacute;jour dans la place (r&eacute;el) 
					</li><li>
						<code class="code">P</code> : Pourcentage de temps total pass&eacute; avec un jeton 
						dans la place (r&eacute;el).
					</li></ul></div>
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur de places est vide. 
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.St"></a>Directive pour les &eacute;tats statistiques (Ancienne version)</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque &eacute;tat statistique (s&eacute;lectionn&eacute;), 
				afficher son nom, num&eacute;ro, et/ou (moyenne, &eacute;cart-type, intervalle de confiance) 
				des diff&eacute;rentes grandeurs statistiques calcul&eacute;es.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">St &lt;type&gt; &lt;select&gt; "&lt;format&gt;" ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;type&gt;</code> correspond &agrave; un type de statistique sp&eacute;cifique 
				(1,2,3,4,5 ou 6), <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> d'&eacute;tats statistiques, 
				<code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher et 
				<code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de caract&egrave;res acceptant les 
				types de champs suivants :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">n</code> : Num&eacute;ro de l'&eacute;tat (entier) 
					</li><li>
						<code class="code">N</code> : Nom de l'&eacute;tat (cha&icirc;nes de caract&egrave;res) 
					</li><li>
						<code class="code">M</code> : Valeur moyenne pour cet &eacute;tat et ce type de statistique (r&eacute;el) 
					</li><li>
						<code class="code">S</code> : Ecart-type pour cet &eacute;tat et ce type de statistique (r&eacute;el) 
					</li><li>
						<code class="code">I</code> : Intervalle de confiance &agrave; 90 % pour cet &eacute;tat et ce type 
						de statistique (r&eacute;el) 
					</li><li>
						<code class="code">P</code> (uniquement pour le type de statistique 1): Pourcentage de 
						temps total pass&eacute; dans cet &eacute;tat statistique (r&eacute;el).
					</li><li>
						<code class="code">C</code> (uniquement pour le type de statistique 6): Nombre de donn&eacute;es 
						non-censur&eacute;es (entier).
					</li></ul></div>
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur d'&eacute;tats statistiques est vide.
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Xt"></a>Directive pour les &eacute;tats statistiques (Nouvelle version)</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Afficher les r&eacute;sultats des &eacute;tats statistiques 
				en prenant en compte la dimension temporelle. 
			</p><p> 
				Par rapport &agrave; l'ancienne version, nous passons d'un syst&egrave;me &agrave; deux dimensions 
				(donn&eacute;es [Etat statistiques] x valeurs [moyenne, &eacute;cart type, intervalle de confiance, ...]) 
				&agrave; un syst&egrave;me &agrave; trois dimensions (donn&eacute;es x valeurs x temps). 
				Le format d'affichage restant en deux dimensions, il y a 6 combinaisons possibles d'affichage. 
			</p><p> 
				Le format d'affichage g&egrave;re 3 sous-ensembles : <code class="literal">Times</code>, 
				<code class="literal">Select</code> et <code class="literal">Values</code> repr&eacute;sentant les temps de calcul, 
				les variables et les grandeurs calcul&eacute;s.
			</p><p> 
				Le premier sous-ensemble saisi correspond la boucle externe d'affichage, le deux autres 
				sous-ensemble sont utilis&eacute;s pour afficher un tableau &agrave; 2 dimensions de mani&egrave;re classique.
			</p><p> 
				Le format d'affichage de chaque sous-ensemble sera directement pr&eacute;cis&eacute; dans la commande 
				ainsi que le libell&eacute; associ&eacute; &agrave; la grandeur consid&eacute;r&eacute;e.
			</p><p> 
				Le format a donc avoir la syntaxe suivante :
				<pre class="programlisting">	Xt &lt;type&gt;
		Times [&lt;times&gt;] "&lt;format&gt;" ["&lt;title&gt;"]
		Select &lt;select&gt; "&lt;format&gt;" ["&lt;title&gt;"]
		Values "&lt;format&gt;" ["&lt;title&gt;"] [, "&lt;format&gt;" ["&lt;title&gt;"]]*
		"&lt;string&gt;"</pre>
			</p><p> 
				o&ugrave; <code class="literal">&lt;type&gt;</code> correspond &agrave; un type de statistique sp&eacute;cifique 
				(1,2,3,4,5 ou 6), <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> d'&eacute;tats statistiques, 
				<code class="literal">&lt;times&gt;</code> est une liste de temps 
				(Cf. option times [Chapitre 2.2.1] pour la syntaxe de <code class="literal">&lt;times&gt;</code>), 
				<code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher et 
				<code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de caract&egrave;res acceptant les types 
				de champs suivants :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">T</code> : Temps consid&eacute;r&eacute; 
					</li><li>
						<code class="code">n</code> : Num&eacute;ro de l'&eacute;tat (entier) 
					</li><li>
						<code class="code">N</code> : Nom de l'&eacute;tat (cha&icirc;nes de caract&egrave;res) 
					</li><li>
						<code class="code">M</code> : Valeur moyenne pour cet &eacute;tat et ce type de statistique (r&eacute;el) 
					</li><li>
						<code class="code">S</code> : Ecart-type pour cet &eacute;tat et ce type de statistique (r&eacute;el) 
					</li><li>
						<code class="code">I</code> : Intervalle de confiance &agrave; 90 % pour cet &eacute;tat et ce type de 
						statistique (r&eacute;el) 
					</li><li>
						<code class="code">P</code> (uniquement pour le type de statistique 1): Pourcentage de 
						temps total pass&eacute; dans cet &eacute;tat statistique (r&eacute;el).
					</li><li>
						<code class="code">C</code> (uniquement pour le type de statistique 6): Nombre de donn&eacute;es 
						non-censur&eacute;es (entier).
					</li></ul></div>
			</p><p> 
				L'ordre entre Times, Select et Values pr&eacute;cise le pr&eacute;fixe, les abscisses et 
				les ordonn&eacute;es.
			</p><p> 
				Si le pr&eacute;fixe est unique, le message (<code class="literal">&lt;title&gt;</code>) est affich&eacute; 
				en pr&eacute;ambule. Dans le cas contraire, il est affich&eacute; directement dans le tableau.
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur d'&eacute;tats statistiques est vide. 
			</p><p> 
				Les exemples suivant permettent de mieux comprendre ce format d'affichage.
				(Calcul pour le r&eacute;seau nomm&eacute; <code class="code">samples</code> sur les &eacute;tats statistiques E1, E2 et E3 au temps 10 et 20).
				<div class="itemizedlist"><ul type="disc"><li><p>
		<pre class="screen"><strong class="userinput"><code>display result samples {Xt 1 Times at 10 "%._$t" "Times" 
		     Select * "% 5$N" "State" 
		     Values "%._$M" "Temps Moyen", "%._$S" "Ecart-Type" 
		     ";"};</code></strong>
		Times;10
		State;Temps Moyen;Ecart-Type
		   E1;2.12345;1.98765
		   E2;4.12345;2.98765
		   E3;6.12345;3.98765</pre>
					</p></li><li><p>
		<pre class="screen"><strong class="userinput"><code>display result samples {Xt 1 Select * "% 5$N" "State" 
		     Times "%._$t" "Times" 
		     Values "%._$M" "Temps Moyen", "%._$S" "Ecart-Type" 
		     ";"};</code></strong>
		State;Times;Temps Moyen;Ecart-Type
		   E1;10;2.12345;1.98765
		   E1;20;4.12345;2.98765
		   E2;10;4.12345;2.98765
		   E2;20;8.12345;4.98765
		   E3;10;6.12345;3.98765
		   E3;20;12.1234;6.98765</pre>
					</p></li><li><p>
		<pre class="screen"><strong class="userinput"><code>display result samples {Xt 1 Values "%._$M" "Temps Moyen" 
		     Select * "% 5$N" "State" 
		     Times "%._$t" "Times"
		     ";"};</code></strong>
		Temps Moyen
		State;10;20
		   E1;2.12345;4.12345
		   E2;4.12345;8.12345
		   E3;6.12345;12.1234</pre> 
					</p></li><li><p>
		<pre class="screen"><strong class="userinput"><code>display result samples {Xt 1 Values "%._$M" "Temps Moyen" 
		     Times "%._$t" "Times" 
		     Select * "% 5$N" "State"
		     ";"};</code></strong>
		Temps Moyen
		Times;E1;E2;E3
		10;2.12345;4.12345;6.12345
		20;4.12345;8.12345;12.1234</pre>
					</p></li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Net"></a>Directive pour le r&eacute;seau</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Afficher la description du r&eacute;seau.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : <span><strong class="command">Net</strong></span> 
			</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avertissement</h3><p>
				Il n'y a pas d'affichage XML pour cette directive.
			 </p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Str"></a>Directive d'affichage d'une cha&icirc;ne de caract&egrave;res</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Afficher une cha&icirc;ne de caract&egrave;res.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : <span><strong class="command">Str "&lt;str&gt;"</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;str&gt;</code> est une cha&icirc;ne de caract&egrave;res.
			</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avertissement</h3><p>
				Il n'y a pas d'affichage XML pour cette directive. Il faut donc &eacute;crire
				la cha&icirc;ne de caract&egrave;res au format XML.
			</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.HstSt"></a>Directive pour les histogrammes des &eacute;tats statistiques</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque &eacute;tat statistique (s&eacute;lectionn&eacute;) 
				ayant le drapeau <code class="code">HST</code> actif, afficher les r&eacute;sultats interm&eacute;diaires 
				(r&eacute;sultat &agrave; chaque fin d'histoire).
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">HstSt &lt;type&gt; &lt;action&gt; &lt;select&gt; [XML] ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;type&gt;</code> correspond &agrave; un type de statistique sp&eacute;cifique 
				(1,2,3,4,5 ou 6), <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> d'&eacute;tats statistiques, 
				<code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher
				et <code class="literal">&lt;action&gt;</code> permet de pr&eacute;ciser le traitement &agrave; r&eacute;aliser sur 
				l'histogramme. 
				Le drapeau <code class="literal">XML</code> permet de sp&eacute;cifier un affichage au format XML.
			</p><p> 
				Il existe quatre traitements : 
				<div class="itemizedlist"><a name="Moca.IMoca.Cmd.Format.Hst.Action"></a><ul type="disc"><li><p>
						<code class="code">Display</code> : Affichage des donn&eacute;es en brute 
						<pre class="screen">			HISTOGRAMME DE L'ETAT No 'St001' No 2
			3,37977E+00
			3,45643E+00
			4,91471E+00
			5,69483E+00
			6,60019E+00
			7,04654E+00
			8,35086E+00
			8,72988E+00
			9,78460E+00
			9,88095E+00
			1,03942E+01
			1,09530E+01
			1,10085E+01
			...			</pre>
					</p></li><li><p>
						<code class="code">EqProba [&lt;nbrclass&gt;]</code> : Affichage de classes &eacute;quiprobables 
						(&eacute;quivalent &agrave; l'ancien utilitaire classes de la distribution moca10XY 
						permettant de r&eacute;utiliser un histogramme pour la loi empirique) 
						<pre class="screen">			/* Classes generation for state 'St001'        
			    Number of classes : 10 
			    Size of histogram : 1000     
			 */             
			    3,379767E+00    ,
			    5,058298E+01    ,
			    8,994500E+01    ,
			    1,344299E+02    ,
			    1,766010E+02    ,
			    2,245854E+02    ,
			    2,710736E+02    ,
			    3,221753E+02    ,
			    3,664302E+02    ,
			    4,151745E+02    ,
			    4,989649E+02    	</pre>
					</p></li><li><p>
						<code class="code">FixStep [&lt;nbrclass&gt;]</code> : Affichage d'histogramme de 
						taille fixe, la taille d'un intervalle est d&eacute;termin&eacute; en fonction de la 
						valeur maximum et minimum de l'histogramme, ainsi que du nombre de 
						classe demand&eacute; ((max-min)/nbrclass) 
						<pre class="screen">			/* Histogram generation for state 'St001'
			    Number of classes : 10     
			    Size of histogram : 1000
			 */                                                    
			    --                         &lt;3,3797666393220425E+000 0
			    &gt;=3,3797666393220425E+000  &lt;5,2938283545430750E+001 108
			    &gt;=5,2938283545430750E+001  &lt;1,0249680045153946E+002 112
			    &gt;=1,0249680045153946E+002  &lt;1,5205531735764816E+002 125
			    &gt;=1,5205531735764816E+002  &lt;2,0161383426375687E+002 116
			    &gt;=2,0161383426375687E+002  &lt;2,5117235116986558E+002 92
			    &gt;=2,5117235116986558E+002  &lt;3,0073086807597429E+002 106
			    &gt;=3,0073086807597429E+002  &lt;3,5028938498208299E+002 102
			    &gt;=3,5028938498208299E+002  &lt;3,9984790188819170E+002 114
			    &gt;=3,9984790188819170E+002  &lt;4,4940641879430041E+002 73
			    &gt;=4,4940641879430041E+002  &lt;=4,9896493570040911E+002    52
			    &gt;4,9896493570040911E+002   --                      0    	</pre>
					</p></li><li><p>
						<code class="code">DefineBorne ['['] &lt;list-of-borne&gt;</code> : Affichage 
						d'histogramme dont les intervalles sont d&eacute;finis par l'utilisateur ;
						<code class="literal">&lt;list-of-borne&gt;</code> est une liste de r&eacute;el
						s&eacute;par&eacute; par des virgules qui permet de sp&eacute;cifier les bornes des
						intervalles. Les bornes -<span class="symbol">&infin;</span> et 
						+<span class="symbol">&infin;</span> sont toujours ajout&eacute;s.
						Le caract&egrave;re optionnel <code class="literal">[</code> permet de changer 
						les r&egrave;gles d'inclusion des bornes des intervalles.
						<pre class="screen">			<strong class="userinput"><code>display result pnet {HstSt 3 
				DefineBorne [ 1E-4,1E-3,1E-2,1E-1 Stat1};</code></strong>
				
			/* Define borne Histogram for state 'Stat1'
				Size of histogram : 15000
				Minimum of histogram : 3.0000000000000001E-005
				Maximum of histogram : 2.0000000000000001E-001
			 */
				--	&lt;1.000000E-004	739	4.9267%
				&gt;=1.000000E-004	&lt;1.000000E-003	2229	 14.86%
				&gt;=1.000000E-003	&lt;1.000000E-002	7508	50.053%
				&gt;=1.000000E-002	&lt;1.000000E-001	2971	19.807%
				&gt;=1.000000E-001	--	1553	10.353%</pre>
					</p></li></ul></div>
			</p><p>
				Si le drapeau <code class="literal">XML</code> a &eacute;t&eacute; sp&eacute;cifi&eacute;, la sortie est diff&eacute;rente
				et d&eacute;pend du traitement effectu&eacute; : 
				<div class="itemizedlist"><ul type="disc"><li><p>
						Les donn&eacute;es de l'histogramme sont affich&eacute;s de la mani&egrave;re suivante : 
						<pre class="screen">  &lt;histogram-data type='St' name='St001' id='2'&gt;
    &lt;data history='1' value='3.116854E+002'/&gt;
    &lt;data history='2' value='5.473069E+002'/&gt;
    ...
  &lt;/histogram-data&gt;</pre>
					</p></li><li><p>
						Les histogrammes de taille fixe, de classes &eacute;quiprobable ou d'intervalles
						d&eacute;finies sont affich&eacute;s de la m&ecirc;me mani&egrave;re (l'attribut <code class="code">typehst</code>
						peut prendre les valeurs <code class="code">fixstep</code>, <code class="code">eqproba</code> ou
						<code class="code">defineborne</code> afin de rappeler le type d'histogramme affich&eacute;) :  
						<pre class="screen">  &lt;histogram typehst='defineborne' type='St1' name='State' id='1' size='627'
      minimum='1.53406350E+000'
      maximum='5.99560058E+002'&gt;
    &lt;interval number='13' ratio='2.0734%'
        beg='-Infinity' include-beg='false'
        end='1.00000000E+001' include-end='true'/&gt;
    &lt;interval number='17' ratio='2.7113%'
        beg='1.00000000E+001' include-beg='false'
        end='2.00000000E+001' include-end='true'/&gt;
    &lt;interval number='11' ratio='1.7544%'
        beg='2.00000000E+001' include-beg='false'
        end='3.00000000E+001' include-end='true'/&gt;
    &lt;interval number='8' ratio='1.2759%'
        beg='3.00000000E+001' include-beg='false'
        end='4.00000000E+001' include-end='true'/&gt;
    &lt;interval number='11' ratio='1.7544%'
        beg='4.00000000E+001' include-beg='false'
        end='5.00000000E+001' include-end='true'/&gt;
    &lt;interval number='567' ratio='90.431%'
        beg='5.00000000E+001' include-beg='false'
        end='+Infinity' include-end='false'/&gt;
  &lt;/histogram&gt; </pre>
					</p></li></ul></div>
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur d'&eacute;tats statistiques est vide. 
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.HstTr"></a>Directive pour les histogrammes des transitions</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque transition (s&eacute;lectionn&eacute;e) ayant 
				le drapeau <code class="code">HST</code> actif, afficher la liste des temps o&ugrave; cette transition 
				a &eacute;t&eacute; tir&eacute;e (histoire par histoire).
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">HstTr &lt;action&gt; &lt;select&gt; [XML] ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;action&gt;</code> permet de pr&eacute;ciser le traitement &agrave; 
				r&eacute;aliser sur <a href="#Moca.IMoca.Cmd.Format.Hst.Action" title="???TITLE???">l'histogramme</a> 
				<code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> de transitions, 
				et <code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher.
				Le drapeau <code class="literal">XML</code> permet de sp&eacute;cifier un affichage au format XML.
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur de transitions est vide.
				Dans le cas contraire, l'affichage est tr&egrave;s proche de l'histogramme des
				&eacute;tats statistiques.
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Chro"></a>Directive pour les chronogrammes des &eacute;tats statistiques</h5></div></div></div><p> 
				<span class="emphasis"><em>Objectif</em></span> : Pour chaque &eacute;tat statistique (s&eacute;lectionn&eacute;) ayant le 
				drapeau <code class="code">CHRO</code> actif, afficher le chronogramme moyen.
			</p><p> 
				<span class="emphasis"><em>Syntaxe</em></span> : 
				<span><strong class="command">Chro &lt;select&gt; [XML] ["&lt;title&gt;"]</strong></span> 
			</p><p> 
				o&ugrave; <code class="literal">&lt;select&gt;</code> est un 
				<a href="#Moca.IMoca.Cmd.Format.Select" title="S&eacute;lecteur de donn&eacute;es">s&eacute;lecteur</a> d'&eacute;tats statistiques 
				et <code class="literal">&lt;title&gt;</code> est un titre &agrave; afficher.
				Le drapeau <code class="literal">XML</code> permet de sp&eacute;cifier un affichage au format XML.
			</p><p> 
				Cette directive n'affiche rien si le s&eacute;lecteur d'&eacute;tats statistiques est vide. 
			</p><p> 
				Dans le cas contraire, il affiche le chronogramme  
				<div class="itemizedlist"><ul type="disc"><li><p>
						soit sous une forme tabul&eacute; (si le drapeau XML n'a pas &eacute;t&eacute; pr&eacute;cis&eacute;) :
						<pre class="screen">			CHRONOGRAMME DE L'ETAT No 'Stck' No 1                       
		    TEMPS                      VALEUR
		    0.0000000000000000E+000    0.0000000000000000E+000
		    1.0000000000000000E+001    2.1699999999999990E+000
		    2.0000000000000000E+001    4.0300000000000002E+000
		    3.0000000000000000E+001    5.9199999999999999E+000
		    4.0000000000000000E+001    1.5470000000000004E+001
		    5.0000000000000000E+001    1.7099999999999994E+001
		    6.0000000000000000E+001    1.8630000000000010E+001
		    7.0000000000000000E+001    2.0239999999999998E+001
		    8.0000000000000000E+001    2.1779999999999987E+001
		    9.0000000000000000E+001    2.3270000000000003E+001
		    1.0000000000000000E+002    3.2570000000000000E+001
		    1.1000000000000000E+002    3.3799999999999997E+001
		    ...</pre>
					</p></li><li><p>
						soit dans un format XML
						<pre class="screen">  &lt;chronogram name='St001' id='1'&gt;
    &lt;point time='0.000000E+000' value='1.900000E-002' /&gt;
    &lt;point time='1.000000E+001' value='4.100000E-002' /&gt;
    &lt;point time='2.000000E+001' value='6.700000E-002' /&gt;
    &lt;point time='3.000000E+001' value='7.500000E-002' /&gt;
    &lt;point time='4.000000E+001' value='1.040000E-001' /&gt;
    &lt;point time='5.000000E+001' value='1.290000E-001' /&gt;
    ...
    &lt;point time='1.000000E+003' value='3.682000E+000' /&gt;
  &lt;/chronogram&gt; </pre>
					</p></li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.IMoca.Cmd.Format.Select"></a>S&eacute;lecteur de donn&eacute;es</h5></div></div></div><p> 
				La plupart des directives d'affichage prennent un ensemble d'objets 
				(transitions, places ou &eacute;tats statistiques) en param&egrave;tre. 
				Cet ensemble d'objets est construit &agrave; l'aide d'un s&eacute;lecteur d&eacute;fini par 
				des primitives de s&eacute;lection. 
			</p><p> 
				Plusieurs primitives sont disponibles pour construire ces s&eacute;lecteurs : 
				<div class="itemizedlist"><ul type="disc" compact><li>
						<code class="code">&lt;name&gt;   </code> : s&eacute;lectionne l'objet de nom donn&eacute;. 
					</li><li>
						<code class="code">{}       </code> : l'ensemble vide. 
					</li><li>
						<code class="code">*        </code> : l'ensemble de r&eacute;f&eacute;rence. 
					</li><li>
						<code class="code">{ S }    </code> : l'ensemble de S. 
					</li><li>
						<code class="code">S1,...,Sk</code> : l'union des ensembles S1,...,Sk. 
					</li><li>
						<code class="code">S1^...^Sk</code> : l'intersection des ensembles S1,...,Sk. 
					</li><li>
						<code class="code">S1/.../Sk</code> : la diff&eacute;rence des ensembles S1,...,Sk. 
						((...(S1/S2)/...)/Sk). 
					</li></ul></div>
			</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Format.Use"></a>Utilisation d'un format d'affichage</h4></div></div></div><p> 
			Un format d'affichage est requis &agrave; chaque fois que l'on souhaite afficher un r&eacute;sultat, 
			c'est-&agrave;-dire lors de l'utilisation de la commande <span><strong class="command">display result ...</strong></span>, 
			mais &eacute;galement lorsque l'on souhaite afficher les r&eacute;sultats interm&eacute;diaires d'une 
			simulation double-d&eacute;tente ou d'une simulation par lots.
		</p><p>
			D'une mani&egrave;re pratique, le format d'affichage n'est pas un champ obligatoire. 
			Dans ce cas, le format par d&eacute;faut est utilis&eacute; (<code class="literal">default</code>). 
			Pour utiliser un format d'affichage, il suffit de sp&eacute;cifier son nom dans la commande d'affichage. 
		</p><pre class="screen"> <strong class="userinput"><code>display result net=&gt;res Moca10Fr1 ;</code></strong></pre><p>
			En lieu et place du nom du format, il est &eacute;galement possible d'utiliser directement 
			les directives de format d'affichage en les entourant d'accolades. 
			Cette fonctionnalit&eacute; est g&eacute;n&eacute;ralement employ&eacute;e pour afficher des informations courtes 
			sur la banque de r&eacute;sultats. 
		</p><p>
			Par exemple, pour afficher le nombre d'histoires qui ont &eacute;t&eacute; simul&eacute;es et m&eacute;moris&eacute;es dans 
			une banque de r&eacute;sultats, il suffit d'employer la commande 
			<span><strong class="command">display result net=&gt;res {Info "%$S"};</strong></span>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Format.Display"></a>Affichage d'un format {<span><strong class="command">display format ...</strong></span>}</h4></div></div></div><p> 
			Pour afficher la d&eacute;finition d'un format (ces directives d'affichage), il convient 
			d'utiliser la commande <span><strong class="command">display format &lt;id-format&gt;;</strong></span>
			o&ugrave; <code class="literal">&lt;id-format&gt;</code> est le nom du format &agrave; afficher.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Format.Clear"></a>Suppression d'un format d'affichage {<span><strong class="command">clear format ...</strong></span>}</h4></div></div></div><p> 
			Pour supprimer d'un format d'affichage, il faut d'utiliser la commande 
			<span><strong class="command">clear format &lt;id-format&gt;;</strong></span>
			o&ugrave; <code class="literal">&lt;id-format&gt;</code> est le nom du format &agrave; afficher.
		</p><p>
			Pour supprimer tous les formats d'affichage, il faut lancer la commande 
			<span><strong class="command">clear format all;</strong></span>.
		</p><p>
			Le format par d&eacute;faut ne peut jamais &ecirc;tre supprim&eacute;. En revanche, 
			lorsque l'on utilise cette commande sur celui-ci, il est reconstruit. 
			C'est utile lorsque l'on souhaite changer de langue.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.IMoca.Cmd.Util"></a>Commandes Utilitaires</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Timer"></a>Gestionnaire de chronom&egrave;tres {<span><strong class="command">... timer ...</strong></span>}</h4></div></div></div><p> 
			Moca-RP<sup>C</sup> permet de g&eacute;rer des chronom&egrave;tres (ou timers) afin de mesurer les temps 
			de chargement, de simulation et/ou d'affichage. Dans la mesure du possible 
			(suivant les syst&egrave;mes d'exploitation), les donn&eacute;es suivantes sont recueillies : 
			temps r&eacute;el, temps utilisateur, temps associ&eacute; au noyau (du syst&egrave;me d'exploitation) 
			comme le temps pour la gestion de la m&eacute;moire "swap".
		</p><p> 
			Les chronom&egrave;tres sont nomm&eacute;s et d&eacute;finis &agrave; l'aide de la commande 
			<span><strong class="command">set timer &lt;id-timer&gt;;</strong></span>
			o&ugrave; <code class="literal">&lt;id-timer&gt;</code> est un identificateur d'un chronom&egrave;tre 
			qui n'existe pas actuellement au sein de Moca-RP<sup>C</sup>. 
		</p><p> 
			Les commandes <span><strong class="command">timer &lt;id-timer&gt; start;</strong></span> et 
			<span><strong class="command">timer &lt;id-timer&gt; stop;</strong></span> permettent respectivement 
			de d&eacute;clencher et d'arr&ecirc;ter un chronom&egrave;tre. 
		</p><p> 
			Il est alors possible d'afficher la valeur courante du chronom&egrave;tre &agrave; l'aide 
			de la commande <span><strong class="command">display timer ...</strong></span>. Cette derni&egrave;re prend 
			en param&egrave;tre un format d'affichage d&eacute;fini &agrave; l'aide d'une cha&icirc;ne de caract&egrave;res. 
			Le caract&egrave;re balise &lsquo;%' sp&eacute;cifie que le prochain caract&egrave;re sera remplac&eacute; en 
			fonction de son type et du chronom&egrave;tre consid&eacute;r&eacute;. 
		</p><p> 
			Les m&eacute;ta-caract&egrave;res suivants sont accept&eacute;s :
			<div class="itemizedlist"><ul type="disc" compact><li>
					<code class="code">%R</code> : affiche la dur&eacute;e r&eacute;elle
				</li><li>
					<code class="code">%U</code> : affiche la dur&eacute;e sp&eacute;cifique &agrave; la simulation 
					(temps utilisateur)
				</li><li>
					<code class="code">%K</code> : affiche la dur&eacute;e associ&eacute;e au noyau
				</li><li>
					<code class="code">%T</code> : affiche l'heure actuelle (uniquement sous Windows)
				</li><li>
					<code class="code">%D</code> : affiche la date actuelle (uniquement sous Windows)
				</li></ul></div>
		</p><p> 
			Les dur&eacute;es sont affich&eacute;es en seconde avec une pr&eacute;cision en millisecondes. 
			La syntaxe pour la commande d'affichage est la suivante 
			<span><strong class="command">display timer &lt;id-timer&gt; &lt;format&gt;;</strong></span>
			o&ugrave; <code class="literal">&lt;id-timer&gt;</code> est un identificateur d'un chronom&egrave;tre 
			pr&eacute;alablement d&eacute;fini et <code class="literal">&lt;format&gt;</code> est une cha&icirc;ne de 
			caract&egrave;res entour&eacute;e de guillemets utilisant les m&eacute;ta-caract&egrave;res pr&eacute;cis&eacute;s ci-dessus. 
			(Par exemple : <span><strong class="command">display timer TS "Temps de simulation : %U sec";</strong></span>) 
		</p><p> 
			Pour finir, la commande <span><strong class="command">clear timer &lt;id-timer&gt;;</strong></span> permet 
			de supprimer un chronom&egrave;tre en m&eacute;moire.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Trace"></a>Trace des commandes et des r&eacute;sultats {<span><strong class="command">set trace ...</strong></span>}</h4></div></div></div><p> 
			Toutes les commandes saisies par l'utilisateur (directement ou indirectement 
			en lisant un fichier de commande) et toutes les sorties (r&eacute;sultats d'une commande 
			ou message d'erreur) peuvent &ecirc;tre automatiquement redirig&eacute;es vers un fichier de trace. 
		</p><p> 
			Pour activer cette fonctionnalit&eacute;, il faut utiliser la commande 
			<span><strong class="command">set trace "&lt;file&gt;";</strong></span> o&ugrave; <code class="literal">&lt;file&gt;</code> est 
			le nom du fichier de trace entour&eacute; par des guillemets. 
			Si ce fichier existait pr&eacute;alablement, il est ouvert en ajout (il n'est donc pas d&eacute;truit).
		</p><p> 
			Pour d&eacute;sactiver la trace, il suffit de lancer la commande 
			<span><strong class="command">set trace;</strong></span> (sans nom de fichier).
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.Options"></a>Options de l'interpr&eacute;teur de commandes {<span><strong class="command">display options |set ...</strong></span>}</h4></div></div></div><p> 
			L'interpr&eacute;teur de commandes utilise un certain nombre d'options qui permet de pr&eacute;ciser 
			son fonctionnement. Citons deux exemples : la langue utilis&eacute;e pour l'affichage 
			des messages et la pr&eacute;cision par d&eacute;faut utilis&eacute;e lors de l'affichage d'un nombre r&eacute;el.
		</p><p> 
			Toutes les options de l'interpr&eacute;teur peuvent &ecirc;tre affich&eacute;es &agrave; l'aide de la 
			commande <span><strong class="command">display options;</strong></span>. Les diff&eacute;rentes options et leurs valeurs 
			par d&eacute;faut sont les suivantes.
			<pre class="screen">		01       Moca &gt; <strong class="userinput"><code>display options;</code></strong>
		02       set language french ;
		03       set precision 6 ;
		04       /* no trace active */
		05       set prompt "
		06       Moca &gt; " ;
		07       set seed     12345681.00 ;
		08       set delay 30 ;
		09       set max-loop 1000 ;
		10       set max-histo 1000 ;
		11       set max-chrono 1000 ;
		12       set adj-chrono 1.0000000000000000E+003 ;
		13       set simul timer "Temps de simulation : %U (%R)
		14       " ;</pre>
		</p><p> 
			Notons que ce format d'affichage peut &ecirc;tre utilis&eacute; directement comme fichier de commande. 
			Il est possible de rediriger cet affichage dans un fichier (par exemple 
			<span><strong class="command">display options &gt; "Moca.ini";</strong></span>), de modifier ce fichier &agrave; notre 
			convenance et de le r&eacute;utiliser imm&eacute;diatement ou dans une prochaine session &agrave; l'aide 
			de la commande <span><strong class="command">load "Moca.ini";</strong></span>.
		</p><p>
			Les diff&eacute;rentes options sont :
			<div class="orderedlist"><ol type="1"><li>
			        La langue utilis&eacute;e pour l'affichage des messages : Seules deux langues sont 
			        disponibles au sein de Moca-RP<sup>C</sup> : le fran&ccedil;ais (french) et l'anglais (english). 
			        Il est relativement ais&eacute; d'ajouter de nouvelles langues au moteur de calcul 
			        (m&ecirc;me si cela entra&icirc;ne la recompilation et la g&eacute;n&eacute;ration d'une nouvelle 
			        version de Moca-RP<sup>C</sup>). Actuellement, seuls les messages en fran&ccedil;ais sont &agrave; jour. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set language {french | english};</strong></span>.
				</li><li>
			        La pr&eacute;cision par d&eacute;faut utilis&eacute;e lors de l'affichage d'un nombre r&eacute;el : 
			        Cette pr&eacute;cision peut &ecirc;tre utilis&eacute;e dans les formats d'affichage des r&eacute;sultats 
			        en mettant pour le champ de pr&eacute;cision le caract&egrave;re '_'. 
			        Cette technique permet de modifier l'affichage des r&eacute;sultats dynamiquement sans 
			        cr&eacute;er un nouveau format d'affichage. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set precision &lt;int&gt;;</strong></span> 
			        o&ugrave; <code class="literal">&lt;int&gt;</code> est un entier.
				</li><li>
			        La trace, c'est-&agrave;-dire la redirection des commandes et des r&eacute;ponses de l'interpr&eacute;teur :
			        Pour plus d'explication, voir <a href="#Moca.IMoca.Cmd.Trace" title="Trace des commandes et des r&eacute;sultats {set trace ...}">la section intitul&eacute;e &laquo;&nbsp;Trace des commandes et des r&eacute;sultats {<span><strong class="command">set trace ...</strong></span>}&nbsp;&raquo;</a>. 
			        Lorsqu'aucune trace n'est active, la commande <span><strong class="command">display options;</strong></span> 
			        affiche <code class="literal">/* no trace active */</code>.
				</li><li>
			        Le prompt, c'est-&agrave;-dire le texte qui invite l'utilisateur &agrave; saisir une nouvelle 
			        commande : Chacun peut personnaliser son prompt. Il existe quelques 
			        meta-caract&egrave;res permettant d'ajouter automatiquement la date courante (%D), 
			        l'heure au moment de l'affichage (%T) ou le caract&egrave;re de pourcentage (%%). 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set prompt &lt;prompt&gt;;</strong></span> o&ugrave; <code class="literal">&lt;prompt&gt;</code>
			        est une cha&icirc;ne de caract&egrave;res entour&eacute;e de guillemets 
			        (les retours &agrave; la ligne sont accept&eacute;s).
				</li><li>
			        La graine par d&eacute;faut du g&eacute;n&eacute;rateur de nombres al&eacute;atoires : Cette donn&eacute;e est utilis&eacute;e 
			        lors de nouvelles simulations, lorsque la banque de r&eacute;sultats vient d'&ecirc;tre cr&eacute;&eacute;e. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set seed &lt;seed&gt;;</strong></span> o&ugrave; <code class="literal">&lt;seed&gt;</code> 
			        est un nombre r&eacute;el sup&eacute;rieur &agrave; z&eacute;ro. 
			        Il est conseill&eacute; d'utiliser un nombre r&eacute;el assez grand et impair. 
				</li><li>
			        Le temps de simulation maximum autoris&eacute; pour effectuer une simulation : 
			        Au-del&agrave; de ce temps, la commande termine l'histoire courante et arr&ecirc;te la simulation. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set delay &lt;delay&gt;;</strong></span> o&ugrave; <code class="literal">&lt;delay&gt;</code> 
			        est un nombre entier sup&eacute;rieur &agrave; z&eacute;ro repr&eacute;sentant le temps de simulation 
			        maximum en seconde.
				</li><li>
			        Le nombre de transitions qui peuvent &ecirc;tre tir&eacute;es successivement sans que le temps 
			        de l'histoire soit incr&eacute;ment&eacute;. Au-del&agrave; de ce nombre la simulation est brutalement 
			        interrompue, la boucle et l'&eacute;ch&eacute;ancier sont affich&eacute;s. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set max-loop &lt;int&gt;;</strong></span> o&ugrave; <code class="literal">&lt;int&gt;</code> 
			        est un nombre entier sup&eacute;rieur &agrave; z&eacute;ro.
				</li><li>
			        Le nombre d'histogrammes possibles pour chaque &eacute;tat statistique ou chaque transition. 
			        Ce nombre limite le nombre de valeur m&eacute;moris&eacute;e pour chaque histogramme de la simulation. 
			        Pour modifier cette option, il faut utiliser la commande 
			        <span><strong class="command">set max-histo &lt;int&gt;;</strong></span> o&ugrave; <code class="literal">&lt;int&gt;</code> 
			        est un nombre entier sup&eacute;rieur &agrave; z&eacute;ro ou &eacute;gal &agrave; '-1'. 
			        Dans le dernier cas, il n'y a pas de limite en dehors de la m&eacute;moire de l'ordinateur. 
			        Pour les histogrammes des transitions, plusieurs valeurs peuvent &ecirc;tre m&eacute;moris&eacute;es 
			        pour une seule histoire. La valeur '&ndash;1' est utilis&eacute;e afin de pr&eacute;ciser que l'on traite 
			        une nouvelle histoire. Dans ce cas, le nombre maximum d'histogrammes pour les 
			        transitions est sup&eacute;rieur au nombre de valeurs affich&eacute;es.
				</li><li>
			        Les options de chronogramme permettent de diriger l'algorithme de composition des 
			        chronogrammes. 
				</li><li>
					L'affichage du temps de simulation : A la fin d'une simulation, Moca-RP<sup>C</sup> 
					affiche le temps qu'il a mis pour effectuer cette simulation. 
					Pour cela, il utilise un chronom&egrave;tre (ou timer). Pour modifier cette option, 
					il faut utiliser la commande <span><strong class="command">set simul timer &lt;display&gt;;</strong></span>
					o&ugrave; <code class="literal">&lt;display&gt;</code> est un format d'affichage de chronom&egrave;tres 
					entour&eacute; de guillemets (Cf. <a href="#Moca.IMoca.Cmd.Timer" title="Gestionnaire de chronom&egrave;tres {... timer ...}">la section intitul&eacute;e &laquo;&nbsp;Gestionnaire de chronom&egrave;tres {<span><strong class="command">... timer ...</strong></span>}&nbsp;&raquo;</a>).
				</li></ol></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.System"></a>Utilisation des commandes syst&egrave;mes {<span><strong class="command">system ...</strong></span>}</h4></div></div></div><p> 
			Il est possible d'utiliser des commandes syst&egrave;mes directement au sein de Moca-RP<sup>C</sup>. 
			L'int&eacute;r&ecirc;t de cette commande est multiple. Elle permet de conna&icirc;tre facilement le 
			r&eacute;pertoire de travail (<span><strong class="command">system "pwd";</strong></span> ou <span><strong class="command">system "cd";</strong></span>), 
			d'afficher un fichier de donn&eacute;es ou de r&eacute;sultats (<span><strong class="command">system "type file.res";</strong></span>), 
			de modifier un fichier de donn&eacute;es (<span><strong class="command">system "notepad file.mok";</strong></span>) ou 
			un fichier de r&eacute;sultats (<span><strong class="command">system "excel file.res";</strong></span>) ou encore de 
			comparer deux fichiers de r&eacute;sultats (<span><strong class="command">system "windiff file1.res file2.res";</strong></span>).
		</p><p> 
			Comme les nombreux exemples le montrent la syntaxe de cette commande est la suivante 
			<span><strong class="command">system "&lt;command&gt;";</strong></span> o&ugrave; <code class="literal">&lt;command&gt;</code> est 
			la commande syst&egrave;me &agrave; ex&eacute;cuter. Si vos commandes utilisent des guillemets, 
			il convient de les faire pr&eacute;c&eacute;der par le caract&egrave;re anti-slach \. 
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.IMoca.Cmd.String"></a>Affichage d'une cha&icirc;ne de caract&egrave;res {<span><strong class="command">display "&lt;string&gt;" ...</strong></span>}</h4></div></div></div><p> 
			La commande <span><strong class="command">display "cha&icirc;ne de caract&egrave;res";</strong></span> permet d'afficher 
			<code class="literal">cha&icirc;ne de caract&egrave;res</code> sur la sortie usuelle. 
		</p><p> 
			Cette commande permet lors du chargement d'un fichier de commande l'affichage 
			d'information permettant de pr&eacute;ciser la teneur des commandes jou&eacute;es. 
			A l'aide de la redirection (Cf. <a href="#Moca.IMoca.Cmd.Redirection" title="Redirection de l'affichage">la section intitul&eacute;e &laquo;&nbsp;Redirection de l'affichage&nbsp;&raquo;</a>), il permet aussi l'insertion de 
			commentaires dans les fichiers de r&eacute;sultat.
		</p></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Moca.Moca12.Law"></a>Les lois dans Moca-RP<sup>C</sup></h2></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Law.Intro"></a>G&eacute;n&eacute;ralit&eacute;s</h3></div></div></div><p> 
			A chaque transition du r&eacute;seau de Petri est attach&eacute;e :
			<div class="itemizedlist"><ul type="disc"><li>
					la loi de distribution du d&eacute;lai de tir de cette transition 
					c'est-&agrave;-dire le d&eacute;lai qui s'&eacute;coule entre l'instant de la validation et 
					l'instant du tir effectif. 
				</li><li>
					La loi de tir de cette transition, c'est-&agrave;-dire la mani&egrave;re dont sera tir&eacute;e 
					la transition 
				</li></ul></div>
		</p><p>
			Cette diff&eacute;renciation entre ces deux lois fait que les lois &agrave; la sollicitation font 
			maintenant partie des lois de tir des transitions. 
		</p><p>
			Les lois sont d&eacute;sormais rep&eacute;r&eacute;es uniquement par leur nom (de six caract&egrave;res au maximum) 
			alors que dans les versions ant&eacute;rieures elles l'&eacute;taient soit par leur nom, 
			soit par leur num&eacute;ro.
		</p><p>
			Les param&egrave;tres des lois sont des expressions quelconques (donc pas forc&eacute;ment constantes). 
			Ces expressions sont &eacute;valu&eacute;es au moment o&ugrave; elles sont utilis&eacute;es, c'est-&agrave;-dire lorsque 
			la transition est valide pour les param&egrave;tres des lois de d&eacute;lai et lorsque la transition 
			est tir&eacute;e pour les param&egrave;tres des lois de tir. Le calcul du d&eacute;lai de tir d'une transition 
			peut donc d&eacute;pendre du moment o&ugrave; elle a &eacute;t&eacute; valide. Cette notion a permis de supprimer 
			toutes les lois N optionnelles des versions pr&eacute;c&eacute;dentes et de simplifier (et de g&eacute;n&eacute;raliser) 
			la loi exponentielle+Wow (attente m&eacute;t&eacute;o).
		</p><p>
			D'autre part, la notion de m&eacute;moire (Cf. <a href="#Moca.Moca12.Transs.Memory" title="Transitions &agrave; m&eacute;moire">la section intitul&eacute;e &laquo;&nbsp;Transitions &agrave; m&eacute;moire&nbsp;&raquo;</a>) est attach&eacute;e aux transitions et 
			non plus aux lois (comme c'&eacute;tait le cas dans les versions 8.9 et pr&eacute;c&eacute;dentes). 
		</p><p>
			Notons que par souci de compatibilit&eacute; ascendante le parseur de fichier 10 offre &agrave; 
			l'utilisateur la possibilit&eacute; d'utiliser les fichiers d'entr&eacute;e des anciennes versions 
			8.x, 9.x et 10.x (Cf. <a href="#Moca.Moca10" title="A.&nbsp;Lecture de fichiers au format Moca10">Annexe&nbsp;A, <i>Lecture de fichiers au format Moca10</i></a>).
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Law.Delay"></a>Lois de d&eacute;lai de Moca-RP<sup>C</sup></h3></div></div></div><p> 
		Les lois de d&eacute;lai actuellement disponibles sont les suivantes :
		<div class="itemizedlist"><ul type="disc" compact><li>
		<code class="code">drc <span class="symbol">&#948;</span></code> est la loi de Dirac de d&eacute;lai <span class="symbol">&#948;</span> ; 
	</li><li>
		<code class="code">erlg m,<span class="symbol">&#946;</span></code> est la loi Erlang de moyenne m et d'ordre <span class="symbol">&#946;</span>; 
	</li><li>
		<code class="code">erlgg <span class="symbol">&#946;</span>, <span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub><span class="symbol">&#946;</span></sub></code> 
		est la loi d'Erlang g&eacute;n&eacute;ralis&eacute;e d'ordre <span class="symbol">&#946;</span> et 
		<span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub>b</sub> 
		sont les param&egrave;tres des exponentielles en s&eacute;rie ; 
	</li><li>
		<code class="code">empir c<sub>1</sub> , ... , c<sub>n</sub></code> 
		est la loi empirique &agrave; n classes c<sub>1</sub> , ... , c<sub>n</sub> ; 
	</li><li>
		<code class="code">exp <span class="symbol">&#955;</span></code> est la loi exponentielle de taux <span class="symbol">&#955;</span> ; 
	</li><li>
		<code class="code">expow <span class="symbol">&#955;</span>, <span class="symbol">&#948;</span></code> est une loi exponentielle de 
		taux <span class="symbol">&#955;</span> &agrave; laquelle on ajoute le d&eacute;lai <span class="symbol">&#948;</span>. ;
	</li><li>
		<code class="code">ipa <span class="symbol">&#964;</span></code> est la loi "instants pr&eacute;vus &agrave; l'avance" ayant 
		pour d&eacute;lai entre deux tirs <span class="symbol">&#964;</span> ; 
	</li><li>
		<code class="code">ifa <span class="symbol">&#948;</span>, t<sub>0</sub></code> est la loi 
		"instants fix&eacute;s &agrave; l'avance" ayant pour d&eacute;lai entre deux tirs le 
		param&egrave;tre <span class="symbol">&#948;</span> et comme premier instant de tir t<sub>0</sub> ; 
	</li><li>
		<code class="code">nlog m, e</code> est la loi log-normale de moyenne m et 
		de facteur d'erreur e ; 
	</li><li>
		<code class="code">spec n, p<sub>1</sub>,...,p<sub>m</sub></code> est 
		la n<sup>i&egrave;me</sup> loi sp&eacute;ciale qui prend 
		p<sub>1</sub>,...,p<sub>m</sub> en param&egrave;tres. 
		Les lois sp&eacute;ciales permettent d'ajouter de nouvelles lois directement en C 
		&agrave; l'aide d'une API de programmation (Cf. <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>)
	</li><li>
		<code class="code">tri a,b,c</code> est la loi triangulaire[3, 4] de minimum a, 
		de maximum b et de mode c. 
	</li><li>
		<code class="code">unif min,max</code> est la loi uniforme de minimum min et 
		de maximum max ; 
	</li><li>
		<code class="code">web m,<span class="symbol">&#946;</span></code> est la loi de Weibull de moyenne m et de 
		param&egrave;tre de forme <span class="symbol">&#946;</span> ; 
	</li><li>
		<code class="code">webtrc m,<span class="symbol">&#946;</span>,<span class="symbol">&#945;</span></code> est la loi de Weibull tronqu&eacute;e 
		de moyenne m, de param&egrave;tre de forme <span class="symbol">&#946;</span> et 
		d'&acirc;ge <span class="symbol">&#945;</span> &agrave; l'instant t = 0; 
	</li></ul></div>
	</p><p> 
		Au niveau de la description du r&eacute;seau, les lois sont rep&eacute;r&eacute;es par le mot-clef 
		<span><strong class="command">LOI</strong></span> suivi du nom de la loi et des param&egrave;tres d&eacute;crits 
		par l'utilisateur. Exemple : <span><strong class="command">LOI webtr p1,p2,p3</strong></span>
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.drc"></a>Loi Dirac {<span><strong class="command">drc ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						Distribution de DIRAC correspondant &agrave; un d&eacute;lai d&eacute;terministe 
						&eacute;gal &agrave; <span class="symbol">&#948;</span>
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>
						<span class="symbol">&#948;</span> = d&eacute;lai au bout duquel la transition est tir&eacute;e &agrave; partir 
						du moment o&ugrave; elle est devenue valide
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						d = <span class="symbol">&#948;</span>
					</p> 
				</td></tr></tbody></table></div><p> 
			Associ&eacute;e &agrave; une transition &agrave; m&eacute;moire (Cf. <a href="#Moca.Moca12.Transs.Memory" title="Transitions &agrave; m&eacute;moire">la section intitul&eacute;e &laquo;&nbsp;Transitions &agrave; m&eacute;moire&nbsp;&raquo;</a>), 
			une loi de DIRAC permet de fabriquer un compteur de temps.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.erlg"></a>Loi Erlang {<span><strong class="command">erlg ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) = <span class="inlinemediaobject"><img src="Moca12/Law/Erlang-01.gif"></span>
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>m = moyenne = E(d);</p>
					<p><span class="symbol">&#946;</span> = ordre de la loi d'Erlang.</p>
				</td></tr><tr><td><p>   Pr&eacute;-calcul   </p></td><td> 
					<p>
						p<sub>1</sub> = <span class="inlinemediaobject"><img src="Moca12/Law/Erlang-02.gif"></span>
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z<sub>1</sub>, Z<sub>2</sub>, ..., 
						Z<sub><span class="symbol">&#946;</span></sub> tir&eacute;s au hasard et &eacute;quir&eacute;partis 
						entre 0 et 1;
					</p> 
					<p>
						d = - p<sub>1</sub>.LN(Z<sub>1</sub> 
						Z<sub>2</sub> ... Z<sub><span class="symbol">&#946;</span></sub>) 
						distribution d'Erlang.
					</p> 
				</td></tr></tbody></table></div><p> 
			Comme <span class="inlinemediaobject"><img src="Moca12/Law/Erlang-03.gif"></span> est &eacute;gal &agrave; 
			<span class="inlinemediaobject"><img src="Moca12/Law/Erlang-02.gif"></span>
			l'&eacute;valuation de p<sub>1</sub> est imm&eacute;diate.
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.erlgg"></a>Loi Erlang g&eacute;n&eacute;ralis&eacute;e {<span><strong class="command">erlgg ...</strong></span>}</h4></div></div></div><p> 
			La distribution d'Erlang g&eacute;n&eacute;ralis&eacute;e est un cas particulier de loi 
			de probabilit&eacute; dite de TYPE PHASE qui permet de mod&eacute;liser des 
			r&eacute;seaux de files d'attente. 
			Une loi d'Erlang g&eacute;n&eacute;ralis&eacute;e d'ordre <span class="symbol">&#946;</span> et de param&egrave;tres 
			<span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub><span class="symbol">&#946;</span></sub>
			mod&eacute;lise la somme 
			T = T<sub>1</sub>+T<sub>2</sub>+...+T<sub><span class="symbol">&#946;</span></sub> 
			o&ugrave; les T<sub>i</sub> ob&eacute;issent &agrave; des lois exponentielles de param&egrave;tres 
			<span class="symbol">&#955;</span><sub>i</sub>.
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						Le produit de convolution de loi exponentielle &agrave; 
						param&egrave;tres diff&eacute;rents.
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#946;</span> = ordre de la loi d'Erlang g&eacute;n&eacute;ralis&eacute;e;</p>
					<p>
						<span class="symbol">&#955;</span><sub>1</sub> , ... , <span class="symbol">&#955;</span><sub><span class="symbol">&#946;</span></sub>
						correspondent aux <span class="symbol">&#946;</span> exponentielles en s&eacute;rie 
					</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z<sub>1</sub>, Z<sub>2</sub>, ..., 
						Z<sub><span class="symbol">&#946;</span></sub> tir&eacute;s au hasard et &eacute;quir&eacute;partis 
						entre 0 et 1;
					</p> 
					<p>
						d = - <span class="symbol">&sum;</span><sup><span class="symbol">&#946;</span></sup>
						<sub>i=1</sub>( LN(Z<sub>i</sub>)/ 
						<span class="symbol">&#955;</span><sub>i</sub> )
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.empir"></a>Loi Empirique {<span><strong class="command">empir ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>Histogramme &agrave; classes &eacute;quiprobables</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>
						X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>N+1</sub> 
						o&ugrave; N d&eacute;signe le nombre de classes de l'&eacute;chantillon  
						et les (Xi)<sub>1<span class="symbol">&le;</span>i<span class="symbol">&le;</span>N+1</sub> repr&eacute;sentent 
						les bornes des diff&eacute;rentes classes &eacute;quiprobables 
						(Ils sont class&eacute;s par ordre croissant) : 
						<p>
                             X<sub>1</sub>, X<sub>2</sub> 
                             repr&eacute;sentent les bornes inf&eacute;rieure et sup&eacute;rieure de la classe 1,
                        </p>
						<p>
                             ...
                        </p>
						<p>
                             X<sub>N</sub>, X<sub>N+1</sub> 
                             repr&eacute;sentent les bornes inf&eacute;rieure et sup&eacute;rieure de la classe N.
                        </p>
					</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1;
					</p> 
					<p>
	                    Calcul de la classe i &agrave; laquelle appartient Z:
						<p>i = INT(N.Z)+1; (INT = partie enti&egrave;re)</p>
	                    Calcul du d&eacute;lai par interpolation lin&eacute;aire entre les bornes de la classe i :
						<p> d = X<sub>i</sub> + ( X<sub>i+1</sub> 
							- X<sub>i</sub> )( N.Z - INT(i) ).
	                    </p>
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.exp"></a>Loi Exponentielle {<span><strong class="command">exp ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) = <span class="symbol">&#955;</span>.e<sup>-<span class="symbol">&#955;</span>d</sup>
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#955;</span> = taux de d&eacute;faillance</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1;
					</p> 
					<p>
						d = - LN(Z)/<span class="symbol">&#955;</span> : d&eacute;lai exponentiel.
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.expw"></a>Loi Exponentielle + wow {<span><strong class="command">expw ...</strong></span>}</h4></div></div></div><p>
			Il s'agit d'un d&eacute;lai exponentiel auquel on ajoute un d&eacute;lai constant. 
			Dans les versions pr&eacute;c&eacute;dentes du logiciel, ce d&eacute;lai &eacute;tait calcul&eacute; en 
			fonction du temps courant de la simulation et d'un tableau repr&eacute;sentant 
			un d&eacute;lai pour chaque mois de l'ann&eacute;e. Dans cette version du logiciel, 
			ce d&eacute;lai peut-&ecirc;tre calcul&eacute; directement &agrave; l'aide des expressions du langage.
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d1) = <span class="symbol">&#955;</span>.e<sup>-<span class="symbol">&#955;</span>d1</sup>
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#955;</span> = taux de d&eacute;faillance ;</p>
					<p><span class="symbol"><span class="symbol">&#948;</span></span> = d&eacute;lai &agrave; ajouter</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1 ;
					</p> 
					<p>
						d<sub>1</sub> = - LN(Z)/<span class="symbol">&#955;</span> : d&eacute;lai exponentiel ;
					</p> 
					<p>
						d = d<sub>1</sub> + <span class="symbol"><span class="symbol">&#948;</span></span>.
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.ipa"></a>Loi Instant Pr&eacute;vu &agrave; l'Avance {<span><strong class="command">ipa ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						Si (n-1).<span class="symbol">&#964;</span> &lt; T &lt; n.<span class="symbol">&#964;</span> alors le tir est 
						effectu&eacute; &agrave; l'instant n.<span class="symbol">&#964;</span> (T &eacute;tant le temps courant).
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#964;</span> = d&eacute;lai entre deux tirs potentiels successifs</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						d = <span class="symbol">&#964;</span> - (T mod <span class="symbol">&#964;</span>).
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.ifa"></a>Loi Instant Fix&eacute; &agrave; l'Avance {<span><strong class="command">ifa ...</strong></span>}</h4></div></div></div><p>
			La loi <code class="code">ifa</code> est similaire &agrave; la loi <code class="code">IPA</code> mais le 
			premier intervalle est diff&eacute;rent des autres. 
			Ceci est utile, par exemple, pour d&eacute;caler les instants de test de 
			composants test&eacute;s &agrave; la m&ecirc;me fr&eacute;quence.
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						Si T &lt; <span class="symbol">&#952;</span> alors le tir a lieu &agrave; <span class="symbol">&#952;</span>. 
						(T &eacute;tant le temps courant)
					</p>
					<p>
						Si ((n-1).<span class="symbol">&#964;</span> + <span class="symbol">&#952;</span>) &lt; T &lt; (n.<span class="symbol">&#964;</span> + <span class="symbol">&#952;</span>)
						alors le tir est effectu&eacute; &agrave; l'instant n.<span class="symbol">&#964;</span> + <span class="symbol">&#952;</span>.
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#964;</span> = d&eacute;lai entre deux tirs potentiels successifs ;</p>
					<p><span class="symbol">&#952;</span> = d&eacute;lai du 1er tir.</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Si T est inf&eacute;rieur &agrave; <span class="symbol">&#952;</span>, d = <span class="symbol">&#952;</span>.
					</p> 
					<p>
						Dans le cas contraire, d = <span class="symbol">&#964;</span> - (T mod <span class="symbol">&#964;</span>).
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.nlog"></a>Loi Log-Normale {<span><strong class="command">nlog ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d') = <span class="inlinemediaobject"><img src="Moca12/Law/NLog-01.gif"></span>
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>m = moyenne = E(d);</p>
					<p>q = facteur d'erreur &agrave; 5%.</p>
				</td></tr><tr><td><p>   Pr&eacute;-calcul   </p></td><td> 
					<p>
						b = <span class="inlinemediaobject"><img src="Moca12/Law/NLog-02.gif"></span>
					</p> 
					<p>
						Pour un facteur d'erreur &agrave; 5%, la valeur de U<sub>a</sub> 
						est &eacute;gale &agrave; 1.64 (valeur provenant des tables relatives &agrave; la loi normale) 
						ce qui permet de d&eacute;finir un intervalle de confiance &agrave; 90% 
						(5% de chaque c&ocirc;t&eacute;).
					</p>
					<p>
						a = <span class="inlinemediaobject"><img src="Moca12/Law/NLog-03.gif"></span>
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z<sub>1</sub>, Z<sub>2</sub> tir&eacute;s au hasard 
						et &eacute;quir&eacute;partis entre 0 et 1;
					</p> 
					<p>
						d' = [ - 2 LN(Z<sub>1</sub>) ]<sup>1/2</sup>
						.cos(2 p Z<sub>2</sub>)      (Distribution normale r&eacute;duite);
					</p> 
					<p>
						d = exp (b.d' + a)               (Distribution log-normale).
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.spec"></a>Loi Sp&eacute;ciale {<span><strong class="command">spec ...</strong></span>}</h4></div></div></div><p>
			Le type <code class="code">spec</code> ne correspond pas &agrave; une mais &agrave; un ensemble de lois 
			que l'utilisateur peut d&eacute;finir lui-m&ecirc;me &agrave; l'aide d'un sous-programme C. 
			Un exemple est donn&eacute; au chapitre : <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>.
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						Elle est ce que l'utilisateur d&eacute;sire et c'est &agrave; lui de la d&eacute;finir
					</p>
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>n  =  Num&eacute;ro de la loi sp&eacute;ciale ;</p>
					<p>p<sub>1</sub>,...,p<sub>m</sub> = 
						correspondent aux param&egrave;tres de la loi.</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						d  est &eacute;valu&eacute; par un sous-programme &eacute;crit par l'utilisateur lui-m&ecirc;me
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.tri"></a>Loi Triangulaire {<span><strong class="command">tri ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) de type triangulaire, comprise entre a et b et 
						&eacute;tant &agrave; son maximum &agrave; t=c.
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>a = Borne inf&eacute;rieure;</p>
					<p>b = Borne sup&eacute;rieure;</p>
					<p>c = mode;</p>
					<p>avec a &lt; c &lt; b.</p>
				</td></tr><tr><td><p>   Pr&eacute;-calcul   </p></td><td> 
					<p>
						F(c) = (c-a)/(b-a) : utilis&eacute; lors du test sur Z
					</p> 
					<p>
						p<sub>1</sub> = [(c-a).(b-a)]<sup>1/2</sup> : 
						pente entre a et c
					</p> 
					<p>
						p<sub>2</sub> = [(b-c).(b-a)]<sup>1/2</sup> : 
						pente entre c et b
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1 ;
					</p> 
					<pre class="programlisting">	si Z = 0, 
		d = a
	sinon	
		si Z &lt; F(c), 
			d = a + p<sub>1</sub>.Z<sup>1/2</sup>
		sinon
			si Z &lt; F(c), 
				d = b + p<sub>2</sub>.(1-Z)<sup>1/2</sup>
			sinon d = b</pre> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.unif"></a>Loi Uniforme {<span><strong class="command">unif ...</strong></span>}</h4></div></div></div><p>
			A la demande de certains utilisateurs nous avons introduit la loi uniforme 
			qui poss&egrave;de les caract&eacute;ristiques suivantes:
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) uniforme entre <span class="symbol">&#948;</span><sub>1</sub> et 
						<span class="symbol">&#948;</span><sub>2</sub>.
					</p>
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p><span class="symbol">&#948;</span><sub>1</sub> = Borne inf&eacute;rieure du d&eacute;lai</p>
					<p><span class="symbol">&#948;</span><sub>2</sub> = Borne sup&eacute;rieure du d&eacute;lai</p>
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1 ;
					</p> 
					<p>
						d = (<span class="symbol">&#948;</span><sub>2</sub> - <span class="symbol">&#948;</span><sub>1</sub> );Z + <span class="symbol">&#948;</span><sub>1</sub>. (distribution uniforme)
					</p> 
				</td></tr></tbody></table></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.web"></a>Loi Weibull {<span><strong class="command">web ...</strong></span>}</h4></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) = <span class="symbol">&#955;</span>.<span class="symbol">&#946;</span>.d<sup><span class="symbol">&#946;</span>-1</sup>.exp(-.<span class="symbol">&#955;</span>.d<sup><span class="symbol">&#946;</span></sup>)
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>m = moyenne = E(d);</p>
					<p><span class="symbol">&#946;</span> = param&egrave;tre de forme.</p>
				</td></tr><tr><td><p>   Pr&eacute;-calcul   </p></td><td> 
					<p>
						p<sub>1</sub> = (1/<span class="symbol">&#955;</span>)<sup>1/<span class="symbol">&#946;</span></sup>;
					</p> 
					<p>
						p<sub>2</sub> = 1/<span class="symbol">&#946;</span>;
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1 ;
					</p> 
					<p>
						d = p<sub>1</sub>.[- LN(Z)]<sup>p<sub>2</sub></sup>.
					</p> 
				</td></tr></tbody></table></div><p>
			Il faut &eacute;valuer p<sub>1</sub> = (1/<span class="symbol">&#955;</span>)<sup>1/<span class="symbol">&#946;</span></sup>;
		</p><p>
			Sachant m = E(d) = <span class="inlinemediaobject"><img src="Moca12/Law/Web-01.gif"></span>(propri&eacute;t&eacute; loi de Weibull),
		</p><p>
			On en d&eacute;duit p<sub>1</sub> = <span class="inlinemediaobject"><img src="Moca12/Law/Web-02.gif"></span> = <span class="symbol">&#951;</span> (param&egrave;tre d'&eacute;chelle)
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Delay.webtr"></a>Loi Weibull tronqu&eacute;e {<span><strong class="command">webtr ...</strong></span>}</h4></div></div></div><p>
			La distribution de la loi Weibull tronqu&eacute;e, a la propri&eacute;t&eacute; de correspondre 
			&agrave; un taux de d&eacute;faillance non nul &agrave; l'instant initial (&acirc;ge <span class="symbol">&#945;</span> du composant) 
			et variant en fonction du temps. 
			Ceci permettra, en particulier de prendre en compte le fait qu'une maintenance 
			pr&eacute;ventive ou corrective ne remet pas forc&eacute;ment compl&egrave;tement &agrave; neuf les 
			composants maintenus. 
			Cette loi est compl&egrave;tement d&eacute;crite dans la note technique 
			DSE/SES- ARF 95063 "Simulation d'une maintenance imparfaite - Loi de Weibull tronqu&eacute;e)".
		</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>   Densit&eacute;   </p></td><td> 
					<p>
						f(d) = <span class="symbol">&#955;</span>.<span class="symbol">&#946;</span>.(d+<span class="symbol">&#945;</span>)<sup><span class="symbol">&#946;</span>-1</sup> 
							exp( <span class="symbol">&#955;</span>.{<span class="symbol">&#945;</span><sup><span class="symbol">&#946;</span></sup> - (d+<span class="symbol">&#945;</span>)<sup><span class="symbol">&#946;</span></sup>) )
					</p> 
				</td></tr><tr><td><p>   Param&egrave;tres   </p></td><td> 
					<p>m = moyenne de la loi non tronqu&eacute;e;</p>
					<p><span class="symbol">&#946;</span> = param&egrave;tre de forme;</p>
					<p><span class="symbol">&#945;</span> = &acirc;ge &agrave; t=0.</p>
				</td></tr><tr><td><p>   Pr&eacute;-calcul   </p></td><td> 
					<p>
						p<sub>1</sub> = 1/<span class="symbol">&#946;</span>;
					</p> 
					<p>
						p<sub>2</sub> = <span class="symbol">&#955;</span>/<span class="symbol">&#945;</span><sup><span class="symbol">&#946;</span></sup>;
					</p> 
				</td></tr><tr><td><p>   Simulation   </p></td><td> 
					<p>
						Z tir&eacute; au hasard est &eacute;quir&eacute;parti entre 0 et 1 ;
					</p> 
					<p>
						d = <span class="symbol">&#945;</span>.{[1- LN(Z)/p<sub>2</sub>]<sup>p<sub>1</sub></sup> -1}
					</p> 
				</td></tr></tbody></table></div><p>
			La Moyenne de la loi Weibull non tronqu&eacute;e est m = E(d) = <span class="inlinemediaobject"><img src="Moca12/Law/WebTr-01.gif"></span>.
		</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.Law.Fire"></a>Lois de tir de Moca-RP<sup>C</sup></h3></div></div></div><p> 
		Les lois de tir actuellement disponibles sont les suivantes :
		<div class="itemizedlist"><ul type="disc" compact><li>
		<code class="code">def</code> est la loi de tir par d&eacute;faut 
		(g&eacute;n&eacute;ralement employ&eacute; dans les r&eacute;seaux de Petri)
	</li><li>
		<code class="code">sol <span class="symbol">&#947;</span><sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub></code> 
		est une loi de tir &agrave; la sollicitation pour n+1 arcs avals. 
	</li><li>
		<code class="code">sol2 <span class="symbol">&#947;</span><sub>1</sub>, #P<sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, #P<sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub>, #P<sub>n</sub></code> 
		est une seconde loi de tir &agrave; la sollicitation pour n+1 places avales. 
		Cette seconde loi permet de sp&eacute;cifier explicitement la place qui est associ&eacute;e &agrave; chaque gamma.
	</li><li>
		<code class="code">spec n, p<sub>1</sub>,...,p<sub>m</sub></code> 
		est la n<sup>i&egrave;me</sup> loi sp&eacute;ciale qui prend 
		p<sub>1</sub>,...,p<sub>m</sub> en param&egrave;tres. 
		Les lois sp&eacute;ciales permettent d'ajouter de nouvelles lois directement en C &agrave; 
		l'aide d'une API de programmation (Cf. <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>)
	</li></ul></div>
	</p><p> 
		Au niveau de la description du r&eacute;seau, les lois sont rep&eacute;r&eacute;es par le mot-clef
		<span><strong class="command">TIR</strong></span> suivi du nom de la loi et des param&egrave;tres d&eacute;crits 
		par l'utilisateur. Exemple : <span><strong class="command">TIR sol g1,g2,g3</strong></span>
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Fire.def"></a>Loi de tir par d&eacute;faut {<span><strong class="command">def</strong></span>}</h4></div></div></div><p> 
			Cette loi ne prend pas de param&egrave;tres et correspond &agrave; la mani&egrave;re usuelle 
			de tirer une transition dans un r&eacute;seau de Petri ; &agrave; savoir :
			<div class="itemizedlist"><ul type="disc"><li>
					Suppression pour chaque place amont d'un nombre n<sub>i</sub>
					de jetons (o&ugrave; n<sub>i</sub> est le poids de l'arc reliant 
					la place amont i de la transition) 
				</li><li>
					Ajout pour chaque place avale d'un nombre m<sub>j</sub> 
					de jetons (o&ugrave; m<sub>j</sub> est le poids de l'arc reliant 
					la place avale j de la transition)
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Fire.sol"></a>Loi de tir &agrave; la sollicitation {<span><strong class="command">sol|sol2 ...</strong></span>}</h4></div></div></div><p> 
			Au moment o&ugrave; un composant est sollicit&eacute; pour changer d'&eacute;tat, il existe 
			une certaine probabilit&eacute; not&eacute;e <span class="symbol">&#947;</span> qu'&agrave; ce moment pr&eacute;cis, le composant 
			reste dans l'&eacute;tat en cours, tombe en panne, ne change pas d'&eacute;tat correctement. 
			Si on repr&eacute;sente ce ph&eacute;nom&egrave;ne &agrave; l'aide d'un r&eacute;seau de Petri, on utilise 
			une transition ayant deux arcs avals, l'un menant vers le changement d'&eacute;tat, 
			l'autre vers un &eacute;tat de panne. Mais, lorsque la transition est tir&eacute;e, 
			seul un des deux arcs avals transmet un jeton dans sa place avale 
			(l'autre en transmet z&eacute;ro) et ceci avec une fr&eacute;quence &eacute;gale &agrave; <span class="symbol">&#947;</span> 
			pour l'arc menant vers l'&eacute;tat de panne et (1-<span class="symbol">&#947;</span>) pour l'autre.
		</p><p> 
			Dans les versions pr&eacute;c&eacute;dentes de Moca-RP<sup>C</sup>, pour prendre en compte des 
			d&eacute;faillances &agrave; la sollicitation, on utilisait les lois <code class="code">SOL1</code>, 
			<code class="code">SOL2</code> et <code class="code">SOL3</code>. 
			Chacune avait des caract&eacute;ristiques sp&eacute;cifiques 
			(nombre de param&egrave;tres, avec ou sans d&eacute;lai, poids des arcs avals 
			strictement &eacute;gal &agrave; 1 ou pas, ...). 
		</p><p> 
			La loi de tir &agrave; la sollicitation <span><strong class="command">sol ...</strong></span> 
			a comme objectif de fournir &agrave; l'utilisateur une loi g&eacute;n&eacute;rique pour prendre 
			en compte toutes les d&eacute;faillances &agrave; la sollicitation. 
			Les param&egrave;tres associ&eacute;s &agrave; cette loi sont les n probabilit&eacute;s de d&eacute;faillance &agrave; la sollicitation 
			<span class="symbol">&#947;</span><sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub>
			pour une transition ayant n+1 arcs avals. 
			Cette loi d&eacute;finit implicitement l'attribution des probabilit&eacute;s de distribution aux places avales
			en fonction de l'ordre du num&eacute;ro des places avales. 
			La place avale qui porte le plus petit num&eacute;ro aura une probabilit&eacute; d'&ecirc;tre 
			choisi de <span class="symbol">&#947;</span><sub>1</sub>.
		</p><p> 
			Une seconde loi de tir &agrave; la sollicitation <span><strong class="command">sol2 ...</strong></span> 
			fonctionne de la m&ecirc;me mani&egrave;re que la premi&egrave;re loi, mais l'attribution des
			probabilit&eacute;s aux places avales est explicite.
			Les param&egrave;tres associ&eacute;s &agrave; cette loi sont 
			<span class="symbol">&#947;</span><sub>1</sub>, #P<sub>1</sub>, <span class="symbol">&#947;</span><sub>2</sub>, #P<sub>2</sub>, ..., <span class="symbol">&#947;</span><sub>n</sub>, #P<sub>n</sub>
			pour une transition ayant n+1 places avales. 
			Il doit donc y avoir un arc aval entre chaque place P<sub>i</sub> et la transition.
			La probabilit&eacute; que la place avale P<sub>i</sub> soit choisie est
			&eacute;gale &agrave; <span class="symbol">&#947;</span><sub>i</sub>.
		</p><p> 
			Dans les 2 cas, la somme des <span class="symbol">&#947;</span><sub>i</sub> 
			doit &ecirc;tre inf&eacute;rieure ou &eacute;gale &agrave; 1.
		</p><p> 
			Le m&eacute;canisme de tir ne diff&egrave;re d'un tir par d&eacute;faut que pour l'ajout de jetons 
			dans les places avales. Dans cette derni&egrave;re phase :
			<div class="itemizedlist"><ul type="disc" compact><li>
					Tir Z au hasard et de mani&egrave;re &eacute;quiprobable entre 0 et 1 
				</li><li>
					Calcul de k de la mani&egrave;re suivante : 
					<div class="itemizedlist"><ul type="circle" compact><li>
							k = -1 ; i = 1
						</li><li><p>
							Tant que (k est &eacute;gal &agrave; -1)
							<div class="itemizedlist"><ul type="square" compact><li>
									Si i &gt; n alors k = n+1
								</li><li>
									sinon si (Z <span class="symbol">&le;</span> <span class="symbol">&sum;</span><sup>i</sup><sub>k=1</sub><span class="symbol">&#947;</span><sub>k</sub> alors k = i 
								</li><li>
									i = i + 1 
								</li></ul></div>
						</p></li></ul></div>
				</li><li>
					Ajout uniquement pour la k<sup>i&egrave;me</sup> place 
					d'un nombre m<sub>k</sub> de jetons (o&ugrave; m<sub>k</sub>
					est le poids de l'arc reliant la k<sup>i&egrave;me</sup> 
					place &agrave; la transition). 
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.Law.Fire.spec"></a>Loi sp&eacute;ciale {<span><strong class="command">spec ...</strong></span>}</h4></div></div></div><p> 
			Le type <code class="code">spec</code> ne correspond pas &agrave; une mais &agrave; un ensemble de lois 
			que l'utilisateur peut d&eacute;finir lui-m&ecirc;me &agrave; l'aide d'un sous-programme C. 
			Un exemple est donn&eacute; au chapitre : <a href="#Moca.Moca12.API" title="Interface de programmation C">la section intitul&eacute;e &laquo;&nbsp;Interface de programmation C&nbsp;&raquo;</a>.
		</p><p> 
			Les param&egrave;tres de cette loi sont son num&eacute;ro (n), ainsi que les m param&egrave;tres 
			p<sub>1</sub>,...,p<sub>m</sub>
			dont l'utilisateur aura besoin lors de la simulation.
		</p><p> 
			Le m&eacute;canisme de tir de la transition est laiss&eacute; &agrave; la responsabilit&eacute; de 
			l'utilisateur. Afin de ne pas engendrer des perturbations avec le moteur 
			de calcul, il est recommand&eacute; de modifier le marquage d'une place que s'il 
			existe un arc entre la dite place et la transition et il est recommand&eacute; de 
			modifier la valeur d'une variable que si on retrouve cette variable dans 
			les affectations de la transition.
		</p></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Moca.Moca12.API"></a>Interface de programmation C</h2></div><div><h3 class="subtitle">Ajout de fonctions/lois externes</h3></div></div></div><p> 
		Afin de permettre l'exp&eacute;rimentation de nouvelles lois (de d&eacute;lai ou de tir) ou d'ajouter des
		fonctions externes &agrave; l'application, Moca-RP<sup>C</sup> offre une interface de programmation (API) 
		permettant &agrave; l'utilisateur averti d'int&eacute;grer de nouvelles lois ou fonctions par un programme. 
		Jusqu'&agrave; la version 9.X cette API &eacute;tait r&eacute;alis&eacute;e en langage Fortran. 
		&Agrave; partir de la version 10.X ce programme devra &ecirc;tre &eacute;crit en langage C. 
	</p><p> 
		Dans la version 12, nous n'avons pas jug&eacute; utile de maintenir les API d'ajout d'&eacute;tats statistiques. 
		Les expressions offrent de tr&egrave;s nombreuses possibilit&eacute;s pour la d&eacute;finition d'&eacute;tats statistiques.
	</p><p> 
		Depuis la version 12.16, cette API a &eacute;t&eacute; &eacute;tendue afin d'int&eacute;grer des fonctions externes &agrave; Moca.
		Le principe de lancement de Moca a alors &eacute;t&eacute; revu afin de faciliter l'acc&egrave;s &agrave; cette API.
	</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.API.Intro"></a>Lancement de Moca-RP<sup>C</sup></h3></div></div></div><p> 
			La distribution de Moca-RP<sup>C</sup> int&egrave;gre 4 fichiers principaux : 
			<div class="orderedlist"><ol type="1"><li>
					<code class="filename">Moca13.dll</code> est le coeur de l'application. C'est une librairie regroupant 
					l'ensemble des fonctions pour lire les diff&eacute;rents formats, interpr&eacute;ter les commandes,
					faire une simulation, afficher les r&eacute;sultats, ...
				</li><li>
					<code class="filename">Moca13.exe</code> est le lanceur de l'application (l'ex&eacute;cutable). Il appelle 
					les fonctions d'entr&eacute;e de la librairie (cr&eacute;ation et lancement un interpr&eacute;teur de commandes).
				</li><li>
					<code class="filename">MocaAdd.dll</code> est une librairie optionnelle charg&eacute;e dynamiquement par
					<code class="filename">Moca13.dll</code>. C'est au sein de cette librairie que des lois ou des fonctions
					peuvent &ecirc;tre ajout&eacute;es &agrave; l'interpr&eacute;teur de commande. Cette librairie doit &ecirc;tre
					dans le m&ecirc;me r&eacute;pertoire que la librairie principale. Dans le cas contraire, la librairie
					principale ne pourra pas charger cette librairie optionnelle.
				</li><li>
					<code class="filename">Moca13.ini</code> est un fichier d'initialisation optionnel lu lors du d&eacute;marrage
					de l'application. Il permet &agrave; l'aide des commandes de l'interpr&eacute;teur de commandes
					la d&eacute;finition de format d'affichage des r&eacute;sultats et/ou la modification des options
					par d&eacute;faut de l'interpr&eacute;teur de commandes
				</li></ol></div>
		</p><p>
			Lors du lancement de l'application, l'interpr&eacute;teur de commande est cr&eacute;&eacute;.
			Puis diff&eacute;rentes op&eacute;rations sont effectu&eacute;es dans l'ordre :  
			<div class="itemizedlist"><ul type="disc" compact><li>
					V&eacute;rification des options de lancement de l'application (options pass&eacute;es en argument
					au niveau de la ligne de commande) ;
				</li><li>
					Chargement s'il existe du fichier <code class="filename">Moca13.ini</code> ;
				</li><li>
					Chargement s'il existe de la librairie <code class="filename">MocaAdd.dll</code> (et donc ajout des
					fonctions/lois externes au sein de Moca-RP<sup>C</sup>) ;
				</li><li>
					Chargement des fichiers pass&eacute;s au niveau de la ligne de commande ;
				</li><li>
					D&eacute;marrage d'une session utilisateur (interpr&eacute;teur de commandes)
				</li></ul></div>
		</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.API.Use"></a>Utilisation des fonctions/lois externes</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Use.xFct"></a>Fonctions externes</h4></div></div></div><p> 
				Une fonction externe est d&eacute;finie &agrave; l'aide
				<div class="itemizedlist"><ul type="disc"><li>
						<span class="emphasis"><em>de son nom</em></span> : afin de l'identifier et de l'utiliser au sein 
						d'un r&eacute;seau de Petri. Par convention (bien que cela ne soit
						d'aucune obligation), le nom d'une fonction externe commence par la lettre x en
						minuscule (pour eXterne) suivi d'un nom significatif commen&ccedil;ant par une majuscule.
						Cela permet de diff&eacute;rencier rapidement les fonctions propres &agrave; Moca des fonctions
						externes d&eacute;finis par l'utilisateur.
					</li><li>
						<span class="emphasis"><em>de sa signature</em></span> : la signature d'une fonction pr&eacute;cise 
						le nombre d'argument, le type (bool&eacute;en, entier, r&eacute;el) de chacun des arguments, 
						ainsi que le type de valeur qui sera renvoy&eacute; par la fonction. La signature 
						permet lors de la lecture du mod&egrave;le d'afficher un &eacute;ventuel message d'erreur/avertissement
						si le nombre d'argument n'est pas correct ou si un argument n'est pas du type attendu.
					</li><li>
						<span class="emphasis"><em>d'un &eacute;ventuel commentaire</em></span> permettant de pr&eacute;ciser ce que calcule
						la fonction externe.
					</li></ul></div>
			</p><p>
				Seuls les types bool&eacute;en (<code class="code">B</code>), entier (<code class="code">I</code>) et r&eacute;el (<code class="code">F</code>)
				sont g&eacute;r&eacute;s au sein de Moca.
			</p><p>
				Une fois d&eacute;finie, une fonction externe peut &ecirc;tre utilis&eacute;e dans la description d'un r&eacute;seau
				de Petri directement au niveau des expressions du mod&egrave;le de la m&ecirc;me
				mani&egrave;re qu'une fonction interne &agrave; Moca comme <code class="code">log(n)</code>. 
				Les fonctions externes s'int&egrave;grent naturellement &agrave; la description du r&eacute;seau.
			</p><p>
				Il est possible d'afficher l'ensemble des fonctions externes au sein de l'interpr&eacute;teur de commandes
				&agrave; l'aide de la commande <span><strong class="command">display functions;</strong></span>.
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Use.xLaw"></a>Lois externes (ou sp&eacute;ciales)</h4></div></div></div><p> 
				Moca-RP<sup>C</sup> permet d'int&eacute;grer de nouvelles lois (de tir et de d&eacute;lai). L'utilisation de ces lois 
				au sein d'un R&eacute;seau de Petri est r&eacute;alis&eacute;e via la loi sp&eacute;ciale (spec). 
			</p><p> 
				Ces lois prennent comme arguments : 
				<div class="itemizedlist"><ul type="disc" compact><li>
						Un num&eacute;ro qui indique le num&eacute;ro de la loi externe consid&eacute;r&eacute;e ; le nombre de nouvelles 
						lois n'est pas born&eacute;. Ce num&eacute;ro est ind&eacute;pendant du type de loi (tir ou d&eacute;lai)
					</li><li>
						Un ensemble d'expression correspondant &agrave; l'ensemble des param&egrave;tres de la loi. 
						Tous les param&egrave;tres de la loi sont de type r&eacute;el.
						Seule la valeur des expressions sera connue de la librairie. 
						Ces expressions sont &eacute;valu&eacute;es par le Moca-RP<sup>C</sup> avant d'&ecirc;tre utilis&eacute;es par la librairie.
					</li></ul></div>
			</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.API.Create"></a>Cr&eacute;ation de la librairie optionnelle <code class="filename">MocaAdd.dll</code></h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Create.Prereq"></a>Pr&eacute;-requis</h4></div></div></div><p>
				Avant tout chose, il est n&eacute;cessaire de disposer d'un compilateur C ANSI.
			</p><p>
				Dans l'environnement Windows, le compilateur de Microsoft simplifie grandement la t&acirc;che 
				(au niveau de la g&eacute;n&eacute;ration de la Dll). Une version gratuite <span class="application">Microsoft 
				Visual C++ Toolkit 2003</span> est disponible sur le site de cet &eacute;diteur. 
			</p><p>
				Il est &eacute;galement possible de travailler dans l'environnement CygWin/GCC avec les
				outils sp&eacute;cifiques Windows pour g&eacute;n&eacute;rer une librairie pouvant &ecirc;tre charg&eacute;e dynamiquement.
			</p><p>
				Dans la suite de ce chapitre, nous supposons que vous avez install&eacute; un des compilateurs
				Microsoft dans un r&eacute;pertoire que vous connaissez. 
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Create.Files"></a>Fichiers utilis&eacute;s</h4></div></div></div><p>
				Outre les 4 fichiers pr&eacute;c&eacute;demment d&eacute;crit, la distribution contient un ensemble de fichiers 
				n&eacute;cessaires &agrave; l'int&eacute;gration de nouvelles fonctionnalit&eacute;s. 
				Ces fichiers, en g&eacute;n&eacute;ral stock&eacute;s dans le r&eacute;pertoire <code class="filename">api</code> de la distribution, 
				sont les suivants :
				<div class="itemizedlist"><ul type="disc"><li>
						<code class="filename">MocaAPIType.h</code> est un fichier ent&ecirc;te C. 
						Il contient l'ensemble des d&eacute;clarations de types utilis&eacute;s au sein de l'API. 
					</li><li>
						<code class="filename">MocaAPI.h</code> est un fichier ent&ecirc;te C. 
						Il contient l'ensemble des d&eacute;clarations de fonctions disponibles au niveau de l'API. 
					</li><li>
						<code class="filename">MocaAdd.c</code> est un exemple complet de code permettant de 
						d&eacute;clarer des fonctions externes. 
					</li><li>
						<code class="filename">Moca13.lib</code> est une biblioth&egrave;que des fonctions C.
						Il contient l'ensemble des fonctions export&eacute;s au niveau du fichier <code class="filename">MocaAPI.h </code>
						Cette biblioth&egrave;que devra &ecirc;tre li&eacute;e &agrave; la librairie additionnelle de Moca.
					</li><li>
						<code class="filename">MocaMake.bat</code> est un fichier de commande qui g&eacute;n&egrave;re 
						la librairie <code class="filename">MocaAdd.dll</code> dans l'environnement Windows &agrave; l'aide 
						d'un compilateur Microsoft.
					</li></ul></div>
				Nous sugg&eacute;rons &agrave; l'utilisateur de faire une copie de l'ensemble de ces fichiers dans 
				son r&eacute;pertoire de travail. 
				Seuls les fichiers <code class="filename">MocaAdd.c</code> et <code class="filename">MocaMake.bat</code> doivent &ecirc;tre modifi&eacute;.
			</p><p>
				Avant d'utiliser <code class="filename">MocaMake.bat</code>, il est n&eacute;cessaire de modifier les lignes 4 et 5
				de ce script afin de pr&eacute;ciser respectivement le r&eacute;pertoire de destination (l&agrave; o&ugrave; sera copi&eacute;
				le fichier <code class="filename">MocaAdd.dll</code>) et le r&eacute;pertoire d'installation du compilateur Microsoft
				&agrave; l'aide des variables d'environnement <code class="literal">MOCA_OUT</code> et <code class="literal">VCPP_PATH</code>.
				<pre class="programlisting">@echo off&#13;
rem ---------------------------------------------------------------------&#13;
rem Visual C++ 9.0 doit etre installe et &#13;
rem vc9varsxx.bat doit avoir ete execute avant l'execution de ce script&#13;
rem ---------------------------------------------------------------------&#13;
&#13;
setlocal&#13;
&#13;
cl /MT /W3 /EHsc /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "__WINDOWS__" /D "_MBCS" /D "_USRDLL"  /D "_CRT_SECURE_NO_WARNINGS" -I. Moca13.lib /LD /FeMocaAdd.dll MocaAdd.c&#13;
&#13;
del MocaAdd.obj&#13;
del MocaAdd.lib&#13;
del MocaAdd.exp&#13;
&#13;
endlocal&#13;
pause</pre>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Create.Principe"></a>Principe g&eacute;n&eacute;ral</h4></div></div></div><p>
				Le seul point d'entr&eacute;e de la librairie additionnelle <code class="filename">MocaAdd.dll</code> est une 
				m&eacute;thode C devant &ecirc;tre nomm&eacute; <code class="literal">Moca_LoadExtend</code> et prenant en param&egrave;tre 
				un pointeur sur l'interpr&eacute;teur de commande de Moca-RP<sup>C</sup>.
				Il est n&eacute;cessaire d'exporter cette m&eacute;thode afin que la librairie principale 
				puisse la trouver et l'appeler.
			</p><p>
				L'exemple ci-dessous est un exemple minimaliste devant afficher sur la sortie standard
				le message <code class="literal">C'est la bonne librairie</code> au d&eacute;marrage de Moca-RP<sup>C</sup>.
				<pre class="programlisting">#include "MocaAPI.h"
__declspec(dllexport) void Moca_LoadExtend(mapi_shell *sh)
{
	printf("C'est la bonne librairie");
}</pre>
			</p><p>
				Ce point d'entr&eacute;e permet d'enregistrer au sein de l'interpr&eacute;teur de commandes
				les fonctions/lois externes d&eacute;finie par l'utilisateur.
			</p><p>
				Les fonctions de l'API suivantes peuvent &ecirc;tre utilis&eacute;es au sein de cette m&eacute;thode :
				<div class="itemizedlist"><ul type="disc" compact><li>
						<a href="#"><code class="function">mapi_add_function</code></a> 
						permet d'enregistrer une fonction externe.
					</li><li>
						<a href="#"><code class="function">mapi_register_special_law</code></a> 
						permet l'enregistrement de tous les lois de d&eacute;lai externe.
					</li><li>
						<a href="#"><code class="function">mapi_register_special_fire</code></a>
						permet l'enregistrement de tous les lois de tir externe.
					</li></ul></div>
			</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Create.Funct"></a>Cr&eacute;ation de fonctions externes</h4></div></div></div><p>
				La fonction <a href="#"><code class="function">mapi_add_function</code></a> 
				prend en argument l'interpr&eacute;teur de commande, le nom de la fonction, sa signature, 
				son commentaire et un pointeur de fonction permettant de r&eacute;aliser le calcul.
			</p><p>
				L'exemple ci-dessous permet de d&eacute;finir une fonction externe xSqrt prenant un param&egrave;tre r&eacute;el
				et renvoyant la racine carr&eacute; du param&egrave;tre sous forme d'un r&eacute;el.
				<pre class="programlisting">#include "MocaAPI.h"
#include &lt;math.h&gt;

static mapi_double
my_fct_sqrt(mapi_net *net, int nbr, mapi_double* args) 
{
  if (nbr != 1) {
    mapi_add_warning(net, "xSqrt : le nombre de param&egrave;tre n'est pas &eacute;gal &agrave; 1."); 
    return mapi_NaN;
  }
  else return sqrt(args[0]);
}

__declspec(dllexport) void Moca_LoadExtend(mapi_shell *sh)
{
  mapi_add_function(sh, "xSqrt", "(F)F", 
  	"La racine carr&eacute;e d'un r&eacute;el", my_fct_sqrt);
}</pre>
			</p><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca12.API.Create.Funct.Sign"></a>Signature de la fonction</h5></div></div></div><p>
					La signature de la fonction est d&eacute;crite sous la forme d'une cha&icirc;ne de caract&egrave;res 
					ayant une syntaxe sp&eacute;cifique. 
				</p><p>
					La signature <code class="literal">(F)F</code> pr&eacute;cise que la fonction prend un argument
					r&eacute;el et renvoie un r&eacute;el. Les parenth&egrave;ses (qui sont obligatoires) encadrent les
					arguments de la fonction. Le type de valeur renvoy&eacute; par la fonction se pr&eacute;cise
					apr&egrave;s les parenth&egrave;ses.
				</p><p>
					Les diff&eacute;rents types de donn&eacute;es admis au niveau de la signature sont : 
					<div class="itemizedlist"><ul type="disc" compact><li>
							<code class="code">B</code> : bool&eacute;en 
						</li><li>
							<code class="code">I</code> : entier 
						</li><li>
							<code class="code">F</code> : r&eacute;el 
						</li></ul></div>
				</p><p>
					Tous les arguments doivent &ecirc;tre donn&eacute;s les uns derri&egrave;res les autres sans espace.
					La signature <code class="literal">(II)I</code> d'une fonction de division enti&egrave;re 
					(<code class="literal">xDivInt</code>) prend 2 arguments entiers et renvoie un entier.
				</p><p>
					La signature <code class="literal">(FFFFFFFFFFFF)F</code> prend 12 arguments r&eacute;els
					et renvoie un r&eacute;el. Il est possible d'utiliser &agrave; la place un raccourci
					d'&eacute;criture en utilisant une d&eacute;claration de tableau. La signature pr&eacute;c&eacute;dente
					peut &ecirc;tre remplac&eacute;e par <code class="literal">([F12)F</code>. Le crochet ouvrant pr&eacute;cise
					l'utilisation d'un tableau, le caract&egrave;re qui suit donne le type (ici un r&eacute;el)
					le nombre pr&eacute;cise la taille du tableau. Il est possible de d'utiliser 
					conjointement les 2 notations. La signature <code class="literal">([F5FF[F5)F</code>
					est &eacute;quivalente aux 2 autres signatures de ce paragraphe.
				</p><p>
					La signature <code class="literal">([F2+)F</code> d&eacute;finit une fonction prenant 2 ou plus 
					arguments r&eacute;els. Le caract&egrave;re '+' ne peut s'employer qu'en derni&egrave;re position
					de la d&eacute;claration des arguments et en relation avec un tableau.
					Cela permet donc de d&eacute;finir des fonctions ayant un nombre d'argument ind&eacute;fini.
				</p><p>
					La majorit&eacute; des fonctions n'a pas besoin d'&ecirc;tre r&eacute;&eacute;valu&eacute;e si la valeur des
					arguments n'a pas &eacute;t&eacute; modifi&eacute;e. Moca-RP<sup>C</sup> se basent sur ce principe pour
					&eacute;viter de r&eacute;&eacute;valuer les expressions inutilement. Les fonctions externes
					peuvent utiliser un nombre g&eacute;n&eacute;r&eacute; al&eacute;atoirement, le temps courant de 
					la simulation ou encore directement la valeur d'une variable du r&eacute;seau 
					sans que ces informations ne soient pass&eacute;es en argument. Ces fonctions
					doivent alors &ecirc;tre syst&eacute;matiquement r&eacute;&eacute;valu&eacute;es. Pour pr&eacute;ciser cela, il suffit
					d'ajouter le caract&egrave;re '#' &agrave; la fin de la signature de la fonction.
					La fonction xRandom renvoyant un nombre al&eacute;atoire entre 0 et 1 est d&eacute;finie
					&agrave; l'aide de la signature <code class="literal">()F#</code>.
				</p><p>
					Si la syntaxe associ&eacute;e &agrave; la signature n'est pas respect&eacute;e, un message sera 
					affich&eacute; sur le flux d'erreur de l'application au moment de 
					l'enregistrement de la fonction. 
				</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca12.API.Create.Funct.Funct"></a>Code de la fonction</h5></div></div></div><p>
					La fonction r&eacute;alisant le calcul prend en param&egrave;tre le r&eacute;seau de Petri,
					le nombre d'argument et un tableau contenant l'ensemble des arguments.
					Elle renvoie bien entendu le r&eacute;sultat associ&eacute; &agrave; la fonction externe.
					Si un probl&egrave;me survient, elle peut renvoyer la valeur 
					<a href="#"><code class="code">mapi_NaN</code></a>.
					Le prototype de la fonction est d&eacute;crit plus en d&eacute;tail 
					(Cf. <a href="#">???</a>).
				</p><p>
					Les principales fonctions d'API utilis&eacute;es au sein du code d'une fonction
					externes sont : 
					<div class="itemizedlist"><ul type="disc" compact><li>
							<a href="#"><code class="function">mapi_add_warning</code></a>
							permet d'associer un message d'avertissement au r&eacute;seau de Petri qui 
							sera affich&eacute; &agrave; la fin de la simulation.
						</li><li>
							<a href="#"><code class="function">mapi_get_probability</code></a>
							renvoie un nombre al&eacute;atoire entre 0 et 1.
						</li><li>
							<a href="#"><code class="function">mapi_get_time</code></a>
							renvoie le temps courant de la simulation.
						</li></ul></div>
				</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca12.API.Create.Law"></a>Cr&eacute;ation de lois externes</h4></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca12.API.Create.Law.Intro"></a>Principes</h5></div></div></div><p>
					Pour d&eacute;finir de nouvelles lois l'utilisateur doit d&eacute;finir un certain nombre 
					de fonction sp&eacute;cifique au type de loi consid&eacute;r&eacute; (loi de d&eacute;lai ou loi de tir). 
					Dans les deux cas, les deux fonctions suivantes doivent &ecirc;tre &eacute;crites : 
					<div class="orderedlist"><ol type="1"><li>
							Une fonction d'initialisation du m&eacute;canisme. Cette fonction est 
							appel&eacute;e par le moteur de calcul avant le lancement de la simulation. 
							Cette fonction a la charge de pr&eacute;venir l'utilisateur de la prise 
							en charge ou non de la dite loi sp&eacute;ciale. Elle peut aussi se charger 
							de cr&eacute;er les structures de donn&eacute;es n&eacute;cessaires &agrave; la mise en &#339;uvre des 
							nouvelles lois. Le prototype de ces fonctions est d&eacute;fini dans le 
							fichier ent&ecirc;te moca_api.h par le type de fonction 
							<a href="#"><code class="function">mapi_special_law_init_proc</code></a> ou 
							<a href="#"><code class="function">mapi_special_fire_init_proc</code></a>.
						</li><li>
							Une fonction de v&eacute;rification des param&egrave;tres. Cette fonction est 
							appel&eacute;e par le moteur de calcul afin de valider les param&egrave;tres 
							de la loi. La valeur de retour de la fonction permet de savoir si les 
							param&egrave;tres sont valides ou non. Dans le second cas, la fonction peut 
							renvoyer un message et un code d'erreur. Le prototype de ces fonctions 
							est d&eacute;fini dans le fichier ent&ecirc;te moca_api.h par le type de fonction 
							<a href="#"><code class="function">mapi_special_law_verif_proc</code></a> ou 
							<a href="#"><code class="function">mapi_special_fire_verif_proc</code></a>).
						</li></ol></div>
				</p><p>
					Pour les lois de d&eacute;lai, il faut aussi impl&eacute;menter une fonction qui d&eacute;termine en 
					fonction du temps courant de la simulation et de la transition consid&eacute;r&eacute;e 
					quel est le d&eacute;lai avant le prochain tir de la transition. Le prototype de 
					cette fonction est d&eacute;fini dans le fichier ent&ecirc;te moca_api.h par le type 
					de fonction : <a href="#"><code class="function">mapi_special_law_delay_proc</code></a>.
				</p><p>
					Pour les lois de tir, il convient de d&eacute;finir deux autres fonctions : 
					<div class="orderedlist"><ol type="1"><li>
							Une fonction appel&eacute;e au moment o&ugrave; la transition devient valide. 
							Cette fonction peut servir pour m&eacute;moriser le temps courant par exemple. 
							Le prototype de cette fonction est d&eacute;fini dans le fichier 
							ent&ecirc;te moca_api.h par le type de fonction 
							<a href="#"><code class="function">mapi_special_fire_valid_proc</code></a>.
						</li><li>
							Une fonction appel&eacute;e au moment o&ugrave; la transition doit &ecirc;tre tir&eacute;e. 
							Cette fonction doit effectuer toutes les phases de tir de la 
							transition (affectation des variables, suppression de jetons dans 
							les places amonts et ajout de jeton dans les places avales) 
							en les modifiant &eacute;ventuellement. 
							Le prototype de cette fonction est d&eacute;fini dans le fichier ent&ecirc;te 
							moca_api.h par le type de fonction : 
							<a href="#"><code class="function">mapi_special_fire_trigger_proc</code></a>.
						</li></ol></div>
				</p><p>
					Apr&egrave;s la construction des fonctions n&eacute;cessaires aux lois sp&eacute;ciales, l'utilisateur 
					doit enregistrer dans la librairie additionnelle l'ensemble de ces fonctions 
					&agrave; l'aide des fonctions 
					<a href="#"><code class="function">mapi_register_special_law</code></a> 
					ou 
					<a href="#"><code class="function">mapi_register_special_fire</code></a>. 
				</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca12.API.Create.Law.Samples"></a>Exemple de loi de d&eacute;lai externe</h5></div></div></div><p>
					L'exemple impl&eacute;mente la loi exponentielle + wow de Moca-RP<sup>C</sup> version 10 et pr&eacute;c&eacute;dente 
					comme exemple de loi de d&eacute;lai externe. 
					Cette loi prend 13 param&egrave;tres : le premier correspond &agrave; un taux de d&eacute;faillance 
					du composant et les 12 autres &agrave; un ajustement du d&eacute;lai de d&eacute;faillance en fonction 
					des diff&eacute;rents mois de l'ann&eacute;e. 
					Cette loi a un &eacute;quivalent dans la version actuelle avec 2 param&egrave;tres le taux de d&eacute;faillance 
					et le d&eacute;lai d'ajustement (g&eacute;n&eacute;ralement calcul&eacute; &agrave; l'aide d'une expression 
					prenant en compte l'op&eacute;rateur time()).
				</p><pre class="programlisting">#include "MocaAPI.h"
#include &lt;math.h&gt;

static char buffer_mess[128];

static int
my_law_init(mapi_net *net, mapi_transition *T, int number)
{
  return number == 11 ? 1 : 0;
}

static int
my_law_verif(
            mapi_net *net, mapi_transition *T, int number, 
            int nb_arguments, mapi_double *arguments, 
            char **mess, int *code)
{
  *code = 999;
  
  if (number == 11) {
    int i;
    if (nb_arguments != 13) {
      sprintf(buffer_mess, "Le nombre d'argument doit etre egal a 13 "
        "(1 pour le Lbd et 12 pour le delai associe a chaque mois de l'annee)");
      *mess = buffer_mess;
      return 1;
    }
    for (i=0; i&lt; nb_arguments; i++) {
      if (arguments[i] &lt; 0) {
        sprintf(buffer_mess, "L'argument %d ne peut pas etre negatif.", i);
        *mess = buffer_mess;
        return 1;
      }
    }
    return 0;
  }

  *mess = "Pas possible !!";
  return 1;
}

static mapi_double
my_law_delay(
            mapi_net *net, mapi_transition *T, int number, 
            int nb_arguments, mapi_double *arguments)
{
  if (number == 11) {
    mapi_double Z = mapi_get_probability(net);
    mapi_double current_time = mapi_get_time(net);
    mapi_double result = -log(Z)/arguments[0];
    int i = ((int)(current_time / 730)) % 12 + 1;
    result += arguments[i];
    return result;
  }
  return -1;
}

__declspec(dllexport) void Moca_LoadExtend(mapi_shell *sh)
{
  mapi_register_special_law(sh,
    my_law_init, my_law_verif, my_law_delay);
}</pre></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Moca12.API.Define"></a>Description des types/fonctions de l'API</h3></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca13.API.Type"></a>D&iuml;&iquest;&#339;claration des diff&iuml;&iquest;&#339;rents types g&iuml;&iquest;&#339;r&iuml;&iquest;&#339;s par l'API</h4></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Type.Data"></a>Types associ&iuml;&iquest;&#339;s &iuml;&iquest;&#339; des donn&iuml;&iquest;&#339;es/objets</h5></div></div></div><p>

<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_shell"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_shell</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Type abstrait repr&iuml;&iquest;&#339;sentant l'interpr&iuml;&iquest;&#339;teur de commandes de Moca-RP<sup>C</sup>. 
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_net"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_net</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Type abstrait repr&iuml;&iquest;&#339;sentant un r&iuml;&iquest;&#339;seau de Petri.
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_transition"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_transition</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Type abstrait repr&iuml;&iquest;&#339;sentant une transition du r&iuml;&iquest;&#339;seau de Petri.
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_expression"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_expression</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Type abstrait repr&iuml;&iquest;&#339;sentant une expression du r&iuml;&iquest;&#339;seau de Petri.
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_table"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_table</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Type abstrait repr&iuml;&iquest;&#339;sentant un tableau du r&iuml;&iquest;&#339;seau de Petri.
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_external"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_external_id, mapi_internal_id</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Ces types repr&iuml;&iquest;&#339;sentent respectivement les num&iuml;&iquest;&#339;rotations 
	  internes et externes des places du r&iuml;&iquest;&#339;seau de Petri. Dans
	  la mesure ou les places peuvent avoir des num&iuml;&iquest;&#339;ros de 
	  description non cons&iuml;&iquest;&#339;cutifs, Moca-RP<sup>C</sup> les renum&iuml;&iquest;&#339;rote en interne.
	</p>
	<p>
	  L'obtention des informations relatives aux places s'effectue
	  via la num&iuml;&iquest;&#339;rotation interne (mapi_internal_id).
	  Le module client a la possibilit&iuml;&iquest;&#339; de r&iuml;&iquest;&#339;cup&iuml;&iquest;&#339;rer le num&iuml;&iquest;&#339;ro interne 
	  d'une place en fonction de son num&iuml;&iquest;&#339;ro externe (celui de la description)
	  via la fonction mapi_get_place_internal_ident 
	</p>
 	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_double"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_double</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
	Type des nombres r&iuml;&iquest;&#339;els utilis&iuml;&iquest;&#339;s par Moca-RP<sup>C</sup>. Ce type d&iuml;&iquest;&#339;fini
  la pr&iuml;&iquest;&#339;cision de nombres en virgules flottantes. 
  A priori le module client de l'API Moca-RP<sup>C</sup> doit utiliser ce type 
  lors de ses calculs.
	</pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_NaN"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef"> <b class="fsfunc">mapi_NaN</b>(</code></td></tr></table><pre class="funcsynopsisinfo">
		Valeur abstraite d'un nombre en virgule flottante erron&iuml;&iquest;&#339;
		(division par z&iuml;&iquest;&#339;ro, ...)
	</pre></div>
 
</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Type.FctxFct"></a>Prototype de fonctions associ&iuml;&iquest;&#339;es aux fonctions externes</h5></div></div></div><p>

<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_funct_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
	    <b class="fsfunc">mapi_special_funct_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">nb_arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">arguments</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">nb_arguments</var>;</code></td></tr><tr><td><code>mapi_double *
    	</code>&nbsp;</td><td><code><var class="pdparam">arguments</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de calcul des fonctions externes 
    d&iuml;&iquest;&#339;finies par routines C.
	</p><p>
	  Ces fonctions re&iuml;&iquest;&#339;oivent en argument le r&iuml;&iquest;&#339;seau de Petri en cours 
	  de simulation <em class="parameter"><code>net</code></em>. 
	</p><p>
	  Les arguments de la fonction externe consid&iuml;&iquest;&#339;r&iuml;&iquest;&#339;e sont donn&iuml;&iquest;&#339;s 
    dans le tableau <em class="parameter"><code>arguments</code></em> qui contient 
	  <em class="parameter"><code>nb_arguments</code></em> nombre r&iuml;&iquest;&#339;els. 
    Le type des arguments a &iuml;&iquest;&#339;t&iuml;&iquest;&#339; valid&iuml;&iquest;&#339; en fonction de la signature
    de la fonction externe.
	</p><p>
		la valeur renvoy&iuml;&iquest;&#339;e est &iuml;&iquest;&#339;ventuellement modifi&iuml;&iquest;&#339;e en fonction
    de la signature, puis utilis&iuml;&iquest;&#339;e au sein de Moca comme r&iuml;&iquest;&#339;sultat
    de l'expression.
	</p>
  </pre></div>
 
</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Type.FctDelay"></a>Prototype de fonctions associ&iuml;&iquest;&#339;es aux lois de d&iuml;&iquest;&#339;lai</h5></div></div></div><p>

<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_law_init_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_special_law_init_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions d'initialisation des <span class="emphasis"><em>lois de d&iuml;&iquest;&#339;lai</em></span>
	  d&iuml;&iquest;&#339;finies par routines C. 
	</p><p>
	  Ces fonctions ont en charge l'initialisation des
	  donn&iuml;&iquest;&#339;es du client pour la loi num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> 
	  associ&iuml;&iquest;&#339;e &iuml;&iquest;&#339; la transition <em class="parameter"><code>T</code></em>
	  du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.	
	</p>
  </pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_law_verif_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_special_law_verif_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">nb_arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mess</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">code</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
    	</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">nb_arguments</var>;</code></td></tr><tr><td><code>mapi_double *
    	</code>&nbsp;</td><td><code><var class="pdparam">arguments</var>;</code></td></tr><tr><td><code>char **</code>&nbsp;</td><td><code><var class="pdparam">mess</var>;</code></td></tr><tr><td><code>int *</code>&nbsp;</td><td><code><var class="pdparam">code</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de v&iuml;&iquest;&#339;rification des <span class="emphasis"><em>lois de d&iuml;&iquest;&#339;lai</em></span>
	  d&iuml;&iquest;&#339;finies par routines C. 
	</p><p>
	  Ces fonctions ont en charge la v&iuml;&iquest;&#339;rification des donn&iuml;&iquest;&#339;es du client 
	  pour la loi num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> associ&iuml;&iquest;&#339;e &iuml;&iquest;&#339; la transition 
	  <em class="parameter"><code>T</code></em> du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>. 
	  Les arguments de la loi consid&iuml;&iquest;&#339;r&iuml;&iquest;&#339;e sont donn&iuml;&iquest;&#339;s dans le tableau 
	  <em class="parameter"><code>arguments</code></em> qui contient 
	  <em class="parameter"><code>nb_arguments</code></em> nombre r&iuml;&iquest;&#339;els. 
	</p><p>
	  Ces fonctions retournent 0 si il n'y a pas de probl&iuml;&iquest;&#339;me, 
	  1 si les param&iuml;&iquest;&#339;tres engendre une erreur irr&iuml;&iquest;&#339;cup&iuml;&iquest;&#339;rable, 
	  2 si l'erreur est de type avertissement.
	</p><p>
	  Dans le cas d'une erreur, ces fonctions doivent modifier les 
	  param&iuml;&iquest;&#339;tres <em class="parameter"><code>mess</code></em> et <em class="parameter"><code>code</code></em> 
	  afin respectivement d'afficher de mani&iuml;&iquest;&#339;re explicite le message d'erreur 
	  et de retourner un code d'erreur via.
	</p>
  </pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_law_delay_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
	    <b class="fsfunc">mapi_special_law_delay_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">nb_arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">arguments</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">nb_arguments</var>;</code></td></tr><tr><td><code>mapi_double *
    	</code>&nbsp;</td><td><code><var class="pdparam">arguments</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de calcul de d&iuml;&iquest;&#339;lai pour les
  	lois de d&iuml;&iquest;&#339;lai d&iuml;&iquest;&#339;finies par routines C.
	</p><p>
	  Ces fonctions re&iuml;&iquest;&#339;oivent en argument le r&iuml;&iquest;&#339;seau de Petri en cours 
	  de simulation <em class="parameter"><code>net</code></em>, la transition 
	  <em class="parameter"><code>T</code></em> dont on d&iuml;&iquest;&#339;sire conna&iuml;&iquest;&#339;tre le d&iuml;&iquest;&#339;lai avant tir, 
	  le num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> de la loi sp&iuml;&iquest;&#339;ciale 
	  consid&iuml;&iquest;&#339;r&iuml;&iquest;&#339;e associ&iuml;&iquest;&#339; &iuml;&iquest;&#339; la transition. 
	</p><p>
	  Les arguments de la loi consid&iuml;&iquest;&#339;r&iuml;&iquest;&#339;e sont donn&iuml;&iquest;&#339;s dans le tableau 
	  <em class="parameter"><code>arguments</code></em> qui contient 
	  <em class="parameter"><code>nb_arguments</code></em> nombre r&iuml;&iquest;&#339;els. 
	  Ces arguments ont &iuml;&iquest;&#339;t&iuml;&iquest;&#339; v&iuml;&iquest;&#339;rifi&iuml;&iquest;&#339;s au pr&iuml;&iquest;&#339;alable.
	</p><p>
		La fonction doit renvoyer le d&iuml;&iquest;&#339;lai entre l'instant de validation
		de la transition et l'instant de tir de la transition.
	</p>
  </pre></div>
 
</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Type.FctFire"></a>Prototype de fonctions associ&iuml;&iquest;&#339;es aux lois de tir</h5></div></div></div><p>

<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_fire_init_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_special_fire_init_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions d'initialisation des <span class="emphasis"><em>lois de tir</em></span>
	  d&iuml;&iquest;&#339;finies par routines C. 
	</p><p>
	  Cette fonction a en charge l'initialisation des
	  donn&iuml;&iquest;&#339;es du client pour la loi num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> 
	  associ&iuml;&iquest;&#339;e &iuml;&iquest;&#339; la transition <em class="parameter"><code>T</code></em>
	  du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.	
	</p>
  </pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_fire_verif_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_special_fire_verif_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">nb_arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mess</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">code</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">nb_arguments</var>;</code></td></tr><tr><td><code>mapi_double *
    	</code>&nbsp;</td><td><code><var class="pdparam">arguments</var>;</code></td></tr><tr><td><code>char **</code>&nbsp;</td><td><code><var class="pdparam">mess</var>;</code></td></tr><tr><td><code>int *</code>&nbsp;</td><td><code><var class="pdparam">code</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de v&iuml;&iquest;&#339;rification des <span class="emphasis"><em>lois de tir</em></span>
	  d&iuml;&iquest;&#339;finies par routines C. 
	</p><p>
	  Ces fonctions ont en charge la v&iuml;&iquest;&#339;rification des donn&iuml;&iquest;&#339;es du client 
	  pour la loi num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> associ&iuml;&iquest;&#339;e &iuml;&iquest;&#339; la transition 
	  <em class="parameter"><code>T</code></em> du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>. 
	  Les arguments de la loi consid&iuml;&iquest;&#339;r&iuml;&iquest;&#339;e sont donn&iuml;&iquest;&#339;s dans le tableau 
	  <em class="parameter"><code>arguments</code></em> qui contient 
	  <em class="parameter"><code>nb_arguments</code></em> nombre r&iuml;&iquest;&#339;els. 
	</p><p>
	  Ces fonctions retournent 0 si il n'y a pas de probl&iuml;&iquest;&#339;me, 
	  1 si les param&iuml;&iquest;&#339;tres engendre une erreur irr&iuml;&iquest;&#339;cup&iuml;&iquest;&#339;rable, 
	  2 si l'erreur est de type avertissement.
	</p><p>
	  Dans le cas d'une erreur, ces fonctions doivent modifier les 
	  param&iuml;&iquest;&#339;tres <em class="parameter"><code>mess</code></em> et <em class="parameter"><code>code</code></em> 
	  afin respectivement d'afficher de mani&iuml;&iquest;&#339;re explicite le message d'erreur 
	  et de retourner un code d'erreur via.
	</p>
  </pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_fire_valid_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_special_fire_valid_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de validation des <span class="emphasis"><em>lois de tir</em></span>
  	d&iuml;&iquest;&#339;finies par routines C.
 	</p><p>
	  Ces fonctions sont appel&iuml;&iquest;&#339;es au moment de la validation d'une transition.
	  Elles permettent la m&iuml;&iquest;&#339;morisation d'informations &iuml;&iquest;&#339; cet instant
	  (comme le temps courant ou un nombre al&iuml;&iquest;&#339;atoire).	
	</p>
  </pre></div>
 
<div class="funcsynopsis"><a name="Moca.Moca13.API.Type.mapi_special_fire_trigger_proc"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
	    <b class="fsfunc">mapi_special_fire_trigger_proc</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">nb_arguments</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">arguments</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *</code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
    	</code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">number</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">nb_arguments</var>;</code></td></tr><tr><td><code>mapi_double *
    	</code>&nbsp;</td><td><code><var class="pdparam">arguments</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
	<p>
		Prototype des fonctions de tir pour les <span class="emphasis"><em>lois de tir</em></span>
		d&iuml;&iquest;&#339;finies par routines C.
	</p><p>
	  Ces fonctions re&iuml;&iquest;&#339;oivent en argument le r&iuml;&iquest;&#339;seau de Petri en cours 
	  de simulation <em class="parameter"><code>net</code></em>, la transition 
	  <em class="parameter"><code>T</code></em> &iuml;&iquest;&#339; tirer, le num&iuml;&iquest;&#339;ro <em class="parameter"><code>number</code></em> 
	  de la loi sp&iuml;&iquest;&#339;ciale associ&iuml;&iquest;&#339; &iuml;&iquest;&#339; la transition. 
	</p><p>
	  Les arguments de la loi sont donn&iuml;&iquest;&#339;s dans le tableau 
	  <em class="parameter"><code>arguments</code></em> qui contient 
	  <em class="parameter"><code>nb_arguments</code></em> nombre r&iuml;&iquest;&#339;els. 
	  Ces arguments ont &iuml;&iquest;&#339;t&iuml;&iquest;&#339; v&iuml;&iquest;&#339;rifi&iuml;&iquest;&#339;s au pr&iuml;&iquest;&#339;alable.
	</p><p>
		La fonction doit effectuer r&iuml;&iquest;&#339;ellement le tir de la transition.
	</p>
  </pre></div>
 
</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Moca13.API.Funct"></a>Liste des diff&iuml;&iquest;&#339;rents fonctions</h4></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Funct.Extend"></a>Fonctions &iuml;&iquest;&#339; utiliser au sein de <code class="function">Moca_LoadExtend</code></h5></div></div></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_add_function"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_add_function</b>(</code></td><td><var class="pdparam">sh</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">signature</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">description</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* funct_proc)</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_shell *
      </code>&nbsp;</td><td><code><var class="pdparam">sh</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">name</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">signature</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">description</var>;</code></td></tr><tr><td><code>
      mapi_special_funct_proc </code>&nbsp;</td><td><code><var class="pdparam">(* funct_proc)</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction permet d'ajouter un op&iuml;&iquest;&#339;rateur/fonction externe au 
    sein de l'interpr&iuml;&iquest;&#339;teur de commande de Moca-RP<sup>C</sup> (<em class="parameter"><code>sh</code></em>).
  </p><p>
    Cette fonction est identifi&iuml;&iquest;&#339;s &iuml;&iquest;&#339; l'aide de son nom (<em class="parameter"><code>name</code></em>),
    de sa signature (<em class="parameter"><code>signature</code></em>) et d'un commentaire
    &iuml;&iquest;&#339;ventuel (<em class="parameter"><code>description</code></em> [peut-&iuml;&iquest;&#339;tre &iuml;&iquest;&#339; <code class="literal">NULL</code>]).
  </p><p>
    Pour plus d'informations sur la signature d'une fonction, voir 
    <a href="#">???</a>.
  </p><p>
    Le pointeur de fonction doit &iuml;&iquest;&#339;tre valide (non <code class="literal">NULL</code>), 
    est de type <a href="#Moca.Moca13.API.Type.mapi_special_funct_proc"><code class="function">mapi_special_funct_proc</code></a>,
    est appel&iuml;&iquest;&#339; &iuml;&iquest;&#339; chaque fois que l'expression doit &iuml;&iquest;&#339;tre recalcul&iuml;&iquest;&#339;e 
    et doit renvoyer un nombre r&iuml;&iquest;&#339;el correspondant &iuml;&iquest;&#339; son r&iuml;&iquest;&#339;le en fonction
    de ces param&iuml;&iquest;&#339;tres et de sa signature.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_register_special_law"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_register_special_law</b>(</code></td><td><var class="pdparam">sh</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* init_proc)</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* verif_proc)</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* delay_proc)</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_shell *
      </code>&nbsp;</td><td><code><var class="pdparam">sh</var>;</code></td></tr><tr><td><code>
      mapi_special_law_init_proc </code>&nbsp;</td><td><code><var class="pdparam">(* init_proc)</var>;</code></td></tr><tr><td><code>
      mapi_special_law_verif_proc </code>&nbsp;</td><td><code><var class="pdparam">(* verif_proc)</var>;</code></td></tr><tr><td><code>
      mapi_special_law_delay_proc </code>&nbsp;</td><td><code><var class="pdparam">(* delay_proc)</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction permet d'ajouter de nouvelles lois de d&iuml;&iquest;&#339;lai au sein de 
    l'interpr&iuml;&iquest;&#339;teur de commande de Moca-RP<sup>C</sup> (<em class="parameter"><code>sh</code></em>).
  </p><p>
    Chaque pointeur de fonction doit &iuml;&iquest;&#339;tre valide (non <code class="literal">NULL</code>) 
    et doit remplir correctement son contrat. 
    <div class="itemizedlist"><ul type="disc"><li><p>
        <em class="parameter"><code>(* init_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_law_init_proc"><code class="function">mapi_special_law_init_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e lors de la cr&iuml;&iquest;&#339;ation de la loi sp&iuml;&iquest;&#339;ciale.
        Elle sert &iuml;&iquest;&#339;ventuellement &iuml;&iquest;&#339; initialiser la loi sp&iuml;&iquest;&#339;ciale.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_law_init_proc"><code class="function">mapi_special_law_init_proc</code></a>.
      </p></li><li><p>
        <em class="parameter"><code>(* verif_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_law_verif_proc"><code class="function">mapi_special_law_verif_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e &iuml;&iquest;&#339; chaque fois que les arguments de la loi
        ont &iuml;&iquest;&#339;t&iuml;&iquest;&#339; modifi&iuml;&iquest;&#339;s (une seule fois si l'ensemble des arguments sont
        constants) afin de v&iuml;&iquest;&#339;rifier les arguments de la loi.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_law_verif_proc"><code class="function">mapi_special_law_verif_proc</code></a>.
      </p></li><li><p>
        <em class="parameter"><code>(* delay_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_law_delay_proc"><code class="function">mapi_special_law_delay_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e &iuml;&iquest;&#339; chaque fois que la transition devient
        valide et qu'il faut calculer un nouveau d&iuml;&iquest;&#339;lai de tir.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_law_delay_proc"><code class="function">mapi_special_law_delay_proc</code></a>.
      </p></li></ul></div>
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_register_special_fire"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_register_special_fire</b>(</code></td><td><var class="pdparam">sh</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* init_proc)</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* verif_proc)</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* valid_proc)</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">(* trigger_proc)</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_shell *
      </code>&nbsp;</td><td><code><var class="pdparam">sh</var>;</code></td></tr><tr><td><code>
      mapi_special_fire_init_proc </code>&nbsp;</td><td><code><var class="pdparam">(* init_proc)</var>;</code></td></tr><tr><td><code>
      mapi_special_fire_verif_proc </code>&nbsp;</td><td><code><var class="pdparam">(* verif_proc)</var>;</code></td></tr><tr><td><code>
      mapi_special_fire_valid_proc </code>&nbsp;</td><td><code><var class="pdparam">(* valid_proc)</var>;</code></td></tr><tr><td><code>
      mapi_special_fire_trigger_proc </code>&nbsp;</td><td><code><var class="pdparam">(* trigger_proc)</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction permet d'ajouter de nouvelles lois de tir au sein de 
    l'interpr&iuml;&iquest;&#339;teur de commande de Moca-RP<sup>C</sup> (<em class="parameter"><code>sh</code></em>).
  </p><p>
    Chaque pointeur de fonction doit &iuml;&iquest;&#339;tre valide (non <code class="literal">NULL</code>) 
    et doit remplir correctement son contrat. 
    <div class="itemizedlist"><ul type="disc"><li><p>
        <em class="parameter"><code>(* init_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_fire_init_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_init_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e lors de la cr&iuml;&iquest;&#339;ation de la loi sp&iuml;&iquest;&#339;ciale.
        Elle sert &iuml;&iquest;&#339;ventuellement &iuml;&iquest;&#339; initialiser la loi sp&iuml;&iquest;&#339;ciale.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_fire_init_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_init_proc</code></a>.
      </p></li><li><p>
        <em class="parameter"><code>(* verif_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_fire_verif_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_verif_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e &iuml;&iquest;&#339; chaque fois que les arguments de la loi
        ont &iuml;&iquest;&#339;t&iuml;&iquest;&#339; modifi&iuml;&iquest;&#339;s (une seule fois si l'ensemble des arguments sont
        constants) afin de v&iuml;&iquest;&#339;rifier les arguments de la loi.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_fire_verif_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_verif_proc</code></a>.
      </p></li><li><p>
        <em class="parameter"><code>(* valid_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_fire_valid_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_valid_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e &iuml;&iquest;&#339; chaque fois que la transition devient
        valide afin de m&iuml;&iquest;&#339;moriser d'&iuml;&iquest;&#339;ventuels informations.
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_fire_valid_proc"><code class="function">mapi_special_<span class="emphasis"><em>fire</em></span>_valid_proc</code></a>.
      </p></li><li><p>
        <em class="parameter"><code>(* trigger_proc)</code></em> est un pointeur de fonction
        de type <a href="#Moca.Moca13.API.Type.mapi_special_fire_trigger_proc"><code class="function">mapi_special_fire_trigger_proc</code></a>.
        Cette fonction est appel&iuml;&iquest;&#339;e lorsque la transition doit &iuml;&iquest;&#339;tre tir&iuml;&iquest;&#339;e.
        Cette fonction doit effectuer toutes les phases de tir de la transition 
        (affectation des variables, suppression de jetons dans les places amonts 
        et ajout de jeton dans les places avales)
        Pour plus d'information, voir <a href="#Moca.Moca13.API.Type.mapi_special_fire_trigger_proc"><code class="function">mapi_special_fire_trigger_proc</code></a>.
      </p></li></ul></div>
  </p>
  </pre></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Funct.Basic"></a>Fonctions g&iuml;&iquest;&#339;n&iuml;&iquest;&#339;rales sur les r&iuml;&iquest;&#339;seaux de Petri</h5></div></div></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_time"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
      <b class="fsfunc">mapi_get_time</b>(</code></td><td><var class="pdparam">net</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le temps courant de la simulation dans
    l'histoire courante du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_probability"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
      <b class="fsfunc">mapi_get_probability</b>(</code></td><td><var class="pdparam">net</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne un nombre al&iuml;&iquest;&#339;atoire r&iuml;&iquest;&#339;el dans l'intervalle [0,1[. 
    Le g&iuml;&iquest;&#339;n&iuml;&iquest;&#339;rateur de nombre au hasard utilis&iuml;&iquest;&#339; est celui de la simulation
    en cours pour le r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_add_warning"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_add_warning</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">warning</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">warning</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction permet d'ajouter un avertissement 
    <em class="parameter"><code>warning</code></em> lors de la simulation 
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p><p>
    Ces avertissements seront affich&iuml;&iquest;&#339;s &iuml;&iquest;&#339; la fin de la simulation.
  </p>
  </pre></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Funct.Trans"></a>Fonctions : Informations sur les transitions</h5></div></div></div><p>
  A partir d'une transition, l'API de Moca-RP<sup>C</sup> permet d'obtenir les informations 
  concernant les places en amont et en aval de la transition, ainsi que sur 
  le vecteur d'affectation compos&iuml;&iquest;&#339; de couple {variable, expression} de la transition.
</p><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_transition_name"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">char *<b class="fsfunc">mapi_get_transition_name</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le nom de la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em> sous forme d'une
    cha&iuml;&iquest;&#339;ne de caract&iuml;&iquest;&#339;res.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_number_of_input_places"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_number_of_input_places</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le nombre d'arcs entrant de la
    transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_nth_input_places"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_internal_id 
      <b class="fsfunc">mapi_get_nth_input_places</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le num&iuml;&iquest;&#339;ro interne de la place 
    associ&iuml;&iquest;&#339; au (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    arc amont de la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_weight_nth_input_edge"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_weight_nth_input_edge</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le poids du 
    (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    arc amont de la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_number_of_output_places"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_number_of_output_places</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le nombre d'arcs sortant de la
    transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_nth_output_places"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_internal_id 
      <b class="fsfunc">mapi_get_nth_output_places</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le num&iuml;&iquest;&#339;ro interne de la place 
    associ&iuml;&iquest;&#339; au (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    arc aval de la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_weight_nth_ouput_edge"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_weight_nth_ouput_edge</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le poids du 
    (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    arc aval de la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_number_of_affect_variable"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_number_of_affect_variable</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le nombre d'affectation associ&iuml;&iquest;&#339;e &iuml;&iquest;&#339; la
    transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  <p>
    Dans le cas d'une transition de type affectation it&iuml;&iquest;&#339;rative, cette fonction renvoie -1.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_nth_affect_variable"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_expression *
      <b class="fsfunc">mapi_get_nth_affect_variable</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la 
    (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    variable "affect&iuml;&iquest;&#339;e" &iuml;&iquest;&#339; la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    Il s'agit de la variable &iuml;&iquest;&#339; affecter.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_nth_affect_expression"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_expression *
      <b class="fsfunc">mapi_get_nth_affect_expression</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">T</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">idx</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_transition *
      </code>&nbsp;</td><td><code><var class="pdparam">T</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">idx</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la 
    (<em class="parameter"><code>idx</code></em>-1)<sup>i&iuml;&iquest;&#339;me</sup> 
    expression "affect&iuml;&iquest;&#339;e" &iuml;&iquest;&#339; la transition <em class="parameter"><code>T</code></em>
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    Il s'agit de la valeur de l'affectation.
  </p>
  </pre></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Funct.Place"></a>Fonctions : Informations sur les places et les variables</h5></div></div></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_place_internal_ident"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_internal_id
      <b class="fsfunc">mapi_get_place_internal_ident</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">P</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_external_id
      </code>&nbsp;</td><td><code><var class="pdparam">P</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction transforme un num&iuml;&iquest;&#339;ro de place externe 
    <em class="parameter"><code>P</code></em> (d&iuml;&iquest;&#339;crit par le constructeur du r&iuml;&iquest;&#339;seau
    de Petri) en un num&iuml;&iquest;&#339;ro de place interne au r&iuml;&iquest;&#339;seau de Petri
    <em class="parameter"><code>net</code></em>.
  </p><p>
    Si la place externe <em class="parameter"><code>P</code></em> n'existe pas, 
    cette fonction retourne -1.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_place_marking"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_place_marking</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">P</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_internal_id
      </code>&nbsp;</td><td><code><var class="pdparam">P</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le marquage courant (nombre de jeton) 
    de la place identifi&iuml;&iquest;&#339; par le num&iuml;&iquest;&#339;ro interne <em class="parameter"><code>P</code></em> 
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_expression"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_expression *
    <b class="fsfunc">mapi_get_expression</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">name</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la variable ou le param&iuml;&iquest;&#339;tre
    associ&iuml;&iquest;&#339; au nom <em class="parameter"><code>name</code></em> au sein 
    du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    Si cette variable n'existe pas, elle renvoie
    <code class="literal">NULL</code>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_expression_value"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
      <b class="fsfunc">mapi_get_expression_value</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">expr</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_expression *
      </code>&nbsp;</td><td><code><var class="pdparam">expr</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la valeur courante de l'expression
    <em class="parameter"><code>expr</code></em> du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_table"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_table *
    <b class="fsfunc">mapi_get_table</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
    </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>char *</code>&nbsp;</td><td><code><var class="pdparam">name</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne le tableau associ&iuml;&iquest;&#339; au nom 
    <em class="parameter"><code>name</code></em> au sein du r&iuml;&iquest;&#339;seau de Petri 
    <em class="parameter"><code>net</code></em>.
    Si ce tableau n'existe pas, elle renvoie <code class="literal">NULL</code>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_table_size"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">int <b class="fsfunc">mapi_get_table_size</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tab</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_table *
      </code>&nbsp;</td><td><code><var class="pdparam">tab</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la taille du tableau <em class="parameter"><code>tab</code></em> au sein 
	du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_get_table_value_at"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">mapi_double 
      <b class="fsfunc">mapi_get_table_value_at</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tab</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">index</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_table *
      </code>&nbsp;</td><td><code><var class="pdparam">tab</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">index</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction retourne la <em class="parameter"><code>index</code></em><sup>i&iuml;&iquest;&#339;me</sup> 
    valeur courante du tableau <em class="parameter"><code>tab</code></em> du r&iuml;&iquest;&#339;seau de Petri 
    <em class="parameter"><code>net</code></em>.
  </p>
  <p>
    <em class="parameter"><code>index</code></em> doit &iuml;&iquest;&#339;tre compris entre 1 et la taille du tableau
    <em class="parameter"><code>tab</code></em>.
  </p>
  </pre></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="Moca.Moca13.API.Funct.Set"></a>Fonctions de modification du r&iuml;&iquest;&#339;seau</h5></div></div></div><p>
Ces fonctions ne doivent &iuml;&iquest;&#339;tre appel&iuml;&iquest;&#339;es que lors du tir d'une transition.
</p><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_set_place_marking"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_set_place_marking</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">P</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mark</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_internal_id
      </code>&nbsp;</td><td><code><var class="pdparam">P</var>;</code></td></tr><tr><td><code>int </code>&nbsp;</td><td><code><var class="pdparam">mark</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction fixe au sein du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    le marquage courant de la place identifi&iuml;&iquest;&#339; par le num&iuml;&iquest;&#339;ro interne 
    <em class="parameter"><code>P</code></em> &iuml;&iquest;&#339; la valeur <em class="parameter"><code>mark</code></em>.
  </p>
  </pre></div><div class="funcsynopsis"><a name="Moca.Moca13.API.Funct.mapi_set_expression_value"></a><table style="padding-bottom: 1em" cellpadding="0" cellspacing="0" summary="Function synopsis" border="0"><tr><td><code class="funcdef">void <b class="fsfunc">mapi_set_expression_value</b>(</code></td><td><var class="pdparam">net</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">expr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table cellpadding="0" cellspacing="0" summary="Function argument synopsis" border="0"><tr><td><code>mapi_net *
      </code>&nbsp;</td><td><code><var class="pdparam">net</var>;</code></td></tr><tr><td><code>mapi_expression *
      </code>&nbsp;</td><td><code><var class="pdparam">expr</var>;</code></td></tr><tr><td><code>mapi_double 
      </code>&nbsp;</td><td><code><var class="pdparam">value</var>;</code></td></tr></table><pre class="funcsynopsisinfo">
  <p>
    Cette fonction fixe au sein du r&iuml;&iquest;&#339;seau de Petri <em class="parameter"><code>net</code></em>.
    la valeur de l'expression <em class="parameter"><code>expr</code></em> 
    &iuml;&iquest;&#339; la valeur <em class="parameter"><code>value</code></em>.
  </p>
  </pre></div></div></div></div></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="Moca.Moca10"></a>A.&nbsp;Lecture de fichiers au format Moca10</h2><p> 
		Le format de donn&eacute;es de la version actuel de Moca-RP<sup>C</sup> n'est pas compatible avec les 
		versions pr&eacute;c&eacute;dentes. Pour des raisons de compatibilit&eacute;, il est tout de 
		m&ecirc;me possible d'ouvrir directement au sein de la version actuelle des fichiers 
		dans l'ancien format. 
	</p><p> 
		Dans la suite de cette annexe nous appellerons l'ancien format de donn&eacute;es le format 
		Moca10 bien qu'en r&eacute;alit&eacute;, il s'agit du format de donn&eacute;e pour les versions 8.x, 
		9.X et 10.x du logiciel Moca-RP<sup>C</sup>.
	</p><p> 
		Le format Moca10 est d&eacute;crit en d&eacute;tail dans le manuel utilisateur de la version pr&eacute;c&eacute;dente 
		de Moca-RP<sup>C</sup> (G&eacute;rald Point. Manuel de l'Utilisateur Moca-RP<sup>C</sup> 10.04 (R&eacute;vision 0). 
		IXI, R&eacute;f. : ISI184/PTGD/MU/1004-0, f&eacute;vrier 2000)
	</p><p> 
		Pour charger un fichier au format Moca10 dans l'interpr&eacute;teur de commandes, il suffit 
		d'utiliser la commande <code class="code">load Moca10 "&lt;file-in&gt;" "&lt;options&gt;";</code> o&ugrave; 
		<code class="code">&lt;file-in&gt;</code> est le nom du fichier &agrave; interpr&eacute;ter encadr&eacute; par des guillemets et 
		<code class="code">&lt;options&gt;</code> des &eacute;ventuels options.
	</p><p> 
		Cette commande interpr&egrave;te le fichier <code class="code">&lt;file-in&gt;</code> et traduit le r&eacute;seau de 
		Petri au format Moca10 en un r&eacute;seau de Petri au format actuel nomm&eacute; <code class="code">&lt;file-in&gt;</code>. 
	</p><p> 
		La traduction concerne principalement les points suivants :
		<div class="itemizedlist"><ul type="disc" compact><li>
				Les param&egrave;tres nomm&eacute;s sont transform&eacute;s en constantes. 
			</li><li>
				Les lois &agrave; la sollicitation sont traduites en lois de d&eacute;lai et de tir &eacute;quivalent. 
			</li><li>
				Les lois optionnelles sont transform&eacute;es en loi de base avec des param&egrave;tres d&eacute;finis 
				&agrave; l'aide d'expression.
			</li><li>
				La loi exponentielle + wow &agrave; 13 param&egrave;tres est traduite dans son &eacute;quivalent &agrave; 2 
				param&egrave;tres avec une expression faisant intervenir l'op&eacute;rateur time(). 
			</li></ul></div>
	</p><p> 
		Il existe des options suppl&eacute;mentaires lors de l'ouverture du fichier de donn&eacute;es : 
		<div class="itemizedlist"><ul type="disc" compact><li>
				<code class="code">-name &lt;id-net&gt;</code>  : o&ugrave; <code class="code">&lt;id-net&gt;</code> est le nom de 
				r&eacute;seau de Petri (&agrave; la place de <code class="code">&lt;file-in&gt;</code>). 
			</li><li>
				<code class="code">-cmd &lt;file-cmd&gt;</code> : o&ugrave; <code class="code">&lt;file-cmd&gt;</code> est le nom du 
				fichier o&ugrave; sera &eacute;crit toutes les commandes permettant de faire une 
				simulation identique &agrave; celle qui devait &ecirc;tre fait par le fichier au format Moca10. 
			</li><li>
				<code class="code">-out &lt;file-out&gt;</code> : o&ugrave; <code class="code">&lt;file-out&gt;</code> est le nom du 
				fichier o&ugrave; sera redirig&eacute; l'affichage des r&eacute;sultats. 
				Cette option n'a de sens que si la pr&eacute;c&eacute;dente est &eacute;galement pr&eacute;sente. 
			</li></ul></div>
		Ces options doivent &ecirc;tre plac&eacute;es entre les guillemets.
	</p><p>
		Par exemple la commande suivante <code class="code">load Moca10 "test.mk10" "&ndash;name test &ndash;cmd cmd.mok &ndash;out test.res";</code> 
		ajoute au sein de l'interpr&eacute;teur de commandes le r&eacute;seau de Petri nomm&eacute; test issu de la traduction du fichier 
		<code class="code">test.mk10</code> et cr&eacute;e le fichier de commande <code class="code">cmd.mok</code>. 
		La simulation peut &ecirc;tre lanc&eacute;e &agrave; l'aide de la commande <code class="code">load "cmd.mok";</code>. 
		Les r&eacute;sultats doivent &ecirc;tre similaires &agrave; une simulation du fichier <code class="code">test.mk10</code> r&eacute;alis&eacute; &agrave; l'aide 
		d'une ancienne version de Moca-RP<sup>C</sup>. Ces r&eacute;sultats sont alors affich&eacute;s dans le fichier <code class="code">test.res</code>. 
	</p></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="Moca.Aralia"></a>B.&nbsp;Lecture de fichiers au format Aralia</h2><p> 
		Aralia est un package BDD (Diagramme de D&eacute;cision Binaire) sp&eacute;cialis&eacute; dans le traitement 
		des mod&egrave;les bool&eacute;ens d'analyse des risques. Son principal avantage est qu'il fournit un 
		r&eacute;sultat exact tant d'un point qualitatif que quantitatif et ceci de mani&egrave;re rapide. 
		Son principal inconv&eacute;nient est qu'il s'agit d'un logiciel "tout ou rien". 
		Il arrive soit &agrave; traiter la formule bool&eacute;enne dans des temps raisonnables, soit il &eacute;choue. 
		De plus, dans le cas de composants r&eacute;parables, il ne peut calculer que la disponibilit&eacute; du syst&egrave;me. 
		Les calculs d'approximation de la fiabilit&eacute; ne sont &lsquo;valables' que pour des &eacute;v&eacute;nements ayant 
		des taux de panne et de r&eacute;paration exponentiel (loi exponentiel et GLM). 
	</p><p> 
		Pour des raisons exp&eacute;rimentales et afin d'avoir un moyen correct d'&eacute;valuer la fiabilit&eacute; d'un 
		syst&egrave;me de s&ucirc;ret&eacute; d&eacute;crit &agrave; l'aide d'un arbre de d&eacute;faillance, un module de chargement de 
		formule au format Aralia a &eacute;t&eacute; d&eacute;velopp&eacute; au sein de Moca-RP<sup>C</sup>. 
	</p><p> 
		Ce module prend en param&egrave;tre une formule bool&eacute;enne au format Aralia et le traduit en r&eacute;seau de Petri : 
		<div class="itemizedlist"><ul type="disc" compact><li>
				Les param&egrave;tres nomm&eacute;s sont repr&eacute;sent&eacute;s dans Moca-RP<sup>C</sup> comme des variables r&eacute;elles. 
			</li><li>
				Les &eacute;v&eacute;nements de base sont simul&eacute;s &agrave; l'aide de petits r&eacute;seaux de Petri ind&eacute;pendants 
				suivant leur loi de probabilit&eacute;. 
			</li><li>
				Les formules bool&eacute;ennes sont d&eacute;finies &agrave; l'aide de variables et d'expressions bool&eacute;ennes 
				au sein du r&eacute;seau de Petri. 
			</li><li>
				Des observateurs (&eacute;tat statistiques) sont ajout&eacute;s pour les variables bool&eacute;ennes. 
			</li><li>
				Des r&eacute;seaux de Petri sont ajout&eacute;s afin de capturer la fiabilit&eacute; des &eacute;v&eacute;nements 
				sommets de l'arbre. 
			</li></ul></div>
	</p><p> 
		Il existe un certain nombre de limites quand &agrave; l'utilisation de ce traducteur :. 
		<div class="itemizedlist"><ul type="disc"><li>
				Les op&eacute;rateurs bool&eacute;ens suivant ne sont pas pris en compte (ils g&eacute;n&egrave;rent une erreur) : 
				les implications, si et seulement si, ou exclusif, quantificateurs existentiel et universel 
			</li><li>
				Certaines lois de probabilit&eacute; ne peuvent pas ou non pas &eacute;t&eacute; traduites en r&eacute;seau de Petri : 
				bound-time, factor (utilis&eacute; dans les cas de d&eacute;faillance de cause commune), dormant, 
				plus de nombreuses lois Aralia V4 (non pr&eacute;sente au sein de Aralia WorkShop) 
			</li></ul></div>
	</p><p> 
		La correspondance entre les lois de probabilit&eacute;s et les r&eacute;seaux de Petri simulant les &eacute;v&eacute;nements 
		de base utilisant ces lois est d&eacute;finit &agrave; l'aide du tableau suivant :
	</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td> <p>
					Loi Aralia
				</p> </td><td> <p>
					R&eacute;seau de Petri &eacute;quivalent
				</p> </td></tr><tr><td> <code class="code">constant q 
(Et les &eacute;quivalents : 
GLM-Asymptotic, NRD, CMT)</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-Constant.gif"></span> </td></tr><tr><td> <code class="code">exponential l</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-Exponential.gif"></span></td></tr><tr><td> <code class="code">Dirac d</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-Dirac.gif"></span></td></tr><tr><td> <code class="code">uniform min max</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-Uniform.gif"></span></td></tr><tr><td> <code class="code">GLM g l m</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-GLM.gif"></span></td></tr><tr><td> <code class="code">Weibull a, b, t0</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-Weibull.gif"></span></td></tr><tr><td> <code class="code">periodic-test 
l, P, t0</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-PeriodicTest3.gif"></span></td></tr><tr><td> <code class="code">periodic-test 
l, m, P, t0</code> </td><td align="center"> <span class="inlinemediaobject"><img src="Aralia/Aralia-PeriodicTest4.gif"></span></td></tr><tr><td> <code class="code">periodic-test 
l, l*, m, t, q, 
g, p, x, s, w</code> </td><td align="left">
				Traiter comme une loi test p&eacute;riodique &agrave; 11 param&egrave;tres <code class="code">periodic-test l, l*, m, t, q, g, p, x, s, 0, w</code> 
				</td></tr><tr><td> <code class="code">periodic-test 
l, l*, m, t, q, 
g, p, x, s, w1, w2</code> </td><td align="center"> 
					<span class="inlinemediaobject"><img src="Aralia/Aralia-PeriodicTest11a.gif"></span>
					<span class="inlinemediaobject"><img src="Aralia/Aralia-PeriodicTest11b.gif"></span>
				</td></tr></tbody></table></div><p> 
		Pour charger une formule bool&eacute;enne dans Moca, il suffit 
		d'utiliser la commande <code class="code">load Aralia "&lt;file-in&gt;" "&lt;options&gt;";</code> o&ugrave; 
		<code class="code">&lt;file-in&gt;</code> contient la formule bool&eacute;enne consid&eacute;r&eacute;e (ainsi que les lois 
		des &eacute;v&eacute;nements de base) au format Aralia et <code class="code">&lt;options&gt;</code> des &eacute;ventuels options.
	</p><p> 
		Les options suppl&eacute;mentaires sont les suivantes :
		<div class="itemizedlist"><ul type="disc" compact><li>
				<code class="code">-name &lt;id-net&gt;</code> : o&ugrave; <code class="code">&lt;id-net&gt;</code> est le nom de 
				r&eacute;seau de Petri (&agrave; la place de Aralia).
			</li><li>
				<code class="code">-all</code> : permet d'ajouter un observateur pour toutes les variables de 
				la formule bool&eacute;enne. Dans le cas contraire, un observateur est ajout&eacute; uniquement 
				pour les variables sommets. 
			</li><li>
				<code class="code">-duration &lt;int&gt;</code> : permet de sp&eacute;cifier la dur&eacute;e d'histoire du 
				r&eacute;seau. 
			</li><li>
				<code class="code">-hst</code> : pr&eacute;cise qu'un histogramme est associ&eacute; &agrave; chaque observateur du 
				r&eacute;seau. 
			</li><li>
				<code class="code">-times &lsquo;&lt;times&gt;'</code> : permet de sp&eacute;cifier les diff&eacute;rents temps de 
				calcul pour les &eacute;tats statistiques. Cf. <a href="#Moca.Moca12.Options" title="Rubrique : Options">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Options&nbsp;&raquo;</a> 
				pour la syntaxe de <code class="code">&lt;times&gt;</code>. 
			</li><li>
				<code class="code">-types &lsquo;&lt;types&gt;'</code> : permet de sp&eacute;cifier les types de statistiques
				&agrave; effectuer. Cf. <a href="#Moca.Moca12.Types" title="Rubrique : Type de statistiques">la section intitul&eacute;e &laquo;&nbsp;Rubrique : Type de statistiques&nbsp;&raquo;</a> pour une d&eacute;finition des types de calcul et de 
				la syntaxe de <code class="code">&lt;types&gt;</code>. 
				Dans le cas d'un calcul de fiabilit&eacute; et de disponibilit&eacute; instantan&eacute;e (&eacute;quivalence 
				avec Aralia), le type 2 est &agrave; prendre en compte. 
			</li></ul></div>
	</p><p>
		Apr&egrave;s exp&eacute;rimentation, on se rend compte rapidement des limites d'une telle solution pour 
		quantifier un arbre de d&eacute;faillance. 
	</p><p>
		Cette d&eacute;marche n'est applicable qu'en cas de probabilit&eacute; d'occurrence 
		(fiabilit&eacute; et/ou disponibilit&eacute;) mesurable ou significative (sup&eacute;rieur &agrave; 10<sup>-4</sup>). 
	</p><p>
		Pour avoir un estimateur statistique correct d'un &eacute;v&eacute;nement ayant une probabilit&eacute; d'occurrence
		de 10<sup>-6</sup>, il convient de r&eacute;aliser au minimum 
		10<sup>+8</sup> histoires. Cela engendre un temps de calcul 
		d&eacute;raisonnable et interdit l'utilisation de cette m&eacute;thode lorsque la probabilit&eacute; d'occurrence 
		de l'&eacute;v&eacute;nement consid&eacute;r&eacute; est inf&eacute;rieure &agrave; cette valeur.
		Le nombre d'histoires maximum est de la taille d'un entier sur 32 bits, 
		soit 2<sup>31</sup>-1 = 2 147 483 647 ~ 2.10<sup>+9</sup>.
	</p></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="Moca.Compute"></a>C.&nbsp;Calcul de la moyenne et de la variance</h2><p> 
    Cette annexe pr&eacute;cise la mani&egrave;re de calculer la moyenne et la variance lors d'une 
    simulation standard et lors d'une simulation par lots (batch), en prenant en compte 
    les probl&egrave;mes de pr&eacute;cision de calcul qui sont engendr&eacute;s par un nombre de 
    simulations toujours plus important.
  </p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Compute.Simul"></a>Lors de la simulation</h3></div></div></div><p> 
      Afin de garantir une bonne pr&eacute;cision des calculs, il convient de trouver une 
      formule de r&eacute;currence pour la moyenne (not&eacute; M<sub>N</sub>) et 
      la variance (not&eacute; V<sub>N</sub>) d'un &eacute;chantillon contenant N 
      donn&eacute;es x<sub>1</sub>, &hellip;, x<sub>N</sub>. 
      C'est-&agrave;-dire, trouvez M<sub>N+1</sub> et V<sub>N+1</sub> 
      en ne connaissant que M<sub>N</sub>, V<sub>N</sub>, N 
      et X<sub>N+1</sub>.
    </p><p> 
      Pour la moyenne, il est ais&eacute; de v&eacute;rifier l'&eacute;quation suivante :
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-001.gif" align="left"></div></div>  
    </p><p> 
      La variance VN s'exprime &agrave; l'aide de la formule :
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-002.gif" align="left"></div></div>  
    </p><p> 
      En d&eacute;veloppant cette formule, nous obtenons l'&eacute;quation suivante :
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-003.gif" align="left"></div></div>  
    </p><p> 
      En passant &agrave; N+1, nous obtenons :
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-004.gif" align="left"></div></div>  
    </p><p> 
      En reprenant la d&eacute;finition de la moyenne et de la variance, nous obtenons :
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-005.gif" align="left"></div></div>  
    </p><p> 
      D'o&ugrave;
      <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/N-100.gif" align="left"></div></div>  
    </p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="Moca.Compute.Merge"></a>Lors de la fusion de 2 lots</h3></div></div></div><p> 
      La parall&eacute;lisassion d'une simulation de Monte-Carlo engendre un traitement 
      par lot. Chaque lot est caract&eacute;ris&eacute; par la graine initiale du g&eacute;n&eacute;rateur de 
      nombre al&eacute;atoire, sa taille, la moyenne et la variance de chacun des 
      estimateurs statistiques de la simulation. 
      Il est alors n&eacute;cessaire de calculer la moyenne et la variance de chacun des 
      estimateurs statistiques pour l'ensemble des lots (et donc des histoires simul&eacute;es).
    </p><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Compute.Merge.Intro"></a>Pr&eacute;sentation</h4></div></div></div><p> 
        Plut&ocirc;t que de travailler sur l'ensemble des lots calcul&eacute;s, il nous est apparu 
        logique de partir du premier lot et d'ajouter les r&eacute;sultats des autres lots 
        un &agrave; un afin de garantir au mieux la pr&eacute;cision des calculs (de la mani&egrave;re 
        analogue &agrave; une formule de r&eacute;currence).
      </p><p> 
        Soit 2 &eacute;chantillons A et B. 
        L'&eacute;chantillon A comporte n donn&eacute;es a<sub>1</sub>, ..., a<sub>n</sub>. 
        L'&eacute;chantillon B, m donn&eacute;es b<sub>1</sub>, ..., b<sub>m</sub>. 
        Soit M<sub>A</sub> et M<sub>B</sub> les moyennes des 
        &eacute;chantillons A et B ; et V<sub>A</sub> et V<sub>B</sub>, 
        leurs variances.
      </p><p> 
        Nous rappelons leurs expressions :
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-001.gif" align="left"></div></div>  
      </p><p> 
        Nous recherchons la moyenne M<sub>C</sub> et la variance 
        V<sub>C</sub> de l'&eacute;chantillon C compos&eacute; de n+m donn&eacute;es 
        a<sub>1</sub>, ... , a<sub>n</sub>, 
        b<sub>1</sub>, ... , b<sub>m</sub>.
      </p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Compute.Merge.Math"></a>D&eacute;veloppements math&eacute;matiques</h4></div></div></div><p> 
        La moyenne M<sub>C</sub> ne pose pas de difficult&eacute;s : 
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-002.gif" align="left"></div></div>  
      </p><p> 
        La variance V<sub>C</sub> s'exprime &agrave; l'aide de la formule :
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-003.gif" align="left"></div></div>  
      </p><p> 
        En d&eacute;veloppant cette formule, nous obtenons les &eacute;quations suivantes :
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-004.gif" align="left"></div></div>  
      </p><p> 
        Il convient alors de revenir aux d&eacute;finitions des variances de A et de B : 
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-005.gif" align="left"></div></div>  
      </p><p> 
        Et pour finir on obtient alors :
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-006.gif" align="left"></div></div>  
      </p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="Moca.Compute.Merge.Result"></a>R&eacute;sultats</h4></div></div></div><p> 
        A partir de deux &eacute;chantillons (A et B) dont nous ne connaissons que la taille 
        (respectivement n et m), la moyenne (M<sub>A</sub> et M<sub>B</sub>) 
        et la variance (V<sub>A</sub> et V<sub>B</sub>), nous 
        pouvons calculer la taille (n+m), la moyenne (M<sub>C</sub>) et 
        la variance (V<sub>C</sub>) de l'union des deux &eacute;chantillons &agrave; 
        l'aide des &eacute;quations :
        <div class="informalfigure"><div class="mediaobject" align="left"><img src="Compute/B-100.gif" align="left"></div></div>  
      </p></div></div></div><p><a name="last-page"></a></p></div></body></html>